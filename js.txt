//location-sharing.js
// === 設定 ===
const CONFIG = {
    LOCATION_TIMEOUT: 20000,
    RECONNECT_BASE_DELAY: 1000,
    RECONNECT_MULTIPLIER: 1.5,
    RECONNECT_MAX_DELAY: 30000,
    CONNECTION_CHECK_INTERVAL: 5000,
    BACKGROUND_UPDATE_INTERVAL: 15000,
    BACKGROUND_KEEPALIVE_INTERVAL: 20000,
    PARTICIPANTS_UPDATE: 2000,
    MAX_TIME_WITHOUT_UPDATE: 30000,
    POSITION_CACHE_DURATION: 7 * 24 * 60 * 60 * 1000,
    MOVEMENT_THRESHOLD: 3,
    MIN_TIME_BETWEEN_UPDATES: 1000,
    CLUSTERING_DISTANCE: 30, 
    CLUSTER_OFFSET_RADIUS: 33,
};

// === ストレージキー ===
const STORAGE_KEYS = {
    SESSION_STATE: `locationSharing_${window.djangoData.sessionId}`,
    STAY_TIME_TRACKER: 'stay_time_tracker'
};

// === 状態管理クラス ===
class LocationSharingState {
    constructor() {
        // =====================
        // 基本状態
        // =====================
        /** @type {boolean} 共有中かどうか */
        this.isSharing = false;

        /** @type {string|null} 一時的な参加者ID（サーバ側付与など） */
        this.participantId = null;

        /** @type {string|null} ★ 永続的な参加者ID（クライアント生成・保存） */
        this.persistentParticipantId = null;

        /** @type {string|null} ★ セッションフィンガープリント（UA等から生成） */
        this.sessionFingerprint = null;

        /** @type {boolean} セッション期限切れフラグ */
        this.sessionExpired = false;

        /** @type {boolean} ユーザー操作があったか */
        this.userInteracted = false;

        /** @type {boolean} 自動フィット有効 */
        this.autoFitEnabled = true;

        /** @type {boolean} バックグラウンド状態か */
        this.isInBackground = false;

        /** @type {string|null} 追従中の参加者ID */
        this.followingParticipantId = null;

        /** @type {string|null} 追従中のグループ */
        this.followingGroup = null;

        /** @type {boolean} 退出処理中か */
        this.isLeaving = false;

        /** @type {boolean} 退出処理の多重起動防止 */
        this._leavingProcessStarted = false;

        // =====================
        // 位置情報
        // =====================
        /** @type {GeolocationPosition|null} 最後に取得した位置 */
        this.lastKnownPosition = null;

        /** @type {GeolocationPosition|null} 最後に送信した位置 */
        this.lastSentPosition = null;

        /** @type {number} 最後に送信したUNIX時刻(ms) */
        this.lastSentTime = 0;

        // =====================
        // 接続状態
        // =====================
        /** @type {number} 再接続試行回数 */
        this.reconnectAttempts = 0;

        /** @type {number} 背景時の再接続試行回数 */
        this.backgroundReconnectAttempts = 0;

        /** @type {Date|null} 直近の成功接続時刻 */
        this.lastSuccessfulConnection = null;

        /** @type {boolean} 再接続動作中か */
        this.isReconnecting = false;

        // =====================
        // データ
        // =====================
        /** @type {Array<any>} 参加者一覧（表示・計算用） */
        this.participantsData = [];

        /** @type {Array<string>} 表示順を保持するID配列 */
        this.participantOrder = [];

        /** @type {Record<string,string>} 参加者ID→色のマップ */
        this.participantColors = {};

        /** @type {Map<string, any>} 直前の参加者状態（差分検出用など） */
        this.previousParticipantsState = new Map();

        // =====================
        // セッション情報
        // =====================
        const dj = (typeof window !== 'undefined' && window.djangoData) ? window.djangoData : {};
        /** @type {string|undefined} サーバ側セッションID */
        this.sessionId = dj?.sessionId;

        /** @type {Date} セッション有効期限 */
        this.expiresAt = new Date(dj?.expiresAt || Date.now());

        // 永続IDとフィンガープリントの生成
        this.initPersistentIds();

        // 前回保存状態の復元
        this.load();
    }

    // ======================================================================
    // 永続ID / フィンガープリント生成
    // ======================================================================

    /**
     * 永続的な参加者IDとセッションフィンガープリントを初期化
     * - localStorage から取得できなければ生成して保存
     */
    initPersistentIds() {
        // 永続的な参加者IDを生成/取得
        try {
            const storedPersistentId = this._safeLocalStorageGetItem('persistent_participant_id');
            if (storedPersistentId) {
                this.persistentParticipantId = storedPersistentId;
            } else {
                this.persistentParticipantId = this.generateUUID();
                this._safeLocalStorageSetItem('persistent_participant_id', this.persistentParticipantId);
            }
        } catch (e) {
            // localStorage 不可でも動作継続（ただし永続不可）
            this.persistentParticipantId = this.generateUUID();
        }

        // セッションフィンガープリントを生成
        this.sessionFingerprint = this.generateSessionFingerprint();
    }

    /**
     * RFC4122 v4風のUUIDを生成
     * - crypto.getRandomValues が使える場合はそちらを優先
     * - 使えない場合は従来の Math.random 実装にフォールバック（元の挙動を維持）
     */
    generateUUID() {
        // 可能なら Web Crypto API を使用
        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
            const buf = new Uint8Array(16);
            crypto.getRandomValues(buf);
            // RFC4122 variant & version
            buf[6] = (buf[6] & 0x0f) | 0x40; // version 4
            buf[8] = (buf[8] & 0x3f) | 0x80; // variant 10
            const toHex = (n) => n.toString(16).padStart(2, '0');
            const hex = Array.from(buf, toHex).join('');
            return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
        }

        // フォールバック
        // eslint-disable-next-line no-bitwise
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            // eslint-disable-next-line no-bitwise
            const r = Math.random() * 16 | 0;
            // eslint-disable-next-line no-bitwise
            const v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }

    /**
     * セッションフィンガープリントを生成
     * - UA / 言語 / プラットフォーム / 画面解像度 / タイムゾーンを結合し簡易ハッシュ
     * - 既存のアルゴリズムを維持
     * @returns {string}
     */
    generateSessionFingerprint() {
        const userAgent = (typeof navigator !== 'undefined' && navigator.userAgent) ? navigator.userAgent : 'unknownUA';
        const language = (typeof navigator !== 'undefined' && navigator.language) ? navigator.language : 'unknownLang';
        const platform = (typeof navigator !== 'undefined' && navigator.platform) ? navigator.platform : 'unknownPlatform';
        const screenResolution = (typeof screen !== 'undefined' && screen.width && screen.height) ?
            `${screen.width}x${screen.height}` :
            '0x0';
        const timezone = (() => {
            try {
                return Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknownTZ';
            } catch {
                return 'unknownTZ';
            }
        })();

        const fingerprint = `${userAgent}_${language}_${platform}_${screenResolution}_${timezone}`;

        // 簡単なハッシュ関数でフィンガープリントを生成
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
            const char = fingerprint.charCodeAt(i);
            // eslint-disable-next-line no-bitwise
            hash = ((hash << 5) - hash) + char;
            // eslint-disable-next-line no-bitwise
            hash = hash & hash; // 32bit に収める
        }

        return Math.abs(hash).toString(36);
    }

    // ======================================================================
    // 状態の保存 / 復元 / クリア
    // ======================================================================

    /**
     * 現在状態の一部を localStorage に保存
     * - 既存の保存項目・構造は変更しない
     */
    save() {
        try {
            const stateToSave = {
                isSharing: this.isSharing,
                participantName: this.getParticipantName(),
                lastPosition: this.lastKnownPosition ? {
                    latitude: this.lastKnownPosition.coords.latitude,
                    longitude: this.lastKnownPosition.coords.longitude,
                    accuracy: this.lastKnownPosition.coords.accuracy,
                    timestamp: Date.now()
                } : null,
                savedAt: Date.now(),
                // 参加者管理データも保存
                participantOrder: this.participantOrder || [],
                participantColors: this.participantColors || {},
                followingParticipantId: this.followingParticipantId || null,
                followingGroup: this.followingGroup || null
            };

            this._safeLocalStorageSetItem(STORAGE_KEYS.SESSION_STATE, JSON.stringify(stateToSave));
        } catch (error) {
            console.warn('状態保存に失敗:', error);
        }
    }

    /**
     * 保存済み状態の読み込み
     * - 参加者管理データの復元も行う
     * @returns {any|undefined} 復元した state オブジェクト
     */
    load() {
        try {
            const savedStateStr = this._safeLocalStorageGetItem(STORAGE_KEYS.SESSION_STATE);
            if (!savedStateStr) return;

            const state = JSON.parse(savedStateStr);

            // 参加者管理データを復元
            if (state.participantOrder) {
                this.participantOrder = state.participantOrder;
            }
            if (state.participantColors) {
                this.participantColors = state.participantColors;
            }
            if (state.followingParticipantId) {
                this.followingParticipantId = state.followingParticipantId;
            }
            if (state.followingGroup) {
                this.followingGroup = state.followingGroup;
            }

            return state;
        } catch (error) {
            console.warn('状態読み込みに失敗:', error);
            this.clear();
        }
    }

    /**
     * 保存情報のクリア
     * - localStorage と sessionStorage（locationSharing_ で始まるキー）を削除
     */
    clear() {
        try {
            // LocalStorage をクリア
            this._safeLocalStorageRemoveItem(STORAGE_KEYS.SESSION_STATE);
            this._safeLocalStorageRemoveItem(STORAGE_KEYS.STAY_TIME_TRACKER);

            // セッションストレージもクリア
            if (typeof sessionStorage !== 'undefined') {
                const keysToRemove = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && key.startsWith('locationSharing_')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => {
                    try {
                        sessionStorage.removeItem(key);
                    } catch (e) {
                        // 1件失敗しても他は続行
                    }
                });
            }

        } catch (error) {
            console.warn('状態クリアに失敗:', error);
        }
    }

    // ======================================================================
    // ユーティリティ
    // ======================================================================

    /**
     * 参加者名を UI から取得
     * @returns {string}
     */
    getParticipantName() {
        // ui.elements.participantName が未定義でも落ちないようガード
        try {
            // 既存の optional chaining 参照を維持
            return ui?.elements?.participantName?.value || '';
        } catch {
            return '';
        }
    }

    /**
     * - 例外（容量超過/プライベートモードなど）で落ちないようにする
     */
    _safeLocalStorageSetItem(key, value) {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem(key, value);
            }
        } catch {
            // 何もしない（永続化できない環境を許容）
        }
    }

    /**
     * localStorage.getItem
     * @returns {string|null}
     */
    _safeLocalStorageGetItem(key) {
        try {
            if (typeof localStorage !== 'undefined') {
                return localStorage.getItem(key);
            }
        } catch {
            // noop
        }
        return null;
    }

    /**
     * localStorage.removeItem
     */
    _safeLocalStorageRemoveItem(key) {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.removeItem(key);
            }
        } catch {
            // noop
        }
    }
}


// === UI管理クラス ===
class UIManager {
    constructor() {
        /** @type {Record<string, HTMLElement|null>} */
        this.elements = {};
        /** @type {Array<{element: EventTarget, event: string, handler: any, options?: AddEventListenerOptions|boolean}>} */
        this.eventListeners = [];
        /** @type {Record<string, number>} 重複通知の抑制用 */
        this.lastNotificationTime = {};
        /** @type {'connected'|'reconnecting'|'error'|'disconnected'|null} */
        this.lastWebSocketStatus = null;
        /** @type {number|null} */
        this.statusChangeTimeout = null;
        /** @type {string} 参加者HTMLの現在値 */
        this.currentParticipantsHtml = '';

        // 定数
        this.CONST = {
            NOTIF_START_TOP: 20, // px
            NOTIF_STACK_OFFSET: 80, // px
            NOTIF_RIGHT: 20, // px
            NOTIF_ZINDEX: 9999,
            NOTIF_MIN_WIDTH: 300, // px
            NOTIF_MAX_WIDTH: 400, // px
            NOTIF_LIFETIME_MS: 5000, // ms
            WS_DEBOUNCE_MS: 1000 // ms
        };

        // ステータス表示のクラス/インジケータ対応表
        this.WS_STATUS_CONFIG = {
            connected: {
                class: 'bg-success',
                indicator: 'connection-good'
            },
            reconnecting: {
                class: 'bg-warning',
                indicator: 'connection-poor'
            },
            error: {
                class: 'bg-danger',
                indicator: 'connection-bad'
            },
            disconnected: {
                class: 'bg-danger',
                indicator: 'connection-bad'
            }
        };

        this.initElements();
    }

    /**
     * 主要DOM要素のキャッシュ
     */
    initElements() {
        // getElementByIdは存在しない可能性もあるのでnull許容
        this.elements = {
            wsStatus: document.getElementById('websocket-status'),
            locationStatus: document.getElementById('location-status'),
            participantsList: document.getElementById('participants-list'),
            countdown: document.getElementById('countdown'),
            participantName: document.getElementById('participant-name'),
            toggleSharing: document.getElementById('toggle-sharing'),
            sessionStatus: document.getElementById('session-status'),
            lastCommunication: document.getElementById('last-communication')
        };
    }

    /**
     * 各種ステータス表示の更新
     * @param {'ws'|'location'|'visibility'} type
     * @param {'connected'|'reconnecting'|'error'|'disconnected'|'ok'|'warn'|'bad'} status
     * @param {string} message
     */
    updateStatus(type, status, message) {
        const element = this.elements[type + 'Status'];
        if (!element) return;

        switch (type) {
            case 'ws':
                this.updateWebSocketStatus(element, status, message);
                break;
            case 'location':
            case 'visibility': {
                // 既存：テキストとクラスを直接代入
                element.textContent = message ?? '';
                element.className = `status-${status}`;
                break;
            }
            default:
                // 未知タイプは何もしない
                break;
        }
    }

    /**
     * WebSocket ステータスの表示（デバウンス付き）
     * @param {HTMLElement} element
     * @param {'connected'|'reconnecting'|'error'|'disconnected'} status
     * @param {string} message
     */
    updateWebSocketStatus(element, status, message) {
        if (this.statusChangeTimeout) {
            clearTimeout(this.statusChangeTimeout);
        }
        if (this.lastWebSocketStatus === status) return;

        this.statusChangeTimeout = setTimeout(() => {
            this.lastWebSocketStatus = status;

            const config = this.WS_STATUS_CONFIG[status] || {
                class: 'bg-secondary',
                indicator: ''
            };

            // 既存のinnerHTML生成を維持（バッジとインジケータ）
            element.innerHTML = `
                <span class="connection-indicator ${config.indicator}"></span>
                <span class="badge ${config.class}">${message ?? ''}</span>
            `;

            this.statusChangeTimeout = null;
        }, this.CONST.WS_DEBOUNCE_MS);
    }

    /**
     * トースト通知の表示（同一メッセージの連投抑制）
     * @param {string} message
     * @param {'info'|'primary'|'secondary'|'success'|'warning'|'danger'|'light'|'dark'} [type='info']
     * @param {string|null} icon FontAwesome等のクラス
     * @param {boolean} [preventDuplicates=true]
     */
    showNotification(message, type = 'info', icon = null, preventDuplicates = true) {
        if (!message) return;

        if (preventDuplicates) {
            const now = Date.now();
            const lastTime = this.lastNotificationTime[message] || 0;
            if (now - lastTime < this.CONST.NOTIF_LIFETIME_MS) return;
            this.lastNotificationTime[message] = now;
        }

        const alertDiv = this.createNotificationElement(message, type, icon);
        this.positionNotification(alertDiv);
        document.body.appendChild(alertDiv);

        // 自動で消す
        setTimeout(() => this.removeNotification(alertDiv), this.CONST.NOTIF_LIFETIME_MS);
    }

    /**
     * 通知DOMを生成（既存のBootstrapベース）
     */
    createNotificationElement(message, type, icon) {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show realtime-notification`;
        alertDiv.setAttribute('role', 'alert');

        if (icon) {
            const iconElement = document.createElement('i');
            iconElement.className = `${icon} me-2`;
            alertDiv.appendChild(iconElement);
        }

        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        alertDiv.appendChild(messageSpan);

        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'btn-close';
        closeButton.setAttribute('aria-label', 'Close');
        closeButton.setAttribute('data-bs-dismiss', 'alert');
        alertDiv.appendChild(closeButton);

        return alertDiv;
    }

    /**
     * 画面右上に通知を積み上げ表示
     */
    positionNotification(alertDiv) {
        const existingNotifications = document.querySelectorAll('.realtime-notification');
        existingNotifications.forEach((notification) => {
            const currentTop = parseInt(notification.style.top) || this.CONST.NOTIF_START_TOP;
            notification.style.top = (currentTop + this.CONST.NOTIF_STACK_OFFSET) + 'px';
        });

        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: this.CONST.NOTIF_START_TOP + 'px',
            right: this.CONST.NOTIF_RIGHT + 'px',
            zIndex: String(this.CONST.NOTIF_ZINDEX),
            minWidth: this.CONST.NOTIF_MIN_WIDTH + 'px',
            maxWidth: this.CONST.NOTIF_MAX_WIDTH + 'px'
        });
    }

    /**
     * 通知を削除し、残りを詰める
     */
    removeNotification(alertDiv) {
        if (alertDiv?.parentNode) {
            alertDiv.remove();

            const remainingNotifications = document.querySelectorAll('.realtime-notification');
            remainingNotifications.forEach((notification) => {
                const currentTop = parseInt(notification.style.top) || (this.CONST.NOTIF_START_TOP + this.CONST.NOTIF_STACK_OFFSET);
                if (currentTop > this.CONST.NOTIF_START_TOP) {
                    notification.style.top = (currentTop - this.CONST.NOTIF_STACK_OFFSET) + 'px';
                }
            });
        }
    }

    /**
     * 共有トグルボタンの文言と色を更新
     * - 既存の global: state を参照（存在しなければ無視）
     */
    updateSharingButton() {
        const btn = this.elements.toggleSharing;
        if (!btn) return;

        // グローバル state が無い環境でも死なないように
        const isSharing = (typeof state !== 'undefined' && !!state.isSharing);

        if (isSharing) {
            btn.innerHTML = '<i class="fas fa-pause"></i> 共有停止';
            btn.className = 'btn btn-warning';
        } else {
            btn.innerHTML = '<i class="fas fa-play"></i> 共有開始';
            btn.className = 'btn btn-success';
        }
    }

    /**
     * 残り時間のカウントダウン表示
     */
    updateCountdown() {
        const el = this.elements.countdown;
        if (!el) return;

        const expiresAt = (typeof state !== 'undefined' && state.expiresAt instanceof Date) ?
            state.expiresAt :
            null;

        if (!expiresAt) {
            el.textContent = '';
            return;
        }

        const now = new Date();
        const timeLeft = +expiresAt - +now;

        if (!Number.isFinite(timeLeft)) {
            el.textContent = '';
            return;
        }

        if (timeLeft <= 0) {
            el.textContent = '期限切れ';
            // 既存動作：期限切れ時に sessionManager.handleExpired() を呼ぶ
            try {
                if (typeof sessionManager !== 'undefined' && sessionManager?.handleExpired) {
                    sessionManager.handleExpired();
                }
            } catch (_) {
                // 失敗してもUI更新は継続
            }
            return;
        }

        const hours = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

        el.textContent =
            `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    /**
     * addEventListener 登録と同時にクリーンアップリストへ格納
     */
    addEventListener(element, event, handler, options = {}) {
        if (!element || !element.addEventListener) return;
        element.addEventListener(event, handler, options);
        this.eventListeners.push({
            element,
            event,
            handler,
            options
        });
    }

    /**
     * 登録済みのイベントリスナーを一括解除
     */
    cleanup() {
        this.eventListeners.forEach(({
            element,
            event,
            handler,
            options
        }) => {
            try {
                if (element && element.removeEventListener) {
                    element.removeEventListener(event, handler, options);
                }
            } catch (_) {
                // 1件失敗しても他は続行
            }
        });
        this.eventListeners = [];
    }
}


// === WebSocket管理クラス ===
class WebSocketManager {
    constructor() {
        this.websocket = null;
        this.connectionInterval = null;

        // 状態フラグと定数
        this.isConnecting = false;
        this.errorCount = 0;

        this.CONST = {
            REINIT_DELAY_MS: 100, // 既存：再初期化待機
            OPEN_HISTORY_REQUEST_DELAY_MS: 500,
            INIT_RETRY_DELAY_MS: 2000, // 初期化失敗時の再試行
            ERROR_PAUSE_AFTER_COUNT: 5, // エラー多発で一時停止する閾値
            ERROR_PAUSE_MS: 10000 // 一時停止時間
        };
    }

    init() {
        // グローバル state 未定義ガード
        if (typeof state === 'undefined') {
            console.warn('state が未定義のため WebSocket 初期化をスキップ');
            return;
        }

        // 退出中の場合は初期化しない
        if (state.isLeaving || state.sessionExpired) {
            console.log('退出中のため WebSocket 初期化をスキップ');
            return;
        }

        // 既存の接続を確実にクリーンアップ
        if (this.websocket) {
            // イベントハンドラーを無効化
            this.websocket.onopen = null;
            this.websocket.onmessage = null;
            this.websocket.onclose = null;
            this.websocket.onerror = null;

            // 接続中または接続待機中の場合は閉じる
            if (this.websocket.readyState === WebSocket.CONNECTING ||
                this.websocket.readyState === WebSocket.OPEN) {
                try {
                    this.websocket.close(1000, 'reinitializing');
                } catch (e) {
                    console.warn('WebSocket close error during reinit:', e);
                }
            }

            this.websocket = null;

            // 少し待ってから新しい接続を開始
            setTimeout(() => {
                this.initWebSocketConnection();
            }, this.CONST.REINIT_DELAY_MS);
            return;
        }

        this.initWebSocketConnection();
    }

    // 実際のWebSocket接続処理
    initWebSocketConnection() {
        // 接続中フラグをチェック
        if (this.isConnecting) {
            console.log('既に接続処理中です');
            return;
        }

        // ★ ガード：sessionId 必須
        const sessionId = (typeof state !== 'undefined' && state.sessionId) ? state.sessionId : (window?.djangoData?.sessionId);
        if (!sessionId) {
            console.warn('sessionId が未設定のため WebSocket 接続を開始できません');
            return;
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/location/${sessionId}/`;

        if (!state.isReconnecting) {
            state.isReconnecting = true;
            // ★ ui ガード
            try {
                ui?.updateStatus?.('ws', 'reconnecting', '接続中...');
            } catch {}
        }

        try {
            this.isConnecting = true;
            this.websocket = new WebSocket(wsUrl);
            this.setupEventHandlers();
        } catch (error) {
            console.error('WebSocket初期化エラー:', error);
            try {
                ui?.updateStatus?.('ws', 'error', 'エラー');
            } catch {}
            state.isReconnecting = false;
            this.isConnecting = false;

            // エラー時は少し待ってから再試行
            setTimeout(() => {
                if (!state.isLeaving && !state.sessionExpired) {
                    this.init();
                }
            }, this.CONST.INIT_RETRY_DELAY_MS);
        }
    }

    setupEventHandlers() {
        if (!this.websocket) return;
        this.websocket.onopen = (event) => this.handleOpen(event);
        this.websocket.onmessage = (event) => this.handleMessage(event);
        this.websocket.onclose = (event) => this.handleClose(event);
        this.websocket.onerror = (error) => this.handleError(error);
    }

    handleOpen(event) {
        // 接続中フラグをリセット
        this.isConnecting = false;

        // 退出フラグを再度チェック
        const leavingFlag = (() => {
            try {
                return localStorage.getItem(`leaving_${state.sessionId}`);
            } catch {
                return null;
            }
        })();

        if (state.isLeaving || state.sessionExpired || leavingFlag === 'true') {
            console.log('退出処理中のため join メッセージをスキップ');
            try {
                this.websocket?.close();
            } catch {}
            return;
        }

        state.reconnectAttempts = 0;
        state.backgroundReconnectAttempts = 0;
        state.isReconnecting = false;
        state.lastSuccessfulConnection = Date.now();
        this.errorCount = 0; // 接続成功でリセット

        try {
            ui?.updateStatus?.('ws', 'connected', '接続中');
        } catch {}
        this.startConnectionManagement();

        this.sendJoinMessage();

        // チャット履歴を要求
        if (window.chatManager) {
            setTimeout(() => {
                const participantId = state.participantId || window.djangoData?.participantId;

                // wsManager グローバル参照のガード
                try {
                    (window.wsManager || this).send({
                        type: 'request_chat_history',
                        session_id: state.sessionId,
                        participant_id: participantId
                    });
                } catch (e) {
                    console.warn('チャット履歴要求に失敗:', e);
                }
            }, this.CONST.OPEN_HISTORY_REQUEST_DELAY_MS);
        }
    }

    handleMessage(event) {
        try {
            const data = JSON.parse(event.data);
            // messageHandler ガード
            try {
                messageHandler?.handle?.(data);
            } catch (e) {
                console.warn('messageHandler.handle 実行中に例外:', e);
            }
            state.lastSuccessfulConnection = Date.now();
        } catch (error) {
            console.error('メッセージ解析エラー:', error);
        }
    }

    // === WebSocket管理クラス
    handleClose(event) {
        this.stopConnectionManagement();
        state.isReconnecting = false;
        this.isConnecting = false;

        // 退出中の場合は再接続しない
        if (state.isLeaving || state.sessionExpired) {
            try {
                ui?.updateStatus?.('ws', 'disconnected', '切断');
            } catch {}
            // 退出中の場合は WebSocket を null にする
            this.websocket = null;
            return;
        }

        // ページ閉じによる正常終了の場合
        const isPageUnloading = !!(typeof backgroundManager !== 'undefined' && backgroundManager?.isPageUnloading);
        if (event.code === 1000 && (event.reason === 'page_unload' || event.reason === 'user_leave' || isPageUnloading)) {
            try {
                ui?.updateStatus?.('ws', 'disconnected', '切断');
            } catch {}
            return;
        }

        // 手動で閉じられた場合も再接続しない
        if (event.wasClean) {
            try {
                ui?.updateStatus?.('ws', 'disconnected', '切断');
            } catch {}
            return;
        }

        // その他の切断の場合は再接続を試行
        this.handleReconnect();
    }

    handleError(error) {
        console.error('WebSocketエラー:', error);

        // 接続中フラグをリセット
        this.isConnecting = false;
        state.isReconnecting = false;

        // エラーカウンターを追加
        this.errorCount = (this.errorCount || 0) + 1;

        // エラーが多すぎる場合は一時停止
        if (this.errorCount > this.CONST.ERROR_PAUSE_AFTER_COUNT) {
            console.warn('WebSocketエラーが頻発しているため、接続を一時停止します');
            try {
                ui?.updateStatus?.('ws', 'error', '接続エラー（一時停止中）');
            } catch {}

            // 一時停止後にリセットして再試行
            setTimeout(() => {
                this.errorCount = 0;
                if (!state.isLeaving && !state.sessionExpired) {
                    this.init();
                }
            }, this.CONST.ERROR_PAUSE_MS);
            return;
        }

        if (!state.isInBackground) {
            setTimeout(() => {
                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    try {
                        ui?.updateStatus?.('ws', 'error', 'エラー');
                    } catch {}
                }
            }, 1000);
        }
    }

    handleReconnect() {
        // 退出中または期限切れの場合は再接続しない
        if (state.sessionExpired || state.isLeaving) {
            console.log('退出中のため再接続をスキップ');
            return;
        }

        // ★ CONFIG ガードとデフォルト
        const RECONNECT_BASE_DELAY = (typeof CONFIG !== 'undefined' && CONFIG?.RECONNECT_BASE_DELAY) ? CONFIG.RECONNECT_BASE_DELAY : 1000;
        const RECONNECT_MAX_DELAY = (typeof CONFIG !== 'undefined' && CONFIG?.RECONNECT_MAX_DELAY) ? CONFIG.RECONNECT_MAX_DELAY : 15000;
        const BACKGROUND_KEEPALIVE_INTERVAL = (typeof CONFIG !== 'undefined' && CONFIG?.BACKGROUND_KEEPALIVE_INTERVAL) ? CONFIG.BACKGROUND_KEEPALIVE_INTERVAL : 60000;

        const maxAttempts = state.isInBackground ? 50 : 10;
        const currentAttempts = state.isInBackground ? state.backgroundReconnectAttempts : state.reconnectAttempts;

        if (currentAttempts < maxAttempts) {
            if (state.isInBackground) {
                state.backgroundReconnectAttempts++;
            } else {
                state.reconnectAttempts++;
            }

            const baseDelay = state.isInBackground ? 3000 : RECONNECT_BASE_DELAY;
            const delay = Math.min(
                baseDelay * Math.pow(1.2, currentAttempts),
                state.isInBackground ? 15000 : RECONNECT_MAX_DELAY
            );

            setTimeout(() => {
                // タイムアウト実行時にも再度チェック
                if (!state.isLeaving && !state.sessionExpired) {
                    this.init();
                }
            }, delay);

            // 背景時の keepalive 間隔が異常に短い場合に備えた軽いガード
            if (state.isInBackground && BACKGROUND_KEEPALIVE_INTERVAL < 5000) {
                console.warn('BACKGROUND_KEEPALIVE_INTERVAL が短すぎます（<5s）');
            }
        }
    }

    send(data) {
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            try {
                this.websocket.send(JSON.stringify(data));
                return true;
            } catch (error) {
                console.error('メッセージ送信エラー:', error);
                return false;
            }
        }
        return false;
    }

    // === WebSocket管理クラス - sendJoinMessage メソッドの修正 ===
    sendJoinMessage() {
        // participant_id が未設定の場合は djangoData から取得
        if (!state.participantId) {
            state.participantId = window.djangoData?.participantId;
        }

        const joinMessage = {
            type: 'join',
            participant_id: state.participantId,
            persistent_participant_id: state.persistentParticipantId,
            session_fingerprint: state.sessionFingerprint,
            participant_name: state.getParticipantName?.() ?? state.getParticipantName?.call?.(state) ?? '',
            is_sharing: state.isSharing,
            has_cached_position: !!state.lastKnownPosition,
            initial_status: state.isSharing ? 'sharing' : 'waiting',
            is_background: state.isInBackground,
            is_mobile: this.isMobileDevice(),
            request_existing_check: true,
            page_returning: (typeof backgroundManager !== 'undefined') ? (backgroundManager?.isPageUnloading === false) : true,
            immediate_online: !state.isInBackground,
            priority_connection: !state.isInBackground,
            deduplicate: true // 重複防止フラグ
        };

        this.send(joinMessage);
    }

    startConnectionManagement() {
        if (this.connectionInterval) clearInterval(this.connectionInterval);

        // CONFIGガード＋デフォルト
        const BACKGROUND_KEEPALIVE_INTERVAL = (typeof CONFIG !== 'undefined' && CONFIG?.BACKGROUND_KEEPALIVE_INTERVAL) ? CONFIG.BACKGROUND_KEEPALIVE_INTERVAL : 60000;
        const pingInterval = state.isInBackground ? BACKGROUND_KEEPALIVE_INTERVAL : 60000;

        this.connectionInterval = setInterval(() => {
            if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                if (!state.isReconnecting) {
                    console.warn('WebSocket接続が無効 - 再接続試行');
                    this.init();
                }
                return;
            }

            // 現在の移動速度を計算して含める
            let currentSpeed = 0;
            let isMoving = false;

            // MapManagerから現在の速度情報を取得（ガード付き）
            try {
                if (state.participantId && typeof mapManager !== 'undefined' &&
                    mapManager.speedHistory && mapManager.speedHistory[state.participantId]) {
                    const speeds = mapManager.speedHistory[state.participantId];
                    if (Array.isArray(speeds) && speeds.length > 0) {
                        currentSpeed = speeds[speeds.length - 1]; // 最新の速度
                        isMoving = currentSpeed >= 3; // 3km/h以上で移動中と判定
                    }
                }
            } catch (e) {
                // 速度情報取得失敗は無視（UIや接続に影響させない）
            }

            // Pingデータ送信（速度情報を追加）
            const pingData = {
                type: 'ping',
                participant_id: state.participantId,
                timestamp: Date.now(),
                is_sharing: state.isSharing,
                has_position: !!state.lastKnownPosition,
                is_background: state.isInBackground,
                is_mobile: this.isMobileDevice(),
                keep_connection: true,
                status: state.isSharing ? 'sharing' : 'waiting',
                // ★ 追加：速度情報
                current_speed: currentSpeed,
                is_moving: isMoving
            };

            this.send(pingData);
        }, pingInterval);
    }

    stopConnectionManagement() {
        if (this.connectionInterval) {
            clearInterval(this.connectionInterval);
            this.connectionInterval = null;
        }
    }

    isMobileDevice() {
        try {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        } catch {
            return false;
        }
    }
}


// === メッセージハンドラークラス ===
class MessageHandler {
    /**
     * 受信データのディスパッチ
     * @param {any} data
     */
    handle(data) {
        if (!data || typeof data.type !== 'string') return;
        switch (data.type) {
            case 'location_update':
                this.handleLocationUpdate(data);
                break;
            case 'single_participant_update':
                this.handleSingleParticipantUpdate(data);
                break;
            case 'notification':
                this.handleNotification(data);
                break;
            case 'session_expired': {
            const reason = data.reason || 'expired';
            if (window.sessionManager?.handleExpired) {
                //セッション無効化ボタン押下時
                sessionManager.handleExpired(reason);
            } else {
                // フォールバック：期限切れ扱い
                sessionManager?.handleExpired?.('expired');
            }
            break;
            }
            case 'error':
                this.handleError(data);
                break;
            case 'pong':
                this.handlePong(data);
                break;
            case 'participant_confirmed':
                this.handleParticipantConfirmed(data);
                break;
            case 'name_update_response':
                this.handleNameUpdateResponse(data);
                break;
            case 'chat_message':
                try {
                    chatManager?.handleIncomingMessage?.(data);
                } catch (e) {
                    console.warn(e);
                }
                break;
            case 'typing_indicator':
                try {
                    chatManager?.handleTypingIndicator?.(data);
                } catch (e) {
                    console.warn(e);
                }
                break;
            case 'chat_history':
                try {
                    chatManager?.handleChatHistory?.(data);
                } catch (e) {
                    console.warn(e);
                }
                break;
            case 'participant_status_update':
                try {
                    chatManager?.handleParticipantStatusUpdate?.(data);
                } catch (e) {
                    console.warn(e);
                }
                break;
            case 'remove_direction_indicator':
                this.handleRemoveDirectionIndicator(data);
                break;
            case 'unread_cleared':
                this.handleUnreadCleared(data);
                break;
            case 'read_status_update':
                try {
                    chatManager?.handleReadStatusUpdate?.(data);
                } catch (e) {
                    console.warn(e);
                }
                break;
        }
    }

    handleUnreadCleared(data) {
        if (typeof chatManager === 'undefined') return;
        const clearedSenderId = data?.cleared_sender_id;
        if (!clearedSenderId) return;

        // --- DM 未読のみクリア（グループチャットではメッセージが残るため）
        if (chatManager.unreadCounts?.individual?.[clearedSenderId] != null) {
            delete chatManager.unreadCounts.individual[clearedSenderId];
        }

        // DM メッセージのローカル既読フラグのみ更新
        const dmArr = chatManager.messages?.individual?.[clearedSenderId];
        if (Array.isArray(dmArr)) {
            dmArr.forEach(msg => {
                msg.is_read = true;
            });
        }

        // バッジ更新
        try {
            chatManager.updateBadge?.();
        } catch {}

        // 参加者リスト表示中なら更新
        try {
            if (chatManager.chatModal &&
                chatManager.chatModal.style.display !== 'none' &&
                document.getElementById('participants-screen')?.classList.contains('active')) {
                chatManager.updateParticipantsList?.();
            }
        } catch {}

        // 個別チャット画面を開いている場合のみ再描画
        try {
            const activeIndividualChat = document
                .getElementById('individual-chat-screen')
                ?.classList.contains('active');
            if (activeIndividualChat && chatManager.currentChatTarget === clearedSenderId) {
                chatManager.renderIndividualMessages?.(clearedSenderId);
            }
        } catch {}

        console.log(`未読メッセージ（DM）のみクリア: ${clearedSenderId} が退出`);
    }


    handleRemoveDirectionIndicator(data) {
        const participantId = data?.participant_id;
        if (!participantId || typeof mapManager === 'undefined') return;

        // 方向指示を削除
        try {
            if (mapManager.directionIndicators?.[participantId]) {
                if (mapManager.map?.hasLayer(mapManager.directionIndicators[participantId])) {
                    mapManager.map.removeLayer(mapManager.directionIndicators[participantId]);
                }
                delete mapManager.directionIndicators[participantId];
            }
        } catch (e) {
            console.warn(e);
        }

        // 移動アニメを停止
        try {
            if (mapManager.movementTrackers?.[participantId]) {
                const tracker = mapManager.movementTrackers[participantId];
                if (tracker.animationId) cancelAnimationFrame(tracker.animationId);
                delete mapManager.movementTrackers[participantId];
            }
        } catch (e) {
            console.warn(e);
        }
    }


    handleSingleParticipantUpdate(data) {
        if (!data?.participant_data) {
            console.warn('参加者データが空です');
            return;
        }
        if (typeof state === 'undefined') return;

        const participantData = data.participant_data;
        const isOwnUpdate = participantData.participant_id === state.participantId;

        // バックグラウンド状態変更の即座反映
        if (typeof participantData.is_background !== 'undefined' &&
            typeof mapManager !== 'undefined' && mapManager.updateParticipantCircleAnimation) {
            const previousParticipant = state.participantsData.find(
                p => p.participant_id === participantData.participant_id
            );
            if (previousParticipant && previousParticipant.is_background !== participantData.is_background) {
                mapManager.updateParticipantCircleAnimation(
                    participantData.participant_id,
                    participantData.is_background
                );
            }
        }

        if (isOwnUpdate && typeof participantData.stay_minutes !== 'undefined') {
            console.log(`自分の滞在時間更新: ${participantData.stay_minutes}分`);
        }

        // 参加者データの更新/追加
        const existingIndex = state.participantsData.findIndex(
            p => p.participant_id === participantData.participant_id
        );
        if (existingIndex !== -1) {
            state.participantsData[existingIndex] = participantData;
            console.log('既存参加者データを更新:', participantData.participant_id);
        } else {
            if (!isOwnUpdate) {
                state.participantsData.push(participantData);
            } else {
                const myIndex = state.participantsData.findIndex(p => p.participant_id === state.participantId);
                if (myIndex !== -1) state.participantsData[myIndex] = participantData;
                else state.participantsData.push(participantData);
            }
        }

        // 滞在時間更新時のマーカー即更新
        if (typeof participantData.stay_minutes !== 'undefined' && typeof mapManager !== 'undefined') {
            try {
                const marker = mapManager.markers?.[participantData.participant_id];
                if (marker) {
                    const color = mapManager.getParticipantColor?.(participantData.participant_id);
                    const name = (participantData.participant_name || `参加者${participantData.participant_id.substring(0, 4)}`).substring(0, 30);

                    marker.setIcon(mapManager.createCustomMarker(
                        name,
                        color,
                        participantData.is_background || false,
                        participantData.stay_minutes,
                        false, // isInCluster
                        1, // clusterSize
                        0, // clusterIndex
                        !participantData.is_online, // isOffline
                        0, // movementSpeed
                        false // speedReliable
                    ));

                    const popup = marker.getPopup?.();
                    if (popup && popup.isOpen?.()) {
                        const location = {
                            ...participantData,
                            participant_id: participantData.participant_id,
                            participant_name: participantData.participant_name,
                            latitude: participantData.latitude,
                            longitude: participantData.longitude,
                            accuracy: participantData.accuracy,
                            status: participantData.status,
                            is_online: participantData.is_online,
                            is_background: participantData.is_background,
                            stay_minutes: participantData.stay_minutes,
                            last_updated: participantData.last_updated
                        };

                        const newPopupContent = mapManager.createPopupContent?.(
                            location,
                            name,
                            color,
                            participantData.stay_minutes,
                            participantData.is_background || false,
                            false, // isInCluster
                            1, // clusterSize
                            0, // movementSpeed
                            false // speedReliable
                        );

                        if (newPopupContent) popup.setContent(newPopupContent);
                        console.log(`ポップアップ更新完了: ${participantData.stay_minutes}分`);
                    }
                }
            } catch (e) {
                console.warn(e);
            }
        }

        // マーカーと参加者リストを更新
        try {
            mapManager?.updateSingleMarkerOnly?.(participantData);
        } catch (e) {
            console.warn(e);
        }
        try {
            participantManager?.updateSingleParticipant?.(participantData);
        } catch (e) {
            console.warn(e);
        }

        // 通知は detectStateChanges に任せる
        const tempLocations = state.participantsData;
        this.detectStateChanges(tempLocations);

        // 単体更新でも未読再配分を即時実行
        try {
            chatManager?.handleParticipantStatusUpdate?.();
        } catch (e) {
            console.warn(e);
        }

        // 自分の位置更新後のフォーカス処理
        if (isOwnUpdate && state.followingParticipantId === state.participantId && typeof mapManager !== 'undefined') {
            try {
                const clusterInfo = mapManager.getCurrentClusterInfo?.(participantData.participant_id);
                if (clusterInfo) {
                    const sortedParticipants = [...clusterInfo.participants].sort((a, b) =>
                        a.participant_id.localeCompare(b.participant_id)
                    );
                    const participantIndex = sortedParticipants.findIndex(p =>
                        p.participant_id === participantData.participant_id
                    );
                    if (participantIndex !== -1) {
                        const angle = (2 * Math.PI * participantIndex) / sortedParticipants.length;
                        const radius = (typeof CONFIG !== 'undefined' && CONFIG?.CLUSTER_OFFSET_RADIUS) ?
                            CONFIG.CLUSTER_OFFSET_RADIUS : 10;

                        const clusterLat = clusterInfo.clusterCenter.lat + (radius * 0.00001) * Math.cos(angle);
                        const clusterLng = clusterInfo.clusterCenter.lng + (radius * 0.00001) * Math.sin(angle);
                        mapManager.focusOnPosition?.(clusterLat, clusterLng);
                    }
                } else {
                    mapManager.focusOnPosition?.(participantData.latitude, participantData.longitude);
                }
            } catch (e) {
                console.warn(e);
            }
        }
    }


    // === ：名前更新応答の処理 ===
    handleNameUpdateResponse(data) {
        const success = !!data?.success;

        if (success) {
            if (ui?.elements?.participantName) {
                ui.elements.participantName.classList.remove('is-invalid');
                ui.elements.participantName.classList.add('is-valid');
                setTimeout(() => {
                    try {
                        ui.elements.participantName.classList.remove('is-valid');
                    } catch {}
                }, 2000);
            }

            if (data.show_notification) {
                const name = (data.participant_name || '').substring(0, 20);
                ui?.showNotification?.(`名前を「${name}」に更新しました`, 'success', 'fas fa-user-check');
            }
        } else {
            const errMsg = data?.error || '名前の更新に失敗しました';
            console.warn(`名前更新失敗: ${errMsg}`);

            if (ui?.elements?.participantName) {
                ui.elements.participantName.classList.add('is-invalid');
                try {
                    eventHandlerManager?.showNameDuplicateWarning?.(
                        ui.elements.participantName,
                        data?.attempted_name || '名前'
                    );
                } catch {}
            }

            ui?.showNotification?.(errMsg, 'error', 'fas fa-user-times');

            if (data?.current_name && ui?.elements?.participantName) {
                ui.elements.participantName.value = data.current_name;
            }
        }
    }

    handleLocationUpdate(data) {
        if (!data?.locations) return;

        const locations = data.locations;
        let processedLocations = locations;

        try {
            processedLocations = participantManager?.processLocationsForDuplicates?.(locations) || locations;
        } catch (e) {
            console.warn('processLocationsForDuplicates で例外:', e);
        }

        // バックグラウンド状態のみ検出
        this.detectStateChanges(processedLocations);

        try {
            mapManager?.updateMarkers?.(processedLocations);
        } catch (e) {
            console.warn(e);
        }
        try {
            participantManager?.updateListAfterProcessing?.(processedLocations);
        } catch (e) {
            console.warn(e);
        }

        // 人数上限によってグループチャットのヘッダーを更新
        this.updateGroupChatHeader();

        // チャットが閉じていても未読再配分を実施（復帰/退出の即時反映）
        try {
            chatManager?.handleParticipantStatusUpdate?.();
        } catch (e) {
            console.warn(e);
        }
    }


    updateGroupChatHeader() {
        if (typeof state === 'undefined') return;

        // グループチャットが開いている場合のみ更新
        const groupChatScreen = document.getElementById('group-chat-screen');
        if (groupChatScreen?.classList.contains('active')) {
            const activeParticipants = (state.participantsData || []).filter(p => p.is_online).length;
            const groupHeader = document.querySelector('#group-chat-screen .chat-header h5');
            if (groupHeader) {
                groupHeader.innerHTML = `<i class="fas fa-users"></i> グループチャット (${activeParticipants}人)`;
            }
        }
    }

    /**
     * 方向円アニメの色・状態更新MessageHandler側のメソッドに任せる
     */
    updateParticipantCircleAnimation(participantId, isBackground) {
        if (typeof mapManager === 'undefined') return;

        // そのまま委譲
        try {
            if (typeof mapManager.updateParticipantCircleAnimation === 'function') {
                mapManager.updateParticipantCircleAnimation(participantId, isBackground);
                return;
            }
        } catch (e) {
            console.warn(e);
        }

        // 委譲先が無い場合の最低限のフォールバック（色のみ更新）
        try {
            const color = isBackground ? '#6c757d' : mapManager.getParticipantColor?.(participantId);
            if (mapManager.accuracyCircles?.[participantId]) {
                mapManager.accuracyCircles[participantId].setStyle?.({
                    color,
                    fillColor: color,
                    fillOpacity: 0.1,
                    opacity: 0.3,
                    weight: 2
                });
            }
        } catch (e) {
            console.warn(e);
        }
    }

    handleNotification(data) {
        if (!data) return;
        if (data.exclude_self && data.participant_id === state?.participantId) return;
        ui?.showNotification?.(data.message, data.notification_type, data.icon);
    }

    handleError(data) {
        const msg = data?.message || '';
        if (msg.includes?.('期限切れ')) {
            try {
                sessionManager?.handleExpired?.();
            } catch {}
        }
    }

    handlePong(_data) {
        try {
            if (ui?.elements?.lastCommunication) {
                ui.elements.lastCommunication.textContent =
                    new Date().toLocaleTimeString() + ' (pong)';
            }
        } catch {}
    }

    handleParticipantConfirmed(data) {
        if (!data?.participant_id || typeof state === 'undefined') return;

        if (data.participant_id && data.participant_id !== state.participantId) {
            state.participantId = data.participant_id;

            try {
                if (data.is_existing && data.participant_name) {
                    if (ui?.elements?.participantName) {
                        ui.elements.participantName.value = data.participant_name;
                    }
                    ui?.showNotification?.('セッションに復帰しました', 'success', 'fas fa-user-check');
                } else {
                    ui?.showNotification?.('セッションに参加しました', 'success', 'fas fa-user-plus');
                }
            } catch (e) {
                console.warn(e);
            }
        }
    }


    detectStateChanges(newLocations) {
        if (typeof state === 'undefined' || state.isLeaving || state.sessionExpired) return;
        if (!Array.isArray(newLocations)) return;

        const currentState = new Map();

        // 現在の参加者状態を収集
        newLocations.forEach(location => {
            if (!location || !location.participant_id) return;

            const hasValidLocation =
                location.latitude !== null && location.longitude !== null &&
                location.latitude !== 999.0 && location.longitude !== 999.0;

            const isSharing = location.status === 'sharing' && hasValidLocation;

            const safeName = (location.participant_name || `参加者${String(location.participant_id).substring(0, 4)}`).substring(0, 30);

            currentState.set(location.participant_id, {
                name: safeName,
                status: location.status,
                is_sharing: isSharing,
                is_background: location.is_background,
                is_online: location.is_online,
                hasValidLocation
            });
        });

        // 退出した参加者を検出
        state.previousParticipantsState?.forEach((previous, participant_id) => {
            if (participant_id === state.participantId) return;
            if (!currentState.has(participant_id)) {
                // 退出を検出
                try {
                    ui?.showNotification?.(
                        `${String(previous.name).substring(0, 30)}が退出しました`,
                        'warning',
                        'fas fa-sign-out-alt',
                        true
                    );
                } catch {}

                // マーカーを削除
                try {
                    if (mapManager?.markers?.[participant_id]) {
                        mapManager.removeMarker?.(participant_id);
                    }
                } catch (e) {
                    console.warn(e);
                }

                // グループチャットにシステムメッセージを追加
                this.addSystemMessageToGroupChat(
                    `${String(previous.name).substring(0, 30)}が退出しました`,
                    'leave'
                );

                // グループチャットのヘッダーを即座に更新
                this.updateGroupChatHeader();
            }
        });

        // 新規参加と状態変化を検出
        currentState.forEach((current, participant_id) => {
            if (participant_id === state.participantId) return;

            const previous = state.previousParticipantsState?.get(participant_id);

            if (!previous) {
                // 新規参加
                try {
                    ui?.showNotification?.(
                        `${current.name.substring(0, 30)}が参加しました`,
                        'success',
                        'fas fa-user-plus',
                        true
                    );
                } catch {}

                this.addSystemMessageToGroupChat(
                    `${current.name.substring(0, 30)}が参加しました`,
                    'join'
                );

                this.updateGroupChatHeader();
            } else {
                // 共有状態の変化（システムメッセージは表示しない）
                try {
                    if (!previous.is_sharing && current.is_sharing) {
                        ui?.showNotification?.(
                            `${current.name.substring(0, 30)}が位置情報を共有しました`,
                            'info',
                            'fas fa-map-marker-alt',
                            true
                        );
                    } else if (previous.is_sharing && !current.is_sharing) {
                        ui?.showNotification?.(
                            `${current.name.substring(0, 30)}が共有を停止しました`,
                            'warning',
                            'fas fa-pause',
                            true
                        );
                    }
                } catch {}
            }
        });

        // 現在の状態を保存
        state.previousParticipantsState = new Map(currentState);
    }

    addSystemMessageToGroupChat(text, type) {
        // システムメッセージを作成
        const systemMessage = {
            type: 'system',
            text: text,
            timestamp: new Date().toISOString(),
            system_type: type // 'join' or 'leave'
        };

        // グループメッセージに追加
        if (window.chatManager) {
            try {
                chatManager.messages = chatManager.messages || {};
                chatManager.messages.group = chatManager.messages.group || [];
                chatManager.messages.group.push(systemMessage);
            } catch (e) {
                console.warn(e);
            }

            // グループチャットが開いている場合は即座に表示
            try {
                const groupChatScreen = document.getElementById('group-chat-screen');
                if (groupChatScreen?.classList.contains('active')) {
                    const container = document.getElementById('group-messages');
                    if (container) {
                        const wasScrolledToBottom = chatManager.isScrolledToBottom?.(container);

                        const systemDiv = document.createElement('div');
                        systemDiv.className = 'system-message';
                        systemDiv.textContent = text;
                        container.appendChild(systemDiv);

                        if (wasScrolledToBottom) {
                            container.scrollTop = container.scrollHeight;
                        }
                    }
                }
            } catch (e) {
                console.warn(e);
            }
        }
    }
}


// === 位置情報管理クラス ===
class LocationManager {
    constructor() {
        this.watchId = null;
        this.locationInterval = null;
        this.backgroundLocationUpdate = null;
        this.forcedUpdateTimeout = null;
        this.initialPositionTimeout = null;

        // === 方位・速度 ===
        this.stableBearing = null; // 基本方位（内部用）
        this.smoothedBearing = null; // 表示用の平滑化方位
        this.smoothedSpeed = 0; // 直近点からの速度

        // アウトライヤ制御用
        this._pendingBearingOutlier = null; // {bearing, firstSeenAt}
        this._lastBearingUpdateAt = 0;

        // 滞在時間追跡
        this.stayTracker = {
            basePosition: null,
            stayStartTime: null,
            lastResetNotifiedAt: null,
        };

        // 更新設定（コメント整備）
        this.UPDATE_CONFIG = {
            MOVEMENT_THRESHOLD: 3, // 3m以上で送信
            MOVEMENT_THRESHOLD_SEND: 3, // 送信判定：3m
            MOVEMENT_THRESHOLD_DISPLAY: 1, // マーカー表示更新閾値
            MIN_INTERVAL: 500, // 最小0.5秒間隔
            MAX_INTERVAL: 5000, // 最大5秒間隔
            STATIONARY_SPEED_THRESHOLD: 0.6, // m/s 未満を静止とみなす
            STATIONARY_TIME_MS: 3000, // 静止状態判定時間
            MOVEMENT_PERSIST_TIME_MS: 2000, // 移動状態維持時間
            STAY_RESET_DISTANCE: 30, // stay判定リセット距離（m）
            STAY_RESET_COOLDOWN_MS: 10000, // stay reset通知の最短間隔
            POSITION_BUFFER_SIZE: 5, // 位置履歴（増やして安定化）
            MIN_ACCEPTABLE_ACCURACY: 0, // 0ならaccuracy無視

            // --- 方位安定化パラメータ ---
            MIN_DIST_FOR_BEARING: 2, // 角度算出に必要な最小移動量(m)
            ALPHA_BEARING_EMA: 0.25, // 方位の指数移動平均の係数
            OUTLIER_DEG: 60, // これ以上の急な方位差は一旦疑う
            OUTLIER_CONFIRM_MS: 800, // 継続したら採用
            MAX_TURN_RATE_DEG_PER_S: 90, // 1秒あたりの最大回頭角
            LONG_BASE_WEIGHT: 0.4, // 古→新ベクトル（長基線）の寄与
        };

        // 位置履歴バッファ
        this.positionBuffer = [];

        // 最後の有意な移動時刻（表示制御で使用）
        this.lastSignificantMovement = null;

        // 表示用フラグ
        this.displayMoving = false;
        this.displayMovingSince = null;

        // 停止処理中フラグ
        this.isStopping = false;

        // watchPosition成功フラグ
        this.watchSuccessful = false;

        // 小さな定数群
        this.CONST = {
            INITIAL_SEND_DELAY_MS: 1000,
            DIRECTION_IND_MIN_MS: 2000,
            STOP_DIRECTION_HIDE_DELAY_MS: 5000
        };
    }


    //ここまで見た
































    
    // ===== ユーティリティ（内部ガード） =====
    _canUseGeolocation() {
        try {
            return typeof navigator !== 'undefined' && !!navigator.geolocation;
        } catch {
            return false;
        }
    }
    _clearTimeoutSafe(idKey) {
        if (this[idKey]) {
            clearTimeout(this[idKey]);
            this[idKey] = null;
        }
    }
    _clearIntervalSafe(idKey) {
        if (this[idKey]) {
            clearInterval(this[idKey]);
            this[idKey] = null;
        }
    }

    // === 角度ユーティリティ（ラップ対応） ===
    _normDeg(a) {
        a %= 360;
        return a < 0 ? a + 360 : a;
    }
    _angleDiff(a, b) { // returns signed shortest diff in [-180,180]
        let d = (a - b + 540) % 360 - 180;
        return d;
    }
    _angleEMA(prev, next, alpha) {
        if (prev === null || prev === undefined) return this._normDeg(next);
        const diff = this._angleDiff(next, prev);
        return this._normDeg(prev + alpha * diff);
    }
    _angleBlend(a, b, wB = 0.5) {
        // 円周平均: ベクトル合成
        const ra = a * Math.PI / 180,
            rb = b * Math.PI / 180;
        const x = (1 - wB) * Math.cos(ra) + wB * Math.cos(rb);
        const y = (1 - wB) * Math.sin(ra) + wB * Math.sin(rb);
        const deg = Math.atan2(y, x) * 180 / Math.PI;
        return this._normDeg(deg);
    }
    _clampTurnRate(prev, next, dtSec, maxRateDegPerS) {
        if (prev === null || prev === undefined) return next;
        const maxDelta = Math.max(0, maxRateDegPerS) * (dtSec || 0);
        const diff = this._angleDiff(next, prev);
        const clamped = Math.abs(diff) > maxDelta ? prev + Math.sign(diff) * maxDelta : next;
        return this._normDeg(clamped);
    }

    startSharing() {
        // ★ 停止処理中は開始を防ぐ
        if (this.isStopping) {
            try {
                ui?.showNotification?.('処理中です。しばらくお待ちください', 'warning', 'fas fa-hourglass-half');
            } catch {}
            return;
        }

        if (!this._canUseGeolocation()) {
            try {
                ui?.updateStatus?.('location', 'error', 'このブラウザでは位置情報がサポートされていません');
            } catch {}
            return;
        }

        state.isSharing = true;
        state.lastSentPosition = null;
        state.lastSentTime = 0;

        this._clearTimeoutSafe('forcedUpdateTimeout');

        try {
            ui?.updateStatus?.('location', 'waiting', '位置情報を取得中...');
        } catch {}

        const options = {
            enableHighAccuracy: true,
            timeout: (typeof CONFIG !== 'undefined' && CONFIG?.LOCATION_TIMEOUT) ? CONFIG.LOCATION_TIMEOUT : 10000,
            maximumAge: 2000
        };

        navigator.geolocation.getCurrentPosition(
            (position) => this.handleInitialPosition(position),
            (error) => {
                if (error.code === 1) { // PERMISSION_DENIED
                    try {
                        ui?.updateStatus?.('location', 'error', '位置情報の利用が拒否されました');
                        state.isSharing = false;
                        ui?.updateSharingButton?.();
                        this.showLocationPermissionHint();
                        ui?.showNotification?.('位置情報が拒否されました。設定方法を確認してください', 'warning', 'fas fa-map-marker-alt');
                    } catch {}
                } else {
                    this.handleLocationError(error);
                }
            },
            options
        );

        try {
            ui?.updateSharingButton?.();
        } catch {}
    }

    handleInitialPosition(position) {
        console.log('初回位置情報取得成功');
        state.lastKnownPosition = position;

        // 滞在追跡の基準位置を設定
        this.stayTracker.basePosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
        };
        this.stayTracker.stayStartTime = Date.now();
        this.stayTracker.lastResetNotifiedAt = null;

        // position bufferを初期化
        this.positionBuffer = [];
        this._pushPositionToBuffer(position);

        // 方位状態初期化
        this.stableBearing = null;
        this.smoothedBearing = null;
        this._pendingBearingOutlier = null;
        this._lastBearingUpdateAt = Date.now();

        // まだマーカーは表示しない（watchPositionが成功してから表示）
        state.lastSentPosition = position;
        state.lastSentTime = Date.now();

        this.updateLocationStatus();

        // watchPosition開始
        this.startTracking();

        // 初回送信（少し遅延してwatch結果を待つ）
        this._clearTimeoutSafe('initialPositionTimeout');
        this.initialPositionTimeout = setTimeout(() => {
            if (state.isSharing && state.lastKnownPosition) {
                console.log('初回位置情報を送信');
                this._maybeSendLocation(state.lastKnownPosition, {
                    force: true
                });

                // 自分の位置にフォーカス
                try {
                    if (mapManager?.isInitialized?.() && state.lastKnownPosition) {
                        mapManager.focusOnPosition(
                            state.lastKnownPosition.coords.latitude,
                            state.lastKnownPosition.coords.longitude
                        );
                        state.followingParticipantId = state.participantId;
                    }
                } catch {}
            }
        }, this.CONST.INITIAL_SEND_DELAY_MS);

        try {
            state.save?.();
        } catch {}
    }

    startTracking() {
        if (!this._canUseGeolocation()) return;

        if (this.watchId) {
            try {
                navigator.geolocation.clearWatch(this.watchId);
            } catch {}
        }

        this.lastSignificantMovement = Date.now();
        this.watchSuccessful = false;

        this.watchId = navigator.geolocation.watchPosition(
            (position) => {
                if (!this.watchSuccessful) {
                    this.watchSuccessful = true;
                    console.log('watchPosition成功 - 位置情報監視開始');

                    if (this.initialPositionTimeout) {
                        clearTimeout(this.initialPositionTimeout);
                        this.initialPositionTimeout = null;

                        this._maybeSendLocation(position, {
                            force: true
                        });

                        try {
                            if (mapManager?.isInitialized?.() && position) {
                                mapManager.focusOnPosition(
                                    position.coords.latitude,
                                    position.coords.longitude
                                );
                                state.followingParticipantId = state.participantId;
                            }
                        } catch {}
                    }
                }

                this.handlePositionUpdate(position);
            },
            (error) => {
                console.warn('位置情報監視エラー:', error);
                this._clearTimeoutSafe('initialPositionTimeout');

                if (error.code === 1) { // PERMISSION_DENIED
                    console.log('watchPositionで許可拒否を検出');

                    state.isSharing = false;
                    try {
                        ui?.updateSharingButton?.();
                        ui?.updateStatus?.('location', 'error', '位置情報の利用が拒否されました');
                    } catch {}

                    try {
                        if (mapManager?.markers?.[state.participantId]) {
                            mapManager.removeOwnMarker?.();
                        }
                    } catch {}

                    try {
                        if (wsManager?.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                            wsManager.send({
                                type: 'stop_sharing',
                                participant_id: state.participantId,
                                participant_name: state.getParticipantName?.(),
                                clear_location: true,
                                remove_marker: true,
                                timestamp: new Date().toISOString()
                            });
                        }
                    } catch {}

                    this.showLocationPermissionHint();

                    if (this.watchId) {
                        try {
                            navigator.geolocation.clearWatch(this.watchId);
                        } catch {}
                        this.watchId = null;
                    }
                }
            }, {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 500
            }
        );
    }

    stopSharing() {
        console.log('位置共有停止');

        if (this.isStopping) return;
        this.isStopping = true;
        state.isSharing = false;

        this._clearTimeoutSafe('initialPositionTimeout');
        this._clearIntervalSafe('locationInterval');
        this._clearTimeoutSafe('forcedUpdateTimeout');

        if (this.watchId) {
            try {
                navigator.geolocation.clearWatch(this.watchId);
            } catch {}
            this.watchId = null;
        }

        // 滞在追跡クリア
        this.stayTracker = {
            basePosition: null,
            stayStartTime: null,
            lastResetNotifiedAt: null
        };

        state.lastSentPosition = null;

        // 方向指示を削除
        try {
            if (mapManager?.directionIndicators?.[state.participantId]) {
                if (mapManager.map?.hasLayer(mapManager.directionIndicators[state.participantId])) {
                    mapManager.map.removeLayer(mapManager.directionIndicators[state.participantId]);
                }
                delete mapManager.directionIndicators[state.participantId];
            }
        } catch {}

        // 移動アニメーションも停止
        try {
            if (mapManager?.movementTrackers?.[state.participantId]) {
                const tr = mapManager.movementTrackers[state.participantId];
                if (tr.animationId) cancelAnimationFrame(tr.animationId);
                delete mapManager.movementTrackers[state.participantId];
            }
        } catch {}

        // 移動停止タイマーもクリア
        try {
            if (mapManager?.movementStopTimers?.[state.participantId]) {
                delete mapManager.movementStopTimers[state.participantId];
            }
        } catch {}

        // 自分のマーカーを削除
        try {
            mapManager?.removeOwnMarker?.();
        } catch {}

        // 参加者データを更新
        try {
            state.participantsData = (state.participantsData || []).map(p => {
                if (p.participant_id === state.participantId) {
                    return {
                        ...p,
                        latitude: null,
                        longitude: null,
                        accuracy: null,
                        status: 'waiting',
                        is_online: true,
                        has_shared_before: false,
                        stay_minutes: 0
                    };
                }
                return p;
            });
        } catch {}

        const stopSharingData = {
            type: 'stop_sharing',
            participant_id: state.participantId,
            participant_name: state.getParticipantName?.(),
            is_background: state.isInBackground,
            clear_location: true,
            remove_marker: true,
            remove_direction_indicator: true,
            clear_stay_time: true,
            timestamp: new Date().toISOString()
        };

        try {
            wsManager?.send?.(stopSharingData);
        } catch {}

        try {
            ui?.updateSharingButton?.();
            this.updateLocationStatus();
            state.save?.();
        } catch {}

        setTimeout(() => {
            this.isStopping = false;
        }, 3000);
    }

    handlePositionUpdate(position) {
        console.log('=== 位置情報更新 ===');

        state.lastKnownPosition = position;
        this.updateLocationStatus();

        this._pushPositionToBuffer(position);
        this._recalculateMotionFromBuffer(); // ★スパイク抑制付き

        this.updateStayTime(position);

        this._maybeSendLocation(position, {});

        this._updateDisplayState(position);

        try {
            state.save?.();
        } catch {}
    }

    // ===========================
    // 位置履歴・速度・方位計算（安定化）
    // ===========================
    _pushPositionToBuffer(position) {
        const item = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy || null,
            t: Date.now()
        };
        this.positionBuffer.push(item);
        const max = this.UPDATE_CONFIG.POSITION_BUFFER_SIZE;
        if (this.positionBuffer.length > max) {
            this.positionBuffer.shift();
        }
    }

    _recalculateMotionFromBuffer() {
        const buf = this.positionBuffer;
        const n = buf.length;
        if (n < 2) {
            this.smoothedSpeed = 0;
            return;
        }

        // 速度は直近2点
        const a = buf[n - 2];
        const b = buf[n - 1];
        const dt = (b.t - a.t) / 1000.0;
        if (dt <= 0) {
            this.smoothedSpeed = 0;
        } else {
            const distAB = this.calculateDistance(a.lat, a.lng, b.lat, b.lng);
            let speed = distAB / dt;
            const maxReasonableSpeed = 92.5; // 333km/h
            if (speed > maxReasonableSpeed) speed = maxReasonableSpeed;
            this.smoothedSpeed = speed;
        }

        // 方位は「直近短基線」と「全体長基線」のブレンドで安定化
        let candidateBearing = null;
        const distAB = this.calculateDistance(a.lat, a.lng, b.lat, b.lng);
        if (distAB >= this.UPDATE_CONFIG.MIN_DIST_FOR_BEARING) {
            const brShort = this.calculateBearing(a.lat, a.lng, b.lat, b.lng);

            if (n >= 3) {
                const first = buf[0];
                const distLong = this.calculateDistance(first.lat, first.lng, b.lat, b.lng);
                if (distLong >= this.UPDATE_CONFIG.MIN_DIST_FOR_BEARING * 2) {
                    const brLong = this.calculateBearing(first.lat, first.lng, b.lat, b.lng);
                    candidateBearing = this._angleBlend(
                        brShort,
                        brLong,
                        this.UPDATE_CONFIG.LONG_BASE_WEIGHT
                    );
                } else {
                    candidateBearing = brShort;
                }
            } else {
                candidateBearing = brShort;
            }
        }

        if (candidateBearing == null) {
            // 小移動なら角度更新しない（前回値維持）
            return;
        }

        // --- アウトライヤ抑制（瞬間的な逆向きを排除） ---
        const now = Date.now();
        const prevSmooth = this.smoothedBearing;
        const diffFromSmooth = (prevSmooth == null) ? 0 : Math.abs(this._angleDiff(candidateBearing, prevSmooth));

        if (prevSmooth != null && diffFromSmooth >= this.UPDATE_CONFIG.OUTLIER_DEG) {
            // まず一旦保留し、一定時間継続したら採用
            if (!this._pendingBearingOutlier ||
                Math.abs(this._angleDiff(this._pendingBearingOutlier.bearing, candidateBearing)) >= 10) {
                this._pendingBearingOutlier = {
                    bearing: candidateBearing,
                    firstSeenAt: now
                };
                // 採用せず終了（現状のsmoothedBearingを維持）
                candidateBearing = prevSmooth;
            } else {
                const elapsed = now - this._pendingBearingOutlier.firstSeenAt;
                if (elapsed < this.UPDATE_CONFIG.OUTLIER_CONFIRM_MS) {
                    candidateBearing = prevSmooth; // まだ採用しない
                } else {
                    // 継続したので真の向きと判断
                    this._pendingBearingOutlier = null;
                    // candidateBearing はそのまま採用へ
                }
            }
        } else {
            // 連続していないので保留をクリア
            this._pendingBearingOutlier = null;
        }

        // --- 回頭速度制限（角度の時間変化をなめらかに） ---
        const dtSince = Math.max(0.001, (now - (this._lastBearingUpdateAt || now)) / 1000);
        const rateLimited = this._clampTurnRate(
            prevSmooth,
            candidateBearing,
            dtSince,
            this.UPDATE_CONFIG.MAX_TURN_RATE_DEG_PER_S
        );

        // --- 角度の指数移動平均（円周対応） ---
        const ema = this._angleEMA(prevSmooth, rateLimited, this.UPDATE_CONFIG.ALPHA_BEARING_EMA);

        // 更新
        this.stableBearing = this._normDeg(candidateBearing);
        this.smoothedBearing = ema;
        this._lastBearingUpdateAt = now;
    }

    // ===========================
    // マーカー表示・方向指示制御（既存条件を維持しつつ方位は平滑値を使用）
    // ===========================
    _updateDisplayState(position) {
        // 自分の方向表示はサーバからのデータ（location.motion）で統一するため、
        // ここでは一切、方向インジケータを生成・削除しない。
        // 表示用のフラグ類もマップ描画には使わないため更新しない。
        return;
    }

    // ===========================
    // 送信（サーバ）制御
    // ===========================
    _maybeSendLocation(position, opts = {}) {
        const now = Date.now();

        if (!state?.participantId) {
            console.warn('participant_id が未設定のため送信をスキップ');
            return false;
        }

        if (!opts.force && (now - (state.lastSentTime || 0)) < this.UPDATE_CONFIG.MIN_INTERVAL) {
            if ((now - (state.lastSentTime || 0)) < this.UPDATE_CONFIG.MAX_INTERVAL) {
                console.log('送信スキップ: 最小間隔未満');
                return false;
            }
        }

        // 距離チェック
        let distance = Infinity;
        if (state.lastSentPosition) {
            distance = this.calculateDistance(
                state.lastSentPosition.coords.latitude,
                state.lastSentPosition.coords.longitude,
                position.coords.latitude,
                position.coords.longitude
            );
        }

        const movedEnough = distance >= this.UPDATE_CONFIG.MOVEMENT_THRESHOLD_SEND;
        const timeSinceLast = now - (state.lastSentTime || 0);

        if (opts.force || movedEnough || timeSinceLast >= this.UPDATE_CONFIG.MAX_INTERVAL || !state.lastSentPosition) {
            this.sendLocationUpdate(position);
            state.lastSentPosition = position;
            state.lastSentTime = now;

            this._clearTimeoutSafe('forcedUpdateTimeout');
            this.forcedUpdateTimeout = setTimeout(() => {
                this.forcedUpdateTimeout = null;
                if (state.isSharing && state.lastKnownPosition) {
                    this._maybeSendLocation(state.lastKnownPosition, {
                        force: true
                    });
                }
            }, this.UPDATE_CONFIG.MAX_INTERVAL + 100);

            console.log(`位置情報送信: 距離=${distance === Infinity ? '初回' : distance.toFixed(1)}m, 経過=${timeSinceLast}ms`);
            return true;
        } else {
            console.log(`送信スキップ: 距離=${isFinite(distance) ? distance.toFixed(1) : '初回判定'}m, 経過=${timeSinceLast}ms`);
            return false;
        }
    }

    sendLocationUpdate(position) {
        if (!state?.participantId) {
            console.error('sendLocationUpdate: participant_id が未設定');
            return;
        }

        let currentClusterInfo = null;
        try {
            currentClusterInfo = mapManager?.getCurrentClusterInfo?.(state.participantId);
        } catch {}

        const locationData = {
            type: 'single_participant_update',
            participant_id: state.participantId,
            participant_name: state.getParticipantName?.(),
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: this.validateAccuracy(position.coords.accuracy),
            timestamp: new Date().toISOString(),
            is_background: state.isInBackground,
            status: 'sharing',
            in_cluster: !!currentClusterInfo,
            cluster_id: currentClusterInfo ? currentClusterInfo.clusterId : null,
            motion: {
                speed_m_s: Math.round((this.smoothedSpeed || 0) * 100) / 100,
                bearing_deg: this.smoothedBearing !== null ? Math.round(this.smoothedBearing) : null,
                display_moving: !!this.displayMoving
            }
        };

        try {
            if (wsManager?.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                wsManager.send(locationData);
                console.log('位置情報送信 - status:', locationData.status);
            } else {
                console.warn('WebSocket未接続のため位置情報送信をスキップ');
            }
        } catch (e) {
            console.warn('位置情報送信中に例外:', e);
        }
    }

    validateAccuracy(accuracy) {
        if (!accuracy || accuracy <= 0 || accuracy > 1000) return null;
        return Math.round(accuracy);
    }

    // ===========================
    // 滞在時間更新
    // ===========================
    updateStayTime(position) {
        if (!state?.isSharing) {
            console.log('共有停止中のため滞在時間更新をスキップ');
            return;
        }

        if (!this.stayTracker.basePosition) {
            this.stayTracker.basePosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            this.stayTracker.stayStartTime = Date.now();
            return;
        }

        const distance = this.calculateDistance(
            this.stayTracker.basePosition.lat,
            this.stayTracker.basePosition.lng,
            position.coords.latitude,
            position.coords.longitude
        );

        if (distance >= this.UPDATE_CONFIG.STAY_RESET_DISTANCE) {
            const now = Date.now();
            const cooldown = this.UPDATE_CONFIG.STAY_RESET_COOLDOWN_MS;
            if (!this.stayTracker.lastResetNotifiedAt ||
                (now - this.stayTracker.lastResetNotifiedAt) >= cooldown) {
                this.stayTracker.basePosition = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude
                };
                this.stayTracker.stayStartTime = now;
                this.stayTracker.lastResetNotifiedAt = now;
                this.sendStayResetNotification();
                console.log('滞在地点リセット：サーバへ通知');
            } else {
                console.log('滞在地点リセットはクールダウン中のためスキップ');
            }
        }
    }

    sendStayResetNotification() {
        try {
            if (wsManager?.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                const resetData = {
                    type: 'stay_reset',
                    participant_id: state?.participantId,
                    timestamp: new Date().toISOString()
                };
                const sent = wsManager.send(resetData);
                if (sent) console.log('滞在時間リセット通知送信成功');
                else console.log('滞在時間リセット通知送信失敗');
            } else {
                console.log('WebSocket未接続のため滞在時間リセット通知をスキップ');
            }
        } catch (e) {
            console.warn('滞在時間リセット通知で例外:', e);
        }
    }

    handleLocationError(error) {
        let message = '';
        switch (error.code) {
            case error.PERMISSION_DENIED:
                message = '位置情報の利用が拒否されました';
                try {
                    ui?.updateStatus?.('location', 'error', message);
                    state.isSharing = false;
                    ui?.updateSharingButton?.();
                    this.showLocationPermissionHint();
                } catch {}
                break;
            case error.POSITION_UNAVAILABLE:
                message = '位置情報が取得できませんでした';
                try {
                    ui?.updateStatus?.('location', 'error', message);
                    ui?.showNotification?.('位置情報が取得できません。設定を確認してください', 'warning', 'fas fa-exclamation-triangle');
                } catch {}
                break;
            case error.TIMEOUT:
                message = '位置情報の取得がタイムアウトしました';
                try {
                    ui?.updateStatus?.('location', 'waiting', message + ' - 再試行中...');
                } catch {}
                setTimeout(() => {
                    if (state?.isSharing && !state?.sessionExpired) {
                        this.startSharing();
                    }
                }, 3000);
                break;
            default:
                message = '位置情報の取得中にエラーが発生しました';
                try {
                    ui?.updateStatus?.('location', 'error', message);
                } catch {}
                break;
        }
        console.warn('位置情報エラー:', message, error);
    }

    showLocationPermissionHint() {
        const existingModal = document.getElementById('location-hint-modal');
        if (existingModal) {
            try {
                const bsModal = bootstrap?.Modal?.getInstance?.(existingModal);
                if (bsModal) bsModal.dispose();
            } catch {}
            existingModal.remove();
        }

        const ua = (typeof navigator !== 'undefined' && navigator.userAgent) ? navigator.userAgent.toLowerCase() : '';
        const isIOS = /iphone|ipad|ipod/.test(ua);
        const isAndroid = /android/.test(ua);
        const isChrome = /chrome/.test(ua) && !/edg/.test(ua);
        const isFirefox = /firefox/.test(ua);
        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);
        const isEdge = /edg/.test(ua);

        let instructions = '';

        if (isIOS) {
            if (isSafari) {
                instructions = `
                    <h6><i class="fas fa-mobile-alt"></i> iPhone/iPadで位置情報を有効にする方法</h6>
                    <ol class="text-start small">
                        <li><strong>設定アプリ</strong>を開く</li>
                        <li><strong>プライバシーとセキュリティ</strong>をタップ</li>
                        <li><strong>位置情報サービス</strong>をタップ</li>
                        <li>位置情報サービスを<strong>オン</strong>にする</li>
                        <li>下にスクロールして<strong>Safari</strong>を探す</li>
                        <li><strong>このAppの使用中のみ許可</strong>を選択</li>
                        <li>このページを再読み込みして、もう一度「共有開始」をタップ</li>
                    </ol>
                    <div class="alert alert-info mt-2">
                        <small><i class="fas fa-info-circle"></i> Safari設定で「位置情報へのアクセス」も確認してください</small>
                    </div>
                `;
            } else {
                instructions = `
                    <h6><i class="fas fa-mobile-alt"></i> iPhone/iPadで位置情報を有効にする方法</h6>
                    <ol class="text-start small">
                        <li><strong>設定アプリ</strong>を開く</li>
                        <li><strong>プライバシーとセキュリティ</strong>をタップ</li>
                        <li><strong>位置情報サービス</strong>をタップ</li>
                        <li>お使いのブラウザ（Chrome/Firefox等）を探す</li>
                        <li><strong>このAppの使用中のみ許可</strong>を選択</li>
                        <li>このページを再読み込みして、もう一度「共有開始」をタップ</li>
                    </ol>
                `;
            }
        } else if (isAndroid) {
            instructions = `
                <h6><i class="fas fa-mobile-alt"></i> Androidで位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>ブラウザのアドレスバー左側の<strong>鍵アイコン</strong>または<strong>ⓘアイコン</strong>をタップ</li>
                    <li><strong>サイトの設定</strong>または<strong>権限</strong>をタップ</li>
                    <li><strong>位置情報</strong>を探してタップ</li>
                    <li><strong>許可</strong>を選択</li>
                    <li>ページを再読み込みして、もう一度「共有開始」をタップ</li>
                </ol>
                <div class="alert alert-secondary mt-2">
                    <small><strong>または端末の設定から：</strong></small>
                    <ol class="mb-0 small">
                        <li>設定 → アプリ → ブラウザアプリを選択</li>
                        <li>権限 → 位置情報 → 許可</li>
                    </ol>
                </div>
            `;
        } else if (isChrome) {
            instructions = `
                <h6><i class="fab fa-chrome"></i> Google Chromeで位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>アドレスバーの左側にある<strong>鍵アイコン</strong>をクリック</li>
                    <li><strong>サイトの設定</strong>をクリック</li>
                    <li><strong>位置情報</strong>の項目を<strong>許可</strong>に変更</li>
                    <li>ページを再読み込み（F5キー）</li>
                    <li>もう一度「共有開始」ボタンをクリック</li>
                </ol>
                <div class="alert alert-info mt-2">
                    <small><i class="fas fa-lightbulb"></i> ヒント: chrome://settings/content/location でも設定できます</small>
                </div>
            `;
        } else if (isFirefox) {
            instructions = `
                <h6><i class="fab fa-firefox"></i> Firefoxで位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>アドレスバーの左側にある<strong>鍵アイコン</strong>をクリック</li>
                    <li><strong>安全でない接続</strong>または<strong>接続は安全です</strong>の横の<strong>></strong>をクリック</li>
                    <li><strong>詳細を表示</strong>をクリック</li>
                    <li><strong>サイト別設定</strong>タブを選択</li>
                    <li><strong>位置情報の取得</strong>を<strong>許可</strong>に変更</li>
                    <li>ページを再読み込み（F5キー）</li>
                </ol>
            `;
        } else if (isSafari) {
            instructions = `
                <h6><i class="fab fa-safari"></i> Safariで位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>メニューバーの<strong>Safari</strong>をクリック</li>
                    <li><strong>設定</strong>（または環境設定）を選択</li>
                    <li><strong>Webサイト</strong>タブをクリック</li>
                    <li>左側のリストから<strong>位置情報</strong>を選択</li>
                    <li>このサイトを探して<strong>許可</strong>に変更</li>
                    <li>ページを再読み込み（Command + R）</li>
                </ol>
            `;
        } else if (isEdge) {
            instructions = `
                <h6><i class="fab fa-edge"></i> Microsoft Edgeで位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>アドレスバーの左側にある<strong>鍵アイコン</strong>をクリック</li>
                    <li><strong>このサイトのアクセス許可</strong>をクリック</li>
                    <li><strong>場所</strong>を<strong>許可</strong>に変更</li>
                    <li>ページを再読み込み（F5キー）</li>
                    <li>もう一度「共有開始」ボタンをクリック</li>
                </ol>
            `;
        } else {
            instructions = `
                <h6><i class="fas fa-map-marker-alt"></i> 位置情報を有効にする方法</h6>
                <ol class="text-start small">
                    <li>ブラウザのアドレスバー付近にある<strong>位置情報アイコン</strong>を探す</li>
                    <li>このサイトに対して位置情報を<strong>許可</strong>する</li>
                    <li>ページを再読み込みする</li>
                    <li>もう一度「共有開始」ボタンをクリック</li>
                </ol>
                <div class="alert alert-warning mt-2">
                    <small><i class="fas fa-exclamation-triangle"></i> お使いのブラウザの設定メニューから位置情報の権限を確認してください</small>
                </div>
            `;
        }

        const modalDiv = document.createElement('div');
        modalDiv.className = 'modal fade';
        modalDiv.style.zIndex = '10001';
        modalDiv.id = 'location-hint-modal';
        modalDiv.setAttribute('tabindex', '-1');
        modalDiv.setAttribute('data-bs-backdrop', 'static');
        modalDiv.innerHTML = `
            <div class="modal-dialog modal-dialog-centered modal-lg">
                <div class="modal-content">
                    <div class="modal-header bg-warning">
                        <h5 class="modal-title">
                            <i class="fas fa-location-arrow"></i> 位置情報の設定方法
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="alert alert-warning mb-3">
                            <i class="fas fa-exclamation-circle"></i> 
                            位置情報の共有には、ブラウザの位置情報許可が必要です
                        </div>
                        ${instructions}
                        <div class="mt-3 p-3 bg-light rounded">
                            <h6 class="text-muted mb-2"><i class="fas fa-shield-alt"></i> プライバシー保護について</h6>
                            <small class="text-muted">
                                • 位置情報は本セッション内でのみ共有されます<br>
                                • 位置情報の共有はいつでも停止できます
                            </small>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                            閉じる
                        </button>
                        <button type="button" class="btn btn-primary" onclick="location.reload()">
                            <i class="fas fa-redo"></i> ページを再読み込み
                        </button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modalDiv);
        try {
            const modal = new bootstrap.Modal(modalDiv);
            modal.show();
        } catch (error) {
            console.error('Failed to show modal:', error);
        }

        try {
            ui?.showNotification?.('位置情報が拒否されました。設定方法を確認してください', 'warning', 'fas fa-map-marker-alt');
        } catch {}
    }

    updateLocationStatus() {
        if (!ui?.elements?.locationStatus) return;

        if (!state?.isSharing) {
            ui.updateStatus('location', 'waiting', '参加中（未共有）');
            return;
        }

        const pos = state.lastKnownPosition;
        const hasValidLocation =
            pos && pos.coords &&
            pos.coords.latitude !== null &&
            pos.coords.longitude !== null &&
            !isNaN(pos.coords.latitude) &&
            !isNaN(pos.coords.longitude);

        if (!hasValidLocation) {
            ui.updateStatus('location', 'waiting', '状態確認中');
            return;
        }

        if (state.isInBackground) {
            ui.updateStatus('location', 'background', 'バックグラウンド');
        } else {
            ui.updateStatus('location', 'active', 'オンライン');
        }
    }

    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    calculateBearing(lat1, lon1, lat2, lon2) {
        const toRad = (d) => d * Math.PI / 180;
        const toDeg = (r) => r * 180 / Math.PI;
        const φ1 = toRad(lat1);
        const φ2 = toRad(lat2);
        const λ1 = toRad(lon1);
        const λ2 = toRad(lon2);
        const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
        let brng = toDeg(Math.atan2(y, x));
        brng = (brng + 360) % 360;
        return brng;
    }
}


// === マップ管理クラス ===
class MapManager {
    constructor() {
        this.map = null;

        // レイヤ管理
        this.markers = {};
        this.accuracyCircles = {};
        this.animationCircles = {};
        this.directionIndicators = {};
        this.clusterConnections = {};
        this.openClusterPopups = new Map();

        // 状態
        this.mapInitialized = false;
        this.markerUpdateQueue = new Map();
        this.clusters = new Map();
        this.currentClusters = new Map();
        this.pulseAnimations = {};
        this.movementTrackers = {};
        this.previousPositions = {};
        this.lastUpdateTimes = {};
        this.originalPositions = {};
        this.movementStopTimers = {};
        this.speedHistory = {};
        this.lastSignificantMove = {};
        this.positionHistory = {};
        this.persistentClusterIds = new Map();
        this.clusterMemberHistory = new Map();
        this.nextClusterId = 1;
        this.preferredZoomByParticipant = new Map();

        // アニメ用
        this.rippleAnimationFrames = {};

        // 定数（z-index順序をPANEで固定）
        this.PANES = {
            tile: 'tilePane', // Leaflet既定: 200
            accuracy: 'accuracyPane', // 400
            connection: 'connectionPane', // 450
            direction: 'directionPane', // 580  ← マーカーより下
            marker: 'customMarkerPane', // 600  ← 通常マーカー
            clusterCenter: 'clusterCenterPane' // 680  ← マーカーより上、Popup(700)より下
            // tooltipPane(650)/popupPane(700) は既定を使用
        };
        this.Z = {
            accuracy: 400,
            connection: 450,
            direction: 580,
            marker: 600,
            clusterCenter: 680
        };
    }

    // === 初期化 ===
    init() {
        this.map = L.map('map', {
            zoomControl: false,
            maxZoom: 22,
            minZoom: 0,
            zoomSnap: 0.25,
            zoomDelta: 0.5,
            wheelPxPerZoomLevel: 60,
            wheelDebounceTime: 20,
            touchZoom: 'center',
            inertia: true
        }).setView([35.6762, 139.6503], 13);

        // タイル
        L.tileLayer(
            'https://api.maptiler.com/maps/jp-mierune-streets/{z}/{x}/{y}.png?key=RZb1fB7Bbfc62pS2buxj', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, &copy; <a href="https://www.maptiler.com/">MapTiler</a>, &copy; <a href="https://mierune.co.jp">MIERUNE</a>',
                minZoom: 0,
                maxZoom: 22,
                maxNativeZoom: 20
            }
        ).addTo(this.map);

        // Pane作成（順序は仕様どおり）
        this._createPanes();

        // ズームコントロール左上
        L.control.zoom({
            position: 'topleft'
        }).addTo(this.map);

        // カスタム全画面
        this.addCustomFullscreenControl();

        this.setupEventHandlers();
        this.mapInitialized = true;
    }

    // === Pane作成 ===
    _createPanes() {
        const make = (name, z) => {
            const p = this.map.createPane(name);
            p.style.zIndex = z.toString();
            p.style.pointerEvents = 'none'; // 基本は非インタラクティブ（必要箇所で個別に可）
            return p;
        };
        make(this.PANES.accuracy, this.Z.accuracy);
        make(this.PANES.connection, this.Z.connection);
        make(this.PANES.direction, this.Z.direction);
        const markerPane = this.map.createPane(this.PANES.marker);
        markerPane.style.zIndex = this.Z.marker.toString();
        markerPane.style.pointerEvents = 'auto'; // マーカーはクリック可能
        make(this.PANES.clusterCenter, this.Z.clusterCenter);
    }

    // === 全画面コントロール（iOSフォールバック付き） ===
    addCustomFullscreenControl() {
        const self = this;
        if (this._isPseudoFullscreen == null) this._isPseudoFullscreen = false;
        this._fsListeners = this._fsListeners || null;

        const FullscreenControl = L.Control.extend({
            options: {
                position: 'topright'
            },
            onAdd: (map) => {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-fullscreen');
                const button = L.DomUtil.create('a', 'leaflet-control-fullscreen-button', container);

                // 基本UI
                button.setAttribute('role', 'button');
                button.setAttribute('aria-label', '全画面表示');
                button.title = '全画面表示';
                button.innerHTML = '<span class="fullscreen-icon">⛶</span>';
                button.style.cssText = 'width:30px;height:30px;line-height:30px;text-align:center;text-decoration:none;color:#333;background:#fff;display:block;font-size:18px;cursor:pointer;user-select:none;';
                container.style.cssText = 'box-shadow:0 1px 5px rgba(0,0,0,.4);border-radius:4px;background:#fff;';

                // クリックが地図に奪われないように
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                // 対象要素
                const mapEl = document.getElementById('map');

                // FS API 検出
                const api = {
                    request: mapEl.requestFullscreen || mapEl.webkitRequestFullscreen || mapEl.mozRequestFullScreen || mapEl.msRequestFullscreen,
                    exit: document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen,
                    enabled: document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled
                };
                const hasNativeFS = !!api.request && (api.enabled === undefined || api.enabled);

                const isIOS = /iP(hone|ad|od)/.test(navigator.platform) || /iPhone|iPad|iPod/.test(navigator.userAgent);
                const isStandalone = window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;

                // 疑似フルスクリーン（iOS/失敗時フォールバック）
                const pseudoFS = {
                    enter() {
                        if (self._isPseudoFullscreen) return;
                        self._isPseudoFullscreen = true;

                        self._prevFSState = {
                            docOverflow: document.documentElement.style.overflow,
                            bodyOverflow: document.body.style.overflow,
                            mapStyle: mapEl.getAttribute('style') || ''
                        };

                        document.documentElement.style.overflow = 'hidden';
                        document.body.style.overflow = 'hidden';

                        const applySize = () => {
                            const h = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
                            mapEl.style.position = 'fixed';
                            mapEl.style.inset = '0';
                            mapEl.style.width = '100vw';
                            mapEl.style.height = `${h}px`; // iOS のアドレスバー分を除外
                            mapEl.style.zIndex = '9999';
                            mapEl.style.background = mapEl.style.background || '#000';
                        };
                        applySize();

                        const onVV = () => applySize();
                        const onOri = () => setTimeout(applySize, 150);

                        self._fsListeners = {
                            onVV,
                            onOri
                        };
                        window.addEventListener('resize', onVV);
                        window.addEventListener('orientationchange', onOri);
                        if (window.visualViewport) window.visualViewport.addEventListener('resize', onVV);

                        // Leaflet 再レイアウト
                        setTimeout(() => map.invalidateSize(), 120);

                        // ボタン表示更新
                        button.innerHTML = '<span class="fullscreen-icon">✕</span>';
                        button.title = '全画面解除';
                    },
                    exit() {
                        if (!self._isPseudoFullscreen) return;
                        self._isPseudoFullscreen = false;

                        const prev = self._prevFSState || {};
                        if (self._fsListeners) {
                            window.removeEventListener('resize', self._fsListeners.onVV);
                            window.removeEventListener('orientationchange', self._fsListeners.onOri);
                            if (window.visualViewport) window.visualViewport.removeEventListener('resize', self._fsListeners.onVV);
                            self._fsListeners = null;
                        }

                        // スタイル復元
                        mapEl.setAttribute('style', prev.mapStyle || '');
                        document.documentElement.style.overflow = prev.docOverflow || '';
                        document.body.style.overflow = prev.bodyOverflow || '';

                        setTimeout(() => map.invalidateSize(), 120);
                        button.innerHTML = '<span class="fullscreen-icon">⛶</span>';
                        button.title = '全画面表示';
                    }
                };

                // FS状態監視（ネイティブ用）
                const onFSChange = () => {
                    const isFS = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                    if (isFS) {
                        button.innerHTML = '<span class="fullscreen-icon">✕</span>';
                        button.title = '全画面解除';
                    } else {
                        button.innerHTML = '<span class="fullscreen-icon">⛶</span>';
                        button.title = '全画面表示';
                    }
                    setTimeout(() => map.invalidateSize(), 100);
                };
                document.addEventListener('fullscreenchange', onFSChange);
                document.addEventListener('webkitfullscreenchange', onFSChange);
                document.addEventListener('mozfullscreenchange', onFSChange);
                document.addEventListener('MSFullscreenChange', onFSChange);

                // クリック（= ユーザー操作内で実行）
                L.DomEvent.on(button, 'click', (e) => {
                    L.DomEvent.stop(e);

                    // すでにネイティブFS or 疑似FSなら解除
                    const isNativeFS = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                    if (isNativeFS) {
                        if (api.exit) api.exit.call(document);
                        return;
                    }
                    if (self._isPseudoFullscreen) {
                        pseudoFS.exit();
                        return;
                    }

                    // まずネイティブ試行 → 失敗/非対応なら疑似FSへ
                    if (hasNativeFS && !(isIOS && isStandalone)) {
                        try {
                            const p = api.request.call(mapEl);
                            // Safari16+ は Promise を返す。失敗時は catch で疑似FSへ
                            if (p && typeof p.then === 'function') {
                                p.then(() => {
                                    /* ok */ }).catch(() => pseudoFS.enter());
                            }
                        } catch (_) {
                            // 例外時は疑似FS
                            pseudoFS.enter();
                        }
                    } else {
                        // iOS 古め / PWA / 非対応ブラウザ
                        pseudoFS.enter();
                    }
                });

                // ページ遷移/破棄時の後始末（疑似FS解除）
                window.addEventListener('pagehide', () => {
                    if (self._isPseudoFullscreen) pseudoFS.exit();
                });

                return container;
            }
        });

        this.map.addControl(new FullscreenControl());
    }

    // === ズーム好み ===
    setPreferredZoom(id, z) {
        if (typeof z === 'number') this.preferredZoomByParticipant.set(id, z);
    }
    getPreferredZoom(id) {
        return this.preferredZoomByParticipant.get(id) ?? 16;
    }

    // === クラスタ検出 ===
    detectAndHandleClusters(locations) {
        const clusters = new Map(),
            processed = new Set(),
            tmp = [];
        locations.forEach((loc, i) => {
            if (processed.has(loc.participant_id)) return;
            const cluster = [loc];
            processed.add(loc.participant_id);
            locations.forEach((o, j) => {
                if (i === j || processed.has(o.participant_id)) return;
                const d = this.calculateDistance(loc.latitude, loc.longitude, o.latitude, o.longitude);
                if (d <= CONFIG.CLUSTERING_DISTANCE) {
                    cluster.push(o);
                    processed.add(o.participant_id);
                }
            });
            if (cluster.length > 1) {
                tmp.push(cluster);
            } else {
                clusters.set(loc.participant_id, {
                    participants: [loc],
                    centerLat: loc.latitude,
                    centerLng: loc.longitude,
                    isCluster: false
                });
            }
        });
        tmp.forEach(cluster => {
            const centerLat = cluster.reduce((s, p) => s + p.latitude, 0) / cluster.length;
            const centerLng = cluster.reduce((s, p) => s + p.longitude, 0) / cluster.length;
            const persistentId = this.getOrCreatePersistentClusterId(cluster);
            const onlineCount = cluster.filter(p => p.is_online === true && p.status === 'sharing').length;
            const offlineCount = cluster.filter(p => p.is_online === false || p.status === 'stopped').length;
            clusters.set(persistentId, {
                participants: cluster,
                centerLat,
                centerLng,
                isCluster: true,
                onlineCount,
                offlineCount,
                persistentId
            });
        });
        return clusters;
    }

    getOrCreatePersistentClusterId(members) {
        const memberIds = members.map(m => m.participant_id).sort();
        for (const [cid, history] of this.clusterMemberHistory) {
            const common = memberIds.filter(id => history.has(id));
            const threshold = Math.max(1, Math.floor(Math.min(memberIds.length, history.size) * 0.5));
            if (common.length >= threshold) {
                memberIds.forEach(id => history.add(id));
                const cur = new Set(memberIds);
                [...history].forEach(id => {
                    const p = state.participantsData.find(x => x.participant_id === id);
                    if (!cur.has(id) && (!p || p.status !== 'sharing')) history.delete(id);
                });
                return cid;
            }
        }
        const newId = `cluster_${this.nextClusterId++}`;
        this.clusterMemberHistory.set(newId, new Set(memberIds));
        this.persistentClusterIds.set(newId, memberIds);
        return newId;
    }

    // === 汎用 ===
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000,
            dLat = (lat2 - lat1) * Math.PI / 180,
            dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    calculateBearing(lat1, lon1, lat2, lon2) {
        const dLon = (lon2 - lon1) * Math.PI / 180,
            la1 = lat1 * Math.PI / 180,
            la2 = lat2 * Math.PI / 180;
        const y = Math.sin(dLon) * Math.cos(la2);
        const x = Math.cos(la1) * Math.sin(la2) - Math.sin(la1) * Math.cos(la2) * Math.cos(dLon);
        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    // === イベント ===
    setupEventHandlers() {
        this.map.on('dragstart', () => {
            state.userInteracted = true;
            state.autoFitEnabled = false;
            if (state.followingParticipantId) state.followingParticipantId = null;
            if (state.followingGroup) {
                state.followingGroup = null;
                this.stopGroupFollowingTimer();
            }
        });
        this.map.on('zoomstart', () => {
            state.userInteracted = true;
            state.autoFitEnabled = false;
        });
        this.map.on('zoomend', () => {
            Object.keys(this.directionIndicators).forEach(pid => {
                const ind = this.directionIndicators[pid];
                if (!ind) return;
                const participant = state.participantsData.find(p => p.participant_id === pid);
                const marker = this.markers[pid];
                const pos = marker ? marker.getLatLng() : ind.getLatLng();
                if (!participant || !pos) return;
                const inCluster = !!this.getCurrentClusterInfo(pid);
                const stopped = (participant.is_online === false) || (participant.status !== 'sharing');
                const bg = !!participant.is_background;
                if (inCluster || stopped || bg) {
                    if (this.map.hasLayer(ind)) this.map.removeLayer(ind);
                    delete this.directionIndicators[pid];
                    return;
                }
                let bearing = null;
                const hist = (this.positionHistory?.[pid]) || [];
                if (hist.length >= 2) {
                    const a = hist[hist.length - 2].position,
                        b = hist[hist.length - 1].position;
                    bearing = this.calculateBearing(a[0], a[1], b[0], b[1]);
                }
                if ((bearing === null || Number.isNaN(bearing)) && this.previousPositions?.[pid]) {
                    const prev = this.previousPositions[pid];
                    bearing = this.calculateBearing(prev[0], prev[1], pos.lat, pos.lng);
                }
                if (bearing === null || Number.isNaN(bearing)) return;
                const color = this.getParticipantColor(pid);
                if (this.map.hasLayer(ind)) this.map.removeLayer(ind);
                delete this.directionIndicators[pid];
                this.createDirectionIndicator(pid, [pos.lat, pos.lng], bearing, color);
            });
        });
        this.map.on('click', (e) => {
            if (!e.originalEvent.target.closest('.custom-marker') && !e.originalEvent.target.closest('.leaflet-popup')) {
                if (state.followingParticipantId) state.followingParticipantId = null;
                if (state.followingGroup) {
                    state.followingGroup = null;
                    this.stopGroupFollowingTimer();
                }
            }
        });
    }

    isInitialized() {
        return this.mapInitialized;
    }

    focusOnPosition(lat, lng, zoom = null) {
        if (!this.mapInitialized) return;
        if (typeof zoom === 'number') this.map.setView([lat, lng], zoom);
        else this.map.panTo([lat, lng]);
    }

    // === メイン更新 ===
    updateMarkers(locations) {
        if (!this.mapInitialized) return;

        const currentMarkerIds = new Set(Object.keys(this.markers));
        const valid = locations.filter(loc => {
            const ok = loc.latitude !== null && loc.longitude !== null && loc.latitude !== 999.0 && loc.longitude !== 999.0 && !isNaN(loc.latitude) && !isNaN(loc.longitude);
            return ok && loc.status === 'sharing';
        });

        // BG時刻保持
        valid.forEach(loc => {
            const m = this.markers[loc.participant_id];
            if (!m) return;
            if (loc.is_background) {
                if (!m.backgroundTimestamp) {
                    m.backgroundTimestamp = loc.background_entered_at || loc.last_updated;
                }
            } else {
                if (m.backgroundTimestamp) {
                    m.backgroundTimestamp = null;
                }
            }
        });

        const validIds = new Set(valid.map(l => l.participant_id));
        [...currentMarkerIds].filter(id => !validIds.has(id)).forEach(id => this.removeMarker(id));

        const clusters = this.detectAndHandleClusters(valid);

        // クラスタ追従：解散したら停止（個人追従へ移行しない）
        if (state.followingGroup && state.followingGroup.length > 0) {
            let next = null,
                max = 0;
            clusters.forEach((c, cid) => {
                if (!c.isCluster) return;
                const ids = c.participants.map(p => p.participant_id);
                const overlap = state.followingGroup.filter(id => ids.includes(id)).length;
                const th = Math.max(2, Math.ceil(state.followingGroup.length * 0.5));
                if (overlap >= th && overlap > max) {
                    max = overlap;
                    next = cid;
                }
            });
            if (next) {
                const c = clusters.get(next);
                const mem = c.participants.map(p => p.participant_id);
                if (!(state.followingGroup.length === mem.length && state.followingGroup.every(id => mem.includes(id)))) {
                    /* log */ }
                state.followingGroup = mem;
            } else {
                this.stopGroupFollowingTimer();
                state.followingGroup = null;
                state.followingParticipantId = null;
                state.autoFitEnabled = false;
            }
        }

        this.currentClusters = clusters;

        this.clearAllClusterConnections();

        const clusteredIds = new Set();
        clusters.forEach((cluster, cid) => {
            if (cluster.isCluster) {
                cluster.participants.forEach(p => clusteredIds.add(p.participant_id));
                this.updateClusterMarkers(cluster, cid);
            } else {
                const p = cluster.participants[0];
                const markerLoc = {
                    ...p,
                    isOffline: false,
                    is_online: true,
                    isInCluster: false,
                    clusterSize: 1,
                    isSingleUpdate: false
                };
                this.updateSingleMarker(markerLoc);
            }
        });

        this.validateMarkerStates(locations);
    }

    // === 整合性確認 ===
    validateMarkerStates(locations) {
        const markerCount = Object.keys(this.markers).length;
        const locationCount = locations.filter(loc => {
            const ok = loc.latitude !== null && loc.longitude !== null && loc.latitude !== 999.0 && loc.longitude !== 999.0 && !isNaN(loc.latitude) && !isNaN(loc.longitude);
            const show = (loc.is_online && loc.status === 'sharing') || (!loc.is_online && loc.has_shared_before);
            return ok && show;
        }).length;
        if (markerCount !== locationCount) {
            console.warn(`マーカー数不整合: 表示 ${markerCount} ≠ 期待 ${locationCount}`);
        }
    }

    // === クラスタ描画 ===
    updateClusterMarkers(cluster, clusterId) {
        const parts = cluster.participants,
            centerLat = cluster.centerLat,
            centerLng = cluster.centerLng;

        let shouldAutoReopen = false;
        if (this.pendingClusterReopens) shouldAutoReopen = this.pendingClusterReopens.has(clusterId);

        this.drawClusterConnections(cluster, clusterId);

        const sorted = [...parts].sort((a, b) => a.participant_id.localeCompare(b.participant_id));
        sorted.forEach((p, idx) => {
            const angle = 2 * Math.PI * idx / sorted.length,
                r = CONFIG.CLUSTER_OFFSET_RADIUS;
            const lat = centerLat + (r * 0.00001) * Math.cos(angle);
            const lng = centerLng + (r * 0.00001) * Math.sin(angle);
            const isOffline = p.is_online === false || p.status === 'stopped';

            if (this.movementTrackers?.[p.participant_id]) this.stopMovementAnimation(p.participant_id);
            if (this.directionIndicators?.[p.participant_id]) {
                if (this.map.hasLayer(this.directionIndicators[p.participant_id])) this.map.removeLayer(this.directionIndicators[p.participant_id]);
                delete this.directionIndicators[p.participant_id];
            }
            const offsetP = {
                ...p,
                latitude: lat,
                longitude: lng,
                isInCluster: true,
                clusterSize: sorted.length,
                clusterIndex: idx,
                clusterCenter: {
                    lat: centerLat,
                    lng: centerLng
                },
                isOffline,
                is_online: p.is_online,
                forceShowClusterBadge: true
            };
            this.updateSingleMarker(offsetP);
        });

        if (shouldAutoReopen) {
            const grp = this.clusterConnections[clusterId];
            if (grp) {
                grp.eachLayer(layer => {
                    if (layer instanceof L.Marker) this.processPendingClusterReopens(clusterId, layer, parts);
                });
            }
        }
    }

    drawClusterConnections(cluster, clusterId) {
        if (this.clusterConnections[clusterId]) this.map.removeLayer(this.clusterConnections[clusterId]);

        const parts = cluster.participants;
        if (parts.length < 2) return;

        // クラスタ内の方向指示は全削除
        parts.forEach(p => {
            if (this.directionIndicators?.[p.participant_id]) {
                if (this.map.hasLayer(this.directionIndicators[p.participant_id])) this.map.removeLayer(this.directionIndicators[p.participant_id]);
                delete this.directionIndicators[p.participant_id];
            }
        });

        const centerLat = cluster.centerLat,
            centerLng = cluster.centerLng;
        const sorted = [...parts].sort((a, b) => a.participant_id.localeCompare(b.participant_id));

        const connectionGroup = L.layerGroup();
        sorted.forEach((p, idx) => {
            const angle = 2 * Math.PI * idx / sorted.length,
                r = CONFIG.CLUSTER_OFFSET_RADIUS;
            const lat = centerLat + (r * 0.00001) * Math.cos(angle);
            const lng = centerLng + (r * 0.00001) * Math.sin(angle);
            const isOffline = p.is_online === false || p.status === 'stopped';
            const color = isOffline ? '#6c757d' : this.getParticipantColor(p.participant_id);
            const line = L.polyline([
                [centerLat, centerLng],
                [lat, lng]
            ], {
                color,
                weight: isOffline ? 2 : 3,
                opacity: isOffline ? 0.3 : 0.5,
                dashArray: isOffline ? '3,8' : '5,10',
                className: `cluster-connection-line ${isOffline?'offline-line':'online-line'}`,
                interactive: false,
                bubblingMouseEvents: false,
                pane: this.PANES.connection
            });
            connectionGroup.addLayer(line);
        });

        // 中心ピン（アニメ無し・Paneで最前面に）
        const centerPinIcon = this.createClusterCenterPin(parts);
        const centerMarker = L.marker([centerLat, centerLng], {
            icon: centerPinIcon,
            pane: this.PANES.clusterCenter
        });
        const popupContent = this.createClusterCenterPopup(parts, centerLat, centerLng);
        centerMarker.bindPopup(popupContent, {
            closeButton: true,
            autoClose: false,
            closeOnClick: false,
            closeOnEscapeKey: true,
            keepInView: true,
            autoPan: false,
            maxWidth: 300,
            offset: [0, -15]
        });

        const wasOpen = this.isClusterPopupOpen(clusterId);
        centerMarker.on('click', (e) => {
            centerMarker.openPopup();
            this.trackOpenClusterPopup(clusterId, centerMarker, parts);
            L.DomEvent.stopPropagation(e);
        });
        centerMarker.on('popupclose', () => {
            this.untrackClusterPopup(clusterId);
            this.manuallyClosedClusters = this.manuallyClosedClusters || new Set();
            this.manuallyClosedClusters.add(clusterId);
            setTimeout(() => {
                if (this.manuallyClosedClusters) this.manuallyClosedClusters.delete(clusterId);
            }, 5000);
        });

        connectionGroup.addLayer(centerMarker);
        this.clusterConnections[clusterId] = connectionGroup;
        connectionGroup.addTo(this.map);

        if (wasOpen && !this.isManuallyClosedCluster(clusterId)) {
            setTimeout(() => {
                if (this.map.hasLayer(centerMarker)) {
                    centerMarker.openPopup();
                    this.trackOpenClusterPopup(clusterId, centerMarker, parts);
                }
            }, 200);
        }
    }

    isManuallyClosedCluster(clusterId) {
        return (this.manuallyClosedClusters && this.manuallyClosedClusters.has(clusterId)) || false;
    }
    isClusterPopupOpen(clusterId) {
        const t = this.openClusterPopups.get(clusterId);
        if (!t) return false;
        if (t.marker && this.map.hasLayer(t.marker)) {
            const pop = t.marker.getPopup();
            return pop && this.map.hasLayer(pop);
        }
        return false;
    }
    trackOpenClusterPopup(clusterId, marker, parts) {
        this.openClusterPopups.set(clusterId, {
            marker,
            participants: parts.map(p => ({
                id: p.participant_id,
                name: p.participant_name || `参加者${p.participant_id.substring(0,4)}`
            })),
            openedAt: Date.now(),
            clusterId,
            centerLat: marker.getLatLng().lat,
            centerLng: marker.getLatLng().lng
        });
    }
    untrackClusterPopup(clusterId) {
        if (this.openClusterPopups.get(clusterId)) this.openClusterPopups.delete(clusterId);
    }

    clearAllClusterConnections() {
        const open = new Map();
        this.openClusterPopups.forEach((info, cid) => {
            if (this.isClusterPopupOpen(cid)) open.set(cid, {
                participants: info.participants,
                openedAt: info.openedAt
            });
        });
        Object.keys(this.clusterConnections).forEach(cid => {
            if (this.clusterConnections[cid]) this.map.removeLayer(this.clusterConnections[cid]);
        });
        this.clusterConnections = {};
        this.openClusterPopups.clear();
        this.pendingClusterReopens = open;
    }
    processPendingClusterReopens(clusterId, marker, parts) {
        if (!this.pendingClusterReopens) return false;
        const pending = this.pendingClusterReopens.get(clusterId);
        if (!pending) return false;
        const cur = parts.map(p => p.participant_id).sort();
        const pen = pending.participants.map(p => p.id).sort();
        const same = cur.length === pen.length && cur.every((id, i) => id === pen[i]);
        if (same) {
            setTimeout(() => {
                if (this.map.hasLayer(marker)) {
                    marker.openPopup();
                    this.trackOpenClusterPopup(clusterId, marker, parts);
                }
            }, 150);
            this.pendingClusterReopens.delete(clusterId);
            return true;
        }
        this.pendingClusterReopens.delete(clusterId);
        return false;
    }

    // === クラスタ中心ピン（アニメ除去） ===
    createClusterCenterPin(participants) {
        const memberCount = participants.length;
        const baseColor = '#FFD700';
        const pinHtml = `
    <div style="position:relative;width:48px;height:48px;display:flex;align-items:center;justify-content:center;">
      <svg width="48" height="48" viewBox="0 0 24 24" style="filter:drop-shadow(0 4px 8px rgba(0,0,0,.3));">
        <path fill="${baseColor}" stroke="white" stroke-width="2" d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/>
        <circle cx="12" cy="9" r="2.5" fill="white"/>
      </svg>
      <div style="position:absolute;top:-8px;right:-8px;background:#ee5a52;color:#fff;font-size:12px;font-weight:700;padding:4px 6px;border-radius:50%;min-width:24px;height:24px;display:flex;align-items:center;justify-content:center;border:2px solid #fff;box-shadow:0 2px 8px rgba(0,0,0,.2);">${memberCount}</div>
    </div>`;
        return L.divIcon({
            html: pinHtml,
            className: 'cluster-center-pin-icon',
            iconSize: [48, 48],
            iconAnchor: [24, 48],
            popupAnchor: [0, -48]
        });
    }

    // createClusterCenterPopup
    createClusterCenterPopup(participants, centerLat, centerLng) {
        const popupDiv = document.createElement('div');
        popupDiv.style.minWidth = '200px';
        popupDiv.style.maxWidth = '400px';

        const onlineCount = participants.filter(p => p.is_online === true && p.status === 'sharing').length;
        const offlineCount = participants.filter(p => p.is_online === false || p.status === 'stopped').length;

        const headerDiv = document.createElement('div');
        headerDiv.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 12px;
        margin: -9px -12px 12px -12px;
        border-radius: 8px 8px 0 0;
        font-weight: bold;
        text-align: center;
    `;
        let headerText = `<i class="fas fa-users"></i> グループ集合地点 (${participants.length}人)`;
        if (offlineCount > 0) {
            headerText += `<br><small style="font-weight: normal;">オンライン: ${onlineCount}人 / オフライン: ${offlineCount}人</small>`;
        }
        headerDiv.innerHTML = headerText;
        popupDiv.appendChild(headerDiv);

        const locationDiv = document.createElement('div');
        locationDiv.style.cssText = 'margin-bottom: 12px; font-size: 12px; color: #666;';
        locationDiv.innerHTML = `
        📍 ${centerLat.toFixed(6)}, ${centerLng.toFixed(6)}<br>
        <small>※ メンバーの中心座標</small>
    `;
        popupDiv.appendChild(locationDiv);

        const membersDiv = document.createElement('div');
        membersDiv.innerHTML = '<strong style="color: #333;">📝 メンバー:</strong>';
        popupDiv.appendChild(membersDiv);

        const membersList = document.createElement('ul');
        membersList.style.cssText = `
        margin: 8px 0 0 0;
        padding-left: 16px;
        max-height: ${participants.length > 5 ? '120px' : 'auto'};
        overflow-y: ${participants.length > 5 ? 'auto' : 'visible'};
    `;

        // 自分→名前昇順（固定）
        const selfId = state.participantId;
        const displayName = (p) => (p.participant_name || `参加者${p.participant_id.substring(0, 4)}`);
        const sortedByName = [...participants].sort((a, b) =>
            displayName(a).localeCompare(displayName(b), 'ja')
        );
        const orderedMembers = [
            ...sortedByName.filter(p => p.participant_id === selfId),
            ...sortedByName.filter(p => p.participant_id !== selfId),
        ];

        orderedMembers.forEach((participant) => {
            const li = document.createElement('li');
            const color = this.getParticipantColor(participant.participant_id);
            const name = displayName(participant).substring(0, 25);
            const isOffline = participant.is_online === false || participant.status === 'stopped';

            li.style.cssText = 'margin-bottom: 4px; font-size: 13px;';
            li.innerHTML = `
            <span style="
                display: inline-block;
                width: 12px;
                height: 12px;
                background: ${isOffline ? '#6c757d' : color};
                border-radius: 50%;
                margin-right: 6px;
                vertical-align: middle;
                opacity: ${isOffline ? '0.6' : '1'};
            "></span>
            <strong style="color: ${isOffline ? '#6c757d' : color};">
                ${name}
                ${isOffline ? ' <span style="font-weight: normal; font-size: 11px;">(オフライン)</span>' : ''}
            </strong>
            ${participant.participant_id === selfId ? '<span style="color: #007bff; font-size: 11px;">(自分)</span>' : ''}
        `;
            membersList.appendChild(li);
        });

        popupDiv.appendChild(membersList);

        const actionsDiv = document.createElement('div');
        actionsDiv.style.cssText = `
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
    `;

        const topButtonsDiv = document.createElement('div');
        topButtonsDiv.style.cssText = `
        display: flex;
        gap: 6px;
        align-items: stretch;
    `;

        const focusButton = document.createElement('button');
        focusButton.className = 'btn btn-sm btn-primary';
        focusButton.innerHTML = '<i class="fas fa-crosshairs"></i> 追従';
        focusButton.style.cssText = `
        flex: 1;
        min-height: 32px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: all 0.2s ease;
        font-size: 12px;
    `;

        const resetButton = document.createElement('button');
        resetButton.className = 'btn btn-sm btn-outline-secondary';
        resetButton.innerHTML = '<i class="fas fa-expand-arrows-alt"></i> 全体';
        resetButton.style.cssText = `
        flex: 1;
        min-height: 32px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: all 0.2s ease;
        font-size: 12px;
    `;

        const navigationButton = document.createElement('button');
        navigationButton.className = 'btn btn-sm btn-success';
        navigationButton.innerHTML = '<i class="fas fa-route"></i> Google Mapsで集合地点に案内';
        navigationButton.style.cssText = `
        width: 100%;
        min-height: 34px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: all 0.2s ease;
        font-size: 13px;
        font-weight: 500;
    `;

        const updateButtonStates = () => {
            const isFollowingGroup = state.followingGroup &&
                state.followingGroup.some(id => participants.map(p => p.participant_id).includes(id));

            resetButton.innerHTML = '<i class="fas fa-expand-arrows-alt"></i> 全体';
            resetButton.className = 'btn btn-sm btn-outline-secondary';
            resetButton.disabled = false;
            resetButton.style.cssText = `
            flex: 1;
            min-height: 32px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: all 0.2s ease;
            font-size: 12px;
            opacity: 1;
            cursor: pointer;
        `;

            actionsDiv.style.display = 'none';
            actionsDiv.offsetHeight;
            actionsDiv.style.display = 'flex';
        };

        focusButton.onclick = () => {
            this.startGroupFollowing(participants);
            focusButton.style.transform = 'scale(0.95)';
            setTimeout(() => {
                updateButtonStates();
                focusButton.style.transform = 'scale(1)';
            }, 100);
            this.map.closePopup();
        };

        resetButton.onclick = () => {
            this.focusOnGroupOnly(participants);
            resetButton.innerHTML = '<i class="fas fa-check"></i> ✓';
            resetButton.className = 'btn btn-sm btn-success';
            resetButton.disabled = true;
            resetButton.style.cssText = `
            flex: 1;
            min-height: 32px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: all 0.2s ease;
            font-size: 12px;
            opacity: 0.8;
            cursor: not-allowed;
        `;
            actionsDiv.style.display = 'none';
            actionsDiv.offsetHeight;
            actionsDiv.style.display = 'flex';
            setTimeout(() => {
                updateButtonStates();
            }, 1000);
            this.map.closePopup();
        };

        navigationButton.onclick = () => {
            this.openGoogleMapsNavigationToClusterCenter(centerLat, centerLng, participants);
            navigationButton.innerHTML = '<i class="fas fa-check"></i> 案内を開始しました';
            navigationButton.className = 'btn btn-sm btn-success';
            navigationButton.disabled = true;
            navigationButton.style.opacity = '0.8';
            setTimeout(() => {
                navigationButton.innerHTML = '<i class="fas fa-route"></i> Google Mapsで集合地点に案内';
                navigationButton.className = 'btn btn-sm btn-success';
                navigationButton.disabled = false;
                navigationButton.style.opacity = '1';
            }, 2000);
            setTimeout(() => {
                this.map.closePopup();
            }, 1500);
        };

        navigationButton.onmouseenter = () => {
            if (!navigationButton.disabled) {
                navigationButton.style.transform = 'scale(1.02)';
                navigationButton.style.boxShadow = '0 4px 12px rgba(40, 167, 69, 0.3)';
            }
        };
        navigationButton.onmouseleave = () => {
            navigationButton.style.transform = 'scale(1)';
            navigationButton.style.boxShadow = 'none';
        };

        const buttonUpdateInterval = setInterval(() => {
            if (popupDiv.closest('.leaflet-popup-content')) {
                const previousFollowingState = focusButton.disabled;
                updateButtonStates();
                if (previousFollowingState !== focusButton.disabled) {
                    /* no-op */
                }
            } else {
                clearInterval(buttonUpdateInterval);
            }
        }, 1000);

        updateButtonStates();

        topButtonsDiv.appendChild(focusButton);
        topButtonsDiv.appendChild(resetButton);
        actionsDiv.appendChild(topButtonsDiv);
        actionsDiv.appendChild(navigationButton);
        popupDiv.appendChild(actionsDiv);

        popupDiv.style.cssText = `
        min-width: 200px;
        max-width: 300px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        line-height: 1.4;
        overflow: visible;
    `;

        return popupDiv;
    }

    // === 集合地点への案内 ===
    openGoogleMapsNavigationToClusterCenter(lat, lng, parts) {
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=walking`;
        const opened = window.open(url, '_blank', 'noopener,noreferrer');
        if (opened) {
            ui.showNotification(`${parts.length}人の集合地点への案内を開始しました`, 'success', 'fas fa-route');
        }
    }

    // === グループ全体ビュー ===
    focusOnGroupOnly(parts) {
        if (!parts || !parts.length) return;
        const ms = parts.map(p => this.markers[p.participant_id]).filter(Boolean);
        if (!ms.length) return;
        const g = new L.featureGroup(ms),
            b = g.getBounds();
        if (b.isValid()) this.map.fitBounds(b.pad(0.15));
        state.followingParticipantId = null;
        state.followingGroup = null;
        this.stopGroupFollowingTimer();
        state.autoFitEnabled = false;
    }

    // === グループ追従 ===
    startGroupFollowing(parts) {
        state.followingGroup = parts.map(p => p.participant_id);
        state.followingParticipantId = null;
        this.followGroupWithCurrentZoom(parts);
        this.startGroupFollowingTimer();
    }
    startGroupFollowingTimer() {
        if (this.groupFollowingTimer) {
            clearInterval(this.groupFollowingTimer);
            this.groupFollowingTimer = null;
        }
        this.groupFollowingTimer = setInterval(() => {
            if (!state.followingGroup || !state.followingGroup.length) {
                this.stopGroupFollowingTimer();
                return;
            }
            const active = state.participantsData.filter(p => state.followingGroup.includes(p.participant_id) && p.status === 'sharing' && p.latitude != null && p.longitude != null);
            if (!active.length) {
                this.stopGroupFollowingTimer();
                return;
            }
            let target = null;
            if (this.currentClusters) {
                for (const [cid, c] of this.currentClusters) {
                    if (!c.isCluster) continue;
                    const ids = c.participants.map(p => p.participant_id);
                    const overlap = active.filter(m => ids.includes(m.participant_id)).length;
                    const th = Math.max(2, Math.ceil(active.length * 0.5));
                    if (overlap >= th) {
                        target = c;
                        break;
                    }
                }
            }
            if (target) {
                const ids = target.participants.map(p => p.participant_id);
                if (state.followingGroup.length !== ids.length || !state.followingGroup.every(id => ids.includes(id))) {
                    /* log */ }
                state.followingGroup = ids;
                this.followGroupWithCurrentZoom(target.participants);
            } else {
                this.stopGroupFollowingTimer();
                return;
            }
        }, 1000);
    }
    followGroupWithCurrentZoom(parts) {
        if (!parts || !parts.length) return;
        const lat = parts.reduce((s, p) => s + p.latitude, 0) / parts.length;
        const lng = parts.reduce((s, p) => s + p.longitude, 0) / parts.length;
        const z = this.map.getZoom();
        this.map.setView([lat, lng], z);
    }
    stopGroupFollowingTimer() {
        if (this.groupFollowingTimer) {
            clearInterval(this.groupFollowingTimer);
            this.groupFollowingTimer = null;
        }
        state.followingGroup = null;
        state.followingParticipantId = null;
    }

    // === マーカー削除 ===
    removeMarker(id) {
        this.stopRegularAnimation(id);
        this.stopMovementAnimation(id);
        if (this.directionIndicators?.[id]) {
            if (this.map.hasLayer(this.directionIndicators[id])) this.map.removeLayer(this.directionIndicators[id]);
            delete this.directionIndicators[id];
        }
        if (this.rippleAnimationFrames?.[id]) {
            cancelAnimationFrame(this.rippleAnimationFrames[id]);
            delete this.rippleAnimationFrames[id];
        }
        delete this.previousPositions[id];
        delete this.originalPositions[id];
        delete this.lastUpdateTimes[id];
        delete this.lastSignificantMove[id];
        delete this.positionHistory[id];
        delete this.speedHistory[id];
        if (this.movementStopTimers?.[id]) delete this.movementStopTimers[id];
        if (this.markers[id]) {
            this.map.removeLayer(this.markers[id]);
            delete this.markers[id];
        }
        if (this.accuracyCircles[id]) {
            this.map.removeLayer(this.accuracyCircles[id]);
            delete this.accuracyCircles[id];
        }
        if (this.animationCircles[id]) {
            this.map.removeLayer(this.animationCircles[id]);
            delete this.animationCircles[id];
        }

        Object.keys(this.clusterConnections).forEach(cid => {
            if (cid.includes(id)) {
                this.map.removeLayer(this.clusterConnections[cid]);
                delete this.clusterConnections[cid];
            }
        });
        Object.keys(this.pulseAnimations).forEach(pid => {
            if (pid.includes(id)) {
                clearInterval(this.pulseAnimations[pid].interval);
                if (this.pulseAnimations[pid].circle) this.map.removeLayer(this.pulseAnimations[pid].circle);
                delete this.pulseAnimations[pid];
            }
        });
    }

    // === 自分のマーカー除去 ===
    removeOwnMarker() {
        this.removeMarker(state.participantId);
        state.participantsData = state.participantsData.map(p => p.participant_id === state.participantId ? {
            ...p,
            latitude: null,
            longitude: null,
            accuracy: null,
            status: 'waiting',
            is_online: true
        } : p);
        participantManager.updateList(state.participantsData);
    }

    // === 参加者が属するクラスタ情報 ===
    getCurrentClusterInfo(pid) {
        if (!this.currentClusters) return null;
        for (const [cid, cluster] of this.currentClusters) {
            if (!cluster.isCluster) continue;
            const f = cluster.participants.find(p => p.participant_id === pid);
            if (f) return {
                clusterId: cid,
                clusterCenter: {
                    lat: cluster.centerLat,
                    lng: cluster.centerLng
                },
                participants: cluster.participants,
                participantIndex: cluster.participants.findIndex(p => p.participant_id === pid)
            };
        }
        return null;
    }

    // === 単一マーカー更新（長いが既存仕様維持、Pane指定のみ追加） ===
    updateSingleMarker(location) {
        const originalName = location.participant_name || `参加者${location.participant_id.substring(0,4)}`;
        const name = originalName.substring(0, 30);
        const color = this.getParticipantColor(location.participant_id);
        const isBackground = location.is_background || false;
        const stayMinutes = location.stay_minutes || 0;
        const isInCluster = location.isInCluster || false;
        const clusterSize = location.clusterSize || 1;
        const isOffline = location.isOffline || (!location.is_online && location.has_shared_before);

        const clusterInfo = this.getCurrentClusterInfo(location.participant_id);
        let actualLat = location.latitude,
            actualLng = location.longitude;
        if (clusterInfo) {
            const sorted = [...clusterInfo.participants].sort((a, b) => a.participant_id.localeCompare(b.participant_id));
            const idx = sorted.findIndex(p => p.participant_id === location.participant_id);
            if (idx !== -1) {
                const ang = 2 * Math.PI * idx / sorted.length,
                    r = CONFIG.CLUSTER_OFFSET_RADIUS;
                actualLat = clusterInfo.clusterCenter.lat + (r * 0.00001) * Math.cos(ang);
                actualLng = clusterInfo.clusterCenter.lng + (r * 0.00001) * Math.sin(ang);
            }
        }

        let movementSpeed = 0,
            speedReliable = false,
            isMoving = false;
        const prev = this.previousPositions[location.participant_id];
        const cur = [actualLat, actualLng];

        if (!this.lastUpdateTimes) this.lastUpdateTimes = {};
        if (!this.positionHistory) this.positionHistory = {};
        if (!this.speedHistory) this.speedHistory = {};
        if (!this.lastSignificantMove) this.lastSignificantMove = {};
        if (!this.movementStopTimers) this.movementStopTimers = {};
        if (!this.positionHistory[location.participant_id]) this.positionHistory[location.participant_id] = [];

        const now = Date.now();
        const entry = {
            position: cur,
            time: now,
            accuracy: location.accuracy || 50
        };
        const first = !prev;

        let actualMoveDist = 0;
        if (!first && prev && !clusterInfo && !isInCluster) {
            actualMoveDist = this.calculateDistance(prev[0], prev[1], cur[0], cur[1]);
        } else if (!first && (clusterInfo || isInCluster)) {
            const p0 = this.originalPositions?.[location.participant_id];
            if (p0) {
                actualMoveDist = this.calculateDistance(p0[0], p0[1], location.latitude, location.longitude);
            }
        }

        if (isBackground || clusterInfo || isInCluster) {
            isMoving = false;
            movementSpeed = 0;
            speedReliable = false;
            if (this.directionIndicators[location.participant_id]) {
                if (this.map.hasLayer(this.directionIndicators[location.participant_id])) this.map.removeLayer(this.directionIndicators[location.participant_id]);
                delete this.directionIndicators[location.participant_id];
            }
            if (this.movementTrackers?.[location.participant_id]) {
                if (this.movementTrackers[location.participant_id].animationId) cancelAnimationFrame(this.movementTrackers[location.participant_id].animationId);
                delete this.movementTrackers[location.participant_id];
            }
            if (!isOffline && location.is_online && location.status === 'sharing') {
                const p0 = this.originalPositions?.[location.participant_id];
                if (p0 && actualMoveDist >= 1) {
                    const dt = (now - (this.lastUpdateTimes[location.participant_id] || now)) / 1000;
                    if (dt >= 1) {
                        const raw = (actualMoveDist / dt) * 3.6;
                        if (raw >= 3 && raw < 200) movementSpeed = Math.round(raw * 10) / 10;
                    }
                }
            }
        } else if (!first && prev && actualMoveDist < CONFIG.MOVEMENT_THRESHOLD) {
            if (this.markers[location.participant_id]) {
                const marker = this.markers[location.participant_id];
                marker.setLatLng(cur);

                if (!location.isSingleUpdate && this.speedHistory?.[location.participant_id]?.length > 0) {
                    const last = this.speedHistory[location.participant_id].slice(-1)[0];
                    const t = now - (this.lastSignificantMove[location.participant_id] || 0);
                    if (t < 5000) {
                        movementSpeed = last;
                        speedReliable = false;
                    } else {
                        movementSpeed = 0;
                        this.speedHistory[location.participant_id] = [];
                    }
                }

                marker.setIcon(this.createCustomMarker(name, color, isBackground, stayMinutes, isInCluster, clusterSize, 0, isOffline, movementSpeed, speedReliable));
                marker.bindPopup(this.createPopupContent(location, name, color, stayMinutes, isBackground, isInCluster, clusterSize, movementSpeed, speedReliable));

                if (this.directionIndicators[location.participant_id]) {
                    this.map.removeLayer(this.directionIndicators[location.participant_id]);
                    delete this.directionIndicators[location.participant_id];
                }

                if (!isOffline && location.status === 'sharing' && !clusterInfo && !isInCluster) {
                    const circleColor = isBackground ? '#6c757d' : color;
                    if (location.isSingleUpdate) {
                        this.stopRegularAnimation(location.participant_id);
                        if (this.accuracyCircles[location.participant_id]) {
                            this.map.removeLayer(this.accuracyCircles[location.participant_id]);
                            delete this.accuracyCircles[location.participant_id];
                        }
                        if (this.animationCircles[location.participant_id]) {
                            this.map.removeLayer(this.animationCircles[location.participant_id]);
                            delete this.animationCircles[location.participant_id];
                        }
                        this.updateAccuracyCircle(location.participant_id, actualLat, actualLng, location.accuracy, circleColor);
                    } else {
                        if (this.accuracyCircles[location.participant_id]) {
                            this.map.removeLayer(this.accuracyCircles[location.participant_id]);
                            delete this.accuracyCircles[location.participant_id];
                        }
                        this.updateAccuracyCircle(location.participant_id, actualLat, actualLng, location.accuracy, circleColor);
                    }
                } else {
                    this.stopRegularAnimation(location.participant_id);
                    if (this.accuracyCircles[location.participant_id]) {
                        this.map.removeLayer(this.accuracyCircles[location.participant_id]);
                        delete this.accuracyCircles[location.participant_id];
                    }
                    if (this.animationCircles[location.participant_id]) {
                        this.map.removeLayer(this.animationCircles[location.participant_id]);
                        delete this.animationCircles[location.participant_id];
                    }
                }

                this.previousPositions[location.participant_id] = cur;
                if (!this.originalPositions) this.originalPositions = {};
                this.originalPositions[location.participant_id] = [location.latitude, location.longitude];
            }
            return;
        }

        if (!location.isSingleUpdate && this.speedHistory?.[location.participant_id]?.length > 0) {
            const last = this.speedHistory[location.participant_id].slice(-1)[0];
            const t = now - (this.lastSignificantMove[location.participant_id] || 0);
            if (t < 10000) {
                movementSpeed = last;
                speedReliable = false;
            }
        }

        if (location.isSingleUpdate && location.is_online && location.status === 'sharing' && !clusterInfo && !isInCluster && !isBackground) {
            this.positionHistory[location.participant_id].push(entry);
            const cut = now - 10000;
            this.positionHistory[location.participant_id] = this.positionHistory[location.participant_id].filter(e => e.time > cut);
            const hist = this.positionHistory[location.participant_id];
            let stationary = first;
            if (!first) {
                const t2 = now - 2000;
                const recent = hist.filter(e => e.time > t2);
                if (recent.length >= 2) {
                    const a = recent[0],
                        b = recent[recent.length - 1];
                    const d = this.calculateDistance(a.position[0], a.position[1], b.position[0], b.position[1]);
                    if (d < 3) {
                        stationary = true;
                        if (this.directionIndicators[location.participant_id]) {
                            this.map.removeLayer(this.directionIndicators[location.participant_id]);
                            delete this.directionIndicators[location.participant_id];
                        }
                    }
                }
            }
            if (!first && prev && !stationary && actualMoveDist >= CONFIG.MOVEMENT_THRESHOLD) {
                this.lastSignificantMove[location.participant_id] = now;
                isMoving = true;
            } else {
                isMoving = false;
                if (this.directionIndicators[location.participant_id]) {
                    this.map.removeLayer(this.directionIndicators[location.participant_id]);
                    delete this.directionIndicators[location.participant_id];
                }
            }
            if (!stationary && hist.length >= 2 && isMoving) {
                const a = hist[0],
                    b = hist[hist.length - 1];
                const d = this.calculateDistance(a.position[0], a.position[1], b.position[0], b.position[1]);
                const dt = (b.time - a.time) / 1000;
                if (dt >= 2 && d >= 2) {
                    const raw = (d / dt) * 3.6;
                    const avgAcc = (a.accuracy + b.accuracy) / 2;
                    const accF = Math.max(0.5, Math.min(1, 50 / avgAcc));
                    if (raw < 200 && raw >= 0.5) {
                        let v = raw * accF;
                        speedReliable = dt >= 5 && avgAcc <= 50;
                        if (!this.speedHistory[location.participant_id]) this.speedHistory[location.participant_id] = [];
                        this.speedHistory[location.participant_id].push(v);
                        if (this.speedHistory[location.participant_id].length > 3) this.speedHistory[location.participant_id].shift();
                        const avg = this.speedHistory[location.participant_id].reduce((a, b) => a + b, 0) / this.speedHistory[location.participant_id].length;
                        movementSpeed = Math.round(avg * 10) / 10;
                    }
                }
            }
            if (stationary || !isMoving) {
                const t = now - (this.lastSignificantMove[location.participant_id] || 0);
                if (t > 5000) {
                    movementSpeed = 0;
                    speedReliable = false;
                    isMoving = false;
                    if (this.speedHistory[location.participant_id]) this.speedHistory[location.participant_id] = [];
                } else if (this.speedHistory[location.participant_id]?.length > 0) {
                    movementSpeed = this.speedHistory[location.participant_id].slice(-1)[0];
                    speedReliable = false;
                    isMoving = false;
                }
                this.startMovementStopTimer(location.participant_id);
            } else this.clearMovementStopTimer(location.participant_id);
            this.lastUpdateTimes[location.participant_id] = now;
        } else if (!location.is_online || location.status !== 'sharing' || isOffline) {
            if (this.positionHistory[location.participant_id]) this.positionHistory[location.participant_id] = [];
            if (this.speedHistory[location.participant_id]) this.speedHistory[location.participant_id] = [];
            if (this.lastSignificantMove[location.participant_id]) delete this.lastSignificantMove[location.participant_id];
            isMoving = false;
            this.clearMovementStopTimer(location.participant_id);
        }

        const popup = this.createPopupContent(location, name, color, stayMinutes, isBackground, isInCluster, clusterSize, isMoving ? movementSpeed : 0, speedReliable);

        if (this.markers[location.participant_id]) {
            const marker = this.markers[location.participant_id];
            if (clusterInfo || isInCluster) {
                marker.setLatLng(cur);
                this.stopMovementAnimation(location.participant_id);
                if (this.directionIndicators[location.participant_id]) {
                    if (this.map.hasLayer(this.directionIndicators[location.participant_id])) this.map.removeLayer(this.directionIndicators[location.participant_id]);
                    delete this.directionIndicators[location.participant_id];
                }
            } else if (!first && prev && !isOffline && isMoving && actualMoveDist >= CONFIG.MOVEMENT_THRESHOLD) {
                const bearing = this.calculateBearing(prev[0], prev[1], cur[0], cur[1]);
                this.animateMarkerMovement(location.participant_id, marker, prev, cur, bearing, color, true);
            } else {
                marker.setLatLng(cur);
                if (this.directionIndicators[location.participant_id]) {
                    this.map.removeLayer(this.directionIndicators[location.participant_id]);
                    delete this.directionIndicators[location.participant_id];
                }
                this.stopMovementAnimation(location.participant_id);
            }
            marker.setIcon(this.createCustomMarker(name, color, isBackground, stayMinutes, isInCluster, clusterSize, 0, isOffline, isMoving ? movementSpeed : 0, speedReliable));
            marker.bindPopup(popup);
            if (state.followingParticipantId === location.participant_id) {
                this.map.panTo(cur);
            }
        } else {
            const icon = this.createCustomMarker(name, color, isBackground, stayMinutes, isInCluster, clusterSize, 0, isOffline, isMoving ? movementSpeed : 0, speedReliable);
            const marker = L.marker(cur, {
                icon,
                pane: this.PANES.marker
            }).addTo(this.map).bindPopup(popup);
            if (!isOffline) {
                marker.on('click', () => {
                    state.followingParticipantId = location.participant_id;
                    const ll = marker.getLatLng();
                    const desired = this.getPreferredZoom(location.participant_id);
                    const next = Math.max(this.map.getZoom(), desired);
                    this.map.setView([ll.lat, ll.lng], next);
                });
            }
            this.markers[location.participant_id] = marker;
            this.lastUpdateTimes[location.participant_id] = now;
            this.lastSignificantMove[location.participant_id] = now;
            isMoving = false;
        }

        this.previousPositions[location.participant_id] = cur;
        if (!this.originalPositions) this.originalPositions = {};
        this.originalPositions[location.participant_id] = [location.latitude, location.longitude];

        // 円
        if (location.status === 'sharing' && !clusterInfo && !isInCluster && !isOffline) {
            const circleColor = isBackground ? '#6c757d' : color;
            if (location.isSingleUpdate) {
                const isNowMoving = isMoving && actualMoveDist >= CONFIG.MOVEMENT_THRESHOLD;
                if (isNowMoving) {
                    this.stopRegularAnimation(location.participant_id);
                    if (this.accuracyCircles[location.participant_id]) {
                        this.map.removeLayer(this.accuracyCircles[location.participant_id]);
                        delete this.accuracyCircles[location.participant_id];
                    }
                    this.updateAccuracyCircle(location.participant_id, actualLat, actualLng, location.accuracy, circleColor);
                    this.createRippleAnimation(location.participant_id, actualLat, actualLng, circleColor, location.accuracy);
                } else {
                    this.stopRegularAnimation(location.participant_id);
                    if (!this.accuracyCircles[location.participant_id]) {
                        this.updateAccuracyCircle(location.participant_id, actualLat, actualLng, location.accuracy, circleColor);
                    } else {
                        this.accuracyCircles[location.participant_id].setLatLng([actualLat, actualLng]);
                    }
                }
            } else {
                if (!this.accuracyCircles[location.participant_id]) {
                    this.updateAccuracyCircle(location.participant_id, actualLat, actualLng, location.accuracy, circleColor);
                } else {
                    this.accuracyCircles[location.participant_id].setLatLng([actualLat, actualLng]);
                    this.accuracyCircles[location.participant_id].setStyle({
                        color: circleColor,
                        fillColor: circleColor
                    });
                }
            }
        } else {
            this.stopRegularAnimation(location.participant_id);
            if (this.accuracyCircles[location.participant_id]) {
                this.map.removeLayer(this.accuracyCircles[location.participant_id]);
                delete this.accuracyCircles[location.participant_id];
            }
            if (this.animationCircles[location.participant_id]) {
                this.map.removeLayer(this.animationCircles[location.participant_id]);
                delete this.animationCircles[location.participant_id];
            }
        }
    }

    // === 移動停止タイマー ===
    startMovementStopTimer(id) {
        this.clearMovementStopTimer(id);
        if (!this.directionIndicators[id]) return;
        this.movementStopTimers[id] = {
            startTime: Date.now(),
            stopped: true
        };
    }
    clearMovementStopTimer(id) {
        if (!this.movementStopTimers) return;
        if (this.movementStopTimers[id]) delete this.movementStopTimers[id];
    }

    // === マーカー移動アニメーション（方向は即時更新、Paneで順序固定） ===
    animateMarkerMovement(pid, marker, fromPos, toPos, bearing, color, isMoving = false) {
        const participant = state.participantsData.find(p => p.participant_id === pid);
        if (participant && participant.isInCluster) {
            marker.setLatLng(toPos);
            return;
        }

        const dist = this.calculateDistance(fromPos[0], fromPos[1], toPos[0], toPos[1]);
        if (dist < 2) {
            marker.setLatLng(toPos);
            if (isMoving) {
                if (!this.directionIndicators[pid]) this.createDirectionIndicator(pid, toPos, bearing, color);
                else {
                    const ind = this.directionIndicators[pid];
                    ind.setLatLng(toPos);
                    const el = ind.getElement();
                    if (el) {
                        const r = el.querySelector('.arrow-rotation-container');
                        if (r) {
                            r.style.transition = 'none';
                            r.style.transform = `rotate(${bearing}deg)`;
                        }
                    }
                }
            }
            return;
        }
        if (this.movementTrackers[pid]) cancelAnimationFrame(this.movementTrackers[pid].animationId);
        if (isMoving && !this.directionIndicators[pid]) this.createDirectionIndicator(pid, fromPos, bearing, color);

        const duration = 1000,
            start = Date.now();
        const animate = () => {
            const t = Date.now() - start,
                p = Math.min(t / duration, 1),
                e = 1 - Math.pow(1 - p, 3);
            const lat = fromPos[0] + (toPos[0] - fromPos[0]) * e,
                lng = fromPos[1] + (toPos[1] - fromPos[1]) * e;
            marker.setLatLng([lat, lng]);
            if (isMoving && this.directionIndicators[pid]) {
                const ind = this.directionIndicators[pid];
                ind.setLatLng([lat, lng]);
                const el = ind.getElement();
                if (el) {
                    const r = el.querySelector('.arrow-rotation-container');
                    if (r) {
                        r.style.transition = 'none';
                        r.style.transform = `rotate(${bearing}deg)`;
                    }
                }
            }
            if (p < 1) {
                this.movementTrackers[pid] = {
                    animationId: requestAnimationFrame(animate),
                    isMoving
                };
            } else {
                if (!isMoving && this.movementStopTimers[pid]) this.stopMovementAnimation(pid);
            }
        };
        this.movementTrackers[pid] = {
            animationId: requestAnimationFrame(animate),
            isMoving
        };
    }

    // === 方向表示（Pane: directionPane に配置 → マーカーより下） ===
    createDirectionIndicator(pid, position, bearing, colorOrOptions) {
        // === 色決定：基本は青、60km/h を超えたら赤（明示color優先） ===
        const speed = (locationManager?.smoothedSpeed ?? 0);
        const speedKmh = speed * 3.6;
        const autoColor = (speedKmh > 60) ? '#ff4444' : '#007bff';
        const explicitColor =
            (typeof colorOrOptions === 'string') ? colorOrOptions :
            (colorOrOptions && colorOrOptions.color) ? colorOrOptions.color :
            null;
        const fillColor = explicitColor || autoColor;

        // === CSSを一度だけ注入 ===
        if (!document.getElementById('direction-fairy-style')) {
            const style = document.createElement('style');
            style.id = 'direction-fairy-style';
            style.textContent = `
        /* --- Direction "fairy light" styles --- */
        .direction-fairy .fairy-core{
        background: radial-gradient(circle, rgba(255,255,255,.95) 0%, currentColor 45%, rgba(255,255,255,0) 72%);
        border-radius: 999px;
        box-shadow:
            0 0 6px currentColor,
            0 0 12px currentColor,
            0 0 24px currentColor,
            0 0 32px rgba(255,255,255,.35);
        animation: fairyPulse 1.6s ease-in-out infinite, fairyFlicker 2.2s ease-in-out infinite;
        will-change: transform, filter, opacity;
        }

        .direction-fairy .fairy-trail{
        background: linear-gradient(to bottom, currentColor 0%, rgba(0,0,0,0) 100%);
        border-radius: 999px;
        filter: blur(0.6px);
        opacity: .85;
        animation: trailWave 1.8s ease-in-out infinite;
        will-change: transform, opacity;
        }

        @keyframes fairyPulse{
        0%,100% { transform: scale(1);   opacity: .95; }
        50%     { transform: scale(1.24); opacity: 1;   }
        }

        @keyframes fairyFlicker{
        0%,100% { filter: drop-shadow(0 0 4px currentColor) drop-shadow(0 0 10px currentColor); }
        50%     { filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 16px currentColor); }
        }

        @keyframes trailWave{
        0%,100% { opacity: .85; transform: translateX(-50%) scaleY(1); }
        50%     { opacity: .60; transform: translateX(-50%) scaleY(.86); }
        }
        `.trim();
            document.head.appendChild(style);
        }

        // === 既存インジケータ（位置・向き・色）更新 ===
        if (this.directionIndicators[pid]) {
            const ind = this.directionIndicators[pid];
            ind.setLatLng(position);
            const el = ind.getElement();
            if (el) {
                const r = el.querySelector('.arrow-rotation-container');
                if (r) {
                    r.style.transition = 'none';
                    r.style.transform = `rotate(${bearing}deg)`;
                    r.style.color = fillColor; // currentColor で全体の色を反映
                }
            }
            return;
        }

        // === 表示サイズは固定（停止時サイズ） ===
        const wrapSize = 90; // ラッパ
        const circleSize = 70; // 方向円
        const border = 2; // 方向円の線幅

        // “妖精の光”パーツの寸法
        const coreSize = 14; // 発光コア
        const tailWidth = 8; // 尻尾の幅
        const tailLen = 22; // 尻尾の長さ

        // さらに外周寄りに（marginを小さく）
        const margin = -4; // px: 外周との余白（0〜1で微調整）

        // 方向円の内側・外周寄りに配置（bearing 0°で上方向、回転で方位追従）
        const radius = (circleSize / 2) - border - (coreSize / 2) - margin; // 中心からの距離を最大寄りに
        const topPx = (wrapSize / 2) - radius - (coreSize / 2);

        const html = `
    <div class="direction-indicator-wrapper direction-fairy"
         style="position:relative;width:${wrapSize}px;height:${wrapSize}px;display:flex;align-items:center;justify-content:center;pointer-events:none;">
      <!-- 方向円 -->
      <div style="position:absolute;width:${circleSize}px;height:${circleSize}px;border:${border}px solid white;border-radius:50%;
                  opacity:.9;box-shadow:0 0 10px rgba(0,0,0,.2);"></div>

      <!-- bearingで回転（currentColorで色が決まる） -->
      <div class="arrow-rotation-container"
           style="position:absolute;width:100%;height:100%;transform:rotate(${bearing}deg);
                  transform-origin:center center;will-change:transform;color:${fillColor};">
        <!-- 妖精の光（外周寄り） -->
        <div class="fairy"
             style="position:absolute;left:50%;top:${topPx}px;width:${coreSize}px;height:${coreSize}px;transform:translateX(-50%);">
          <!-- 尻尾（中心側へ伸びる） -->
          <div class="fairy-trail"
               style="position:absolute;left:50%;top:${coreSize/2}px;width:${tailWidth}px;height:${tailLen}px;transform:translateX(-50%);"></div>
          <!-- 発光コア -->
          <div class="fairy-core"
               style="position:absolute;left:0;top:0;width:100%;height:100%;"></div>
        </div>
      </div>
    </div>`;

        const icon = L.divIcon({
            html,
            className: 'direction-indicator direction-fairy',
            iconSize: [wrapSize, wrapSize],
            iconAnchor: [45, 65]
        });

        const m = L.marker(position, {
            icon,
            interactive: false,
            pane: this.PANES.direction
        });
        m.addTo(this.map);
        this.directionIndicators[pid] = m;
    }

    // === 停止 ===
    stopMovementAnimation(id) {
        if (this.movementTrackers?.[id]) {
            if (this.movementTrackers[id].animationId) cancelAnimationFrame(this.movementTrackers[id].animationId);
            delete this.movementTrackers[id];
        }
        this.clearMovementStopTimer(id);
    }

    // === ポップアップ/ナビ/マーカー見た目（既存ロジック・Pane無関係） ===
    createPopupContent(location, name, color, stay, isBG, isInCluster = false, clusterSize = 1, spd = 0, rel = false) {
        const d = document.createElement('div');
        const nameDiv = document.createElement('div');
        nameDiv.style.color = color;
        nameDiv.style.fontWeight = 'bold';
        if (location.isOffline || !location.is_online || location.status === 'stopped') nameDiv.innerHTML = `${name} <span style="color:#dc3545;font-size:12px;">[オフライン]</span>`;
        else nameDiv.textContent = name;
        d.appendChild(nameDiv);

        if (isInCluster && clusterSize > 1 && location.is_online) {
            const c = document.createElement('div');
            c.style.color = '#dc3545';
            c.style.fontWeight = 'bold';
            c.style.fontSize = '12px';
            c.innerHTML = '<i class="fas fa-users"></i> 近くにメンバーがいます';
            d.appendChild(c);
        }

        const timeDiv = document.createElement('div');
        if (location.isOffline || !location.is_online || location.status === 'stopped') {
            const t = location.last_seen_at || location.last_updated;
            if (t) {
                const dt = new Date(t);
                const diff = Math.floor((Date.now() - dt) / 60000);
                if (diff < 60) timeDiv.innerHTML = `<span style="color:#dc3545;">最終確認: ${diff}分前</span>`;
                else if (diff < 1440) timeDiv.innerHTML = `<span style="color:#dc3545;">最終確認: ${Math.floor(diff/60)}時間前</span>`;
                else timeDiv.innerHTML = `<span style="color:#dc3545;">最終確認: ${Math.floor(diff/1440)}日前</span>`;
            } else timeDiv.innerHTML = '<span style="color:#dc3545;">最終確認: 不明</span>';
        } else if (isBG) {
            const m = this.markers[location.participant_id];
            const fixed = m?.backgroundTimestamp || location.background_entered_at || location.last_updated;
            timeDiv.textContent = `バックグラウンドに移行: ${new Date(fixed).toLocaleTimeString()}`;
        } else {
            timeDiv.textContent = `最終更新: ${new Date(location.last_updated).toLocaleTimeString()}`;
        }
        d.appendChild(timeDiv);

        const acc = document.createElement('div');
        let txt = '';
        if (location.isOffline || !location.is_online || location.status === 'stopped') {
            txt = 'オフライン（最後の位置）';
            acc.style.color = '#dc3545';
            acc.style.fontStyle = 'italic';
        } else if (location.status === 'waiting') {
            txt = location.participant_id === state.participantId ? '位置共有を開始してください' : '位置共有待ち';
        } else if (!location.accuracy || location.accuracy <= 0) {
            txt = '精度: 不明';
        } else if (location.accuracy > 1000) {
            txt = '精度: 低精度';
        } else {
            txt = `精度: ${Math.round(location.accuracy)}m`;
        }
        acc.textContent = txt;
        d.appendChild(acc);

        if (!location.isOffline && location.is_online && !isBG) {
            if (spd >= 3) {
                const s = document.createElement('div');
                s.style.color = '#2196F3';
                s.style.fontWeight = 'bold';
                const display = Math.round(spd);
                const t = (spd >= 40) ? `${display}km/h` : ((!rel && spd < 5) ? `${display}km/h` : `約${display}km/h`);
                s.textContent = `移動中 ${t}`;
                d.appendChild(s);
            } else if (stay >= 1) {
                const s = document.createElement('div');
                s.style.color = '#ff9800';
                s.style.fontWeight = 'bold';
                if (stay >= 60) {
                    const h = Math.floor(stay / 60),
                        m = stay % 60;
                    s.textContent = m > 0 ? `${h}時間${m}分滞在中` : `${h}時間滞在中`;
                } else s.textContent = `${stay}分滞在中`;
                d.appendChild(s);
            }
        }
        if (isBG && location.is_online && !location.isOffline) {
            const b = document.createElement('div');
            b.style.color = '#6c757d';
            b.style.fontStyle = 'italic';
            b.innerHTML = '<i class="fas fa-mobile-alt"></i> バックグラウンド';
            d.appendChild(b);
        }

        if (location.latitude != null && location.longitude != null && location.latitude !== 999.0 && location.longitude !== 999.0 && !isNaN(location.latitude) && !isNaN(location.longitude)) {
            const hr = document.createElement('div');
            hr.style.marginTop = '10px';
            hr.style.marginBottom = '5px';
            hr.style.borderTop = '1px solid #eee';
            d.appendChild(hr);
            const btn = document.createElement('button');
            btn.className = 'btn btn-primary btn-sm';
            btn.style.cssText = 'width:100%;margin-bottom:5px;display:flex;align-items:center;justify-content:center;gap:6px;font-size:13px;padding:6px 12px;border-radius:6px;transition:.2s;';
            btn.innerHTML = '<i class="fas fa-route"></i> Google Mapsで案内';
            btn.onclick = () => this.openGoogleMapsNavigation(location);
            btn.onmouseenter = () => {
                btn.style.transform = 'scale(1.02)';
                btn.style.boxShadow = '0 4px 12px rgba(0,123,255,.3)';
            };
            btn.onmouseleave = () => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            };
            d.appendChild(btn);
        }
        return d;
    }

    openGoogleMapsNavigation(location) {
        const lat = location.latitude,
            lng = location.longitude;
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=walking`;
        const opened = window.open(url, '_blank', 'noopener,noreferrer');
        if (opened) this.map.closePopup();
    }

    // === マーカー見た目 ===
    createCustomMarker(name, color, isBackground = false, stayMinutes = 0, isInCluster = false, clusterSize = 1, clusterIndex = 0, isOffline = false, movementSpeed = 0, speedReliable = false) {
        const initials = this.getInitials(name);

        let markerStyle = '';
        let backgroundIndicator = '';
        let clusterStyle = '';
        let clusterAnimation = '';

        if (isBackground) {
            markerStyle = `
            background-color: ${color};
            opacity: 0.7;
            position: relative;
        `;
            backgroundIndicator = `
            <div style="
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(108, 117, 125, 0.9);
                color: white;
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 8px;
                white-space: nowrap;
                font-weight: 500;
                border: 1px solid rgba(255, 255, 255, 0.3);
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                z-index: 1000;
            ">バックグラウンド</div>
        `;
        } else if (isInCluster && clusterSize > 1) {
            const hueRotation = (clusterIndex * 60) % 360;
            clusterStyle = `
            background: linear-gradient(45deg, ${color}, ${this.lightenColor(color, 20)});
            border: 3px solid transparent;
            background-clip: padding-box;
            box-shadow:
                0 0 20px rgba(${this.hexToRgb(color)}, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: visible;
        `;
            clusterAnimation = `animation: clusterGlow 2s infinite alternate;`;
            markerStyle = clusterStyle;
        } else {
            markerStyle = `
            background-color: ${color};
            position: relative;
        `;
        }

        let statusIndicator = '';
        if (!isBackground) {
            if (movementSpeed >= 3) {
                let speedIcon = '🚶';
                let bgGradient = 'linear-gradient(135deg, #4CAF50 0%, #66BB6A 100%)';
                let displaySpeed = Math.round(movementSpeed);

                if (movementSpeed >= 320) {
                    speedIcon = '🌟';
                    bgGradient = 'linear-gradient(135deg, #FFD700 0%, #FFA500 100%)';
                } else if (movementSpeed >= 300) {
                    speedIcon = '💫';
                    bgGradient = 'linear-gradient(135deg, #FF1493 0%, #FF69B4 100%)';
                } else if (movementSpeed >= 280) {
                    speedIcon = '☄️';
                    bgGradient = 'linear-gradient(135deg, #DC143C 0%, #FF6347 100%)';
                } else if (movementSpeed >= 260) {
                    speedIcon = '🔥';
                    bgGradient = 'linear-gradient(135deg, #FF4500 0%, #FF8C00 100%)';
                } else if (movementSpeed >= 240) {
                    speedIcon = '💥';
                    bgGradient = 'linear-gradient(135deg, #8B0000 0%, #CD5C5C 100%)';
                } else if (movementSpeed >= 220) {
                    speedIcon = '🎆';
                    bgGradient = 'linear-gradient(135deg, #4B0082 0%, #9370DB 100%)';
                } else if (movementSpeed >= 200) {
                    speedIcon = '⭐';
                    bgGradient = 'linear-gradient(135deg, #000080 0%, #4169E1 100%)';
                } else if (movementSpeed >= 180) {
                    speedIcon = '🎯';
                    bgGradient = 'linear-gradient(135deg, #2F4F4F 0%, #708090 100%)';
                } else if (movementSpeed >= 160) {
                    speedIcon = '🌀';
                    bgGradient = 'linear-gradient(135deg, #6a1ee5ff 0%, #8164f6ff 100%)';
                } else if (movementSpeed >= 140) {
                    speedIcon = '⚡';
                    bgGradient = 'linear-gradient(135deg, #e51e1eff 0%, #f69064ff 100%)';
                } else if (movementSpeed >= 120) {
                    speedIcon = '🚀';
                    bgGradient = 'linear-gradient(135deg, #dbb53aff 0%, #e1c64dff 100%)';
                } else if (movementSpeed >= 100) {
                    speedIcon = '🛸';
                    bgGradient = 'linear-gradient(135deg, #0a821eff 0%, #30c157ff 100%)';
                } else if (movementSpeed >= 80) {
                    speedIcon = '✈️';
                    bgGradient = 'linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%)';
                } else if (movementSpeed >= 60) {
                    speedIcon = '🚄';
                    bgGradient = 'linear-gradient(135deg, #363ff4ff 0%, #50afefff 100%)';
                } else if (movementSpeed >= 40) {
                    speedIcon = '🚗';
                    bgGradient = 'linear-gradient(135deg, #FF5722 0%, #FF7043 100%)';
                } else if (movementSpeed >= 20) {
                    speedIcon = '🚲';
                    bgGradient = 'linear-gradient(135deg, #1da037ff 0%, #22a616ff 100%)';
                } else if (movementSpeed >= 10) {
                    speedIcon = '🏃';
                    bgGradient = 'linear-gradient(135deg, #FFC107 0%, #FFD54F 100%)';
                }

                const speedText = (movementSpeed >= 40) ?
                    `${displaySpeed}km/h` :
                    ((!speedReliable && movementSpeed < 5) ? `約${displaySpeed}km/h` : `${displaySpeed}km/h`);

                statusIndicator = `
                <div style="
                    position: absolute;
                    top: -37px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: ${bgGradient};
                    color: white;
                    font-size: ${movementSpeed >= 60 ? '11px' : '10px'};
                    padding: 4px 8px;
                    border-radius: 12px;
                    white-space: nowrap;
                    font-weight: 600;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    z-index: 1001;
                    backdrop-filter: blur(10px);
                    animation: ${movementSpeed >= 60 ? 'speedPulseFast' : 'speedPulse'} 1.5s infinite ease-in-out;
                ">${speedIcon} ${speedText}</div>
            `;
            } else if (stayMinutes >= 1) {
                let stayText = '';
                if (stayMinutes >= 60) {
                    const hours = Math.floor(stayMinutes / 60);
                    const minutes = stayMinutes % 60;
                    stayText = minutes > 0 ? `⏰ ${hours}時間${minutes}分滞在` : `⏰ ${hours}時間滞在`;
                } else {
                    stayText = `⏰ ${stayMinutes}分滞在`;
                }
                statusIndicator = `
                <div style="
                    position: absolute;
                    top: -37px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
                    color: #333;
                    font-size: 10px;
                    padding: 4px 8px;
                    border-radius: 12px;
                    white-space: nowrap;
                    font-weight: 600;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                    z-index: 1001;
                    backdrop-filter: blur(10px);
                    animation: stayTimePulse 2s infinite ease-in-out;
                ">${stayText}</div>
            `;
            }
        }

        let clusterIndicator = '';
        if (isInCluster && clusterSize > 1) {
            clusterIndicator = `
            <div style="
                position: absolute;
                top: -8px;
                right: -8px;
                background: linear-gradient(135deg, #ff6b6b, #ee5a52);
                color: white;
                font-size: 10px;
                padding: 0;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                font-weight: bold;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 2px solid white;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
                z-index: 1002;
                animation: bounce 1s infinite;
            ">
                ${clusterSize}
            </div>
        `;
        }

        // キラキラ（元の動き復活）
        let sparkleEffect = '';
        if (isInCluster) {
            sparkleEffect = `
            <div class="sparkle-container" style="
                position: absolute;
                top: -6px; left: -6px; right: -6px; bottom: -6px;
                pointer-events: none;
                z-index: 999;
            ">
                <div class="sparkle" style="position:absolute; top:10%; left:18%;  animation: sparkle 1.5s infinite;">✨</div>
                <div class="sparkle" style="position:absolute; top:65%; right:10%; animation: sparkle 1.8s infinite 0.3s;">⭐</div>
                <div class="sparkle" style="position:absolute; bottom:15%; left:60%; animation: sparkle 1.2s infinite 0.6s;">💫</div>
            </div>
        `;
        }

        const markerHtml = `
        <div class="custom-marker" style="${markerStyle} ${clusterAnimation} transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform-style: preserve-3d;">
            ${initials}
            ${backgroundIndicator}
            ${statusIndicator}
            ${clusterIndicator}
            ${sparkleEffect}
        </div>
        <style>
            @keyframes speedPulse {
                0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.95; }
                50%      { transform: translateX(-50%) scale(1.05); opacity: 1; }
            }
            @keyframes speedPulseFast {
                0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.95; }
                50%      { transform: translateX(-50%) scale(1.08); opacity: 1; }
            }
            @keyframes stayTimePulse {
                0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.9; }
                50%      { transform: translateX(-50%) scale(1.05); opacity: 1; }
            }
            @keyframes clusterGlow {
                0%   { box-shadow: 0 0 20px rgba(${this.hexToRgb(color)}, 0.6), inset 0 0 20px rgba(255, 255, 255, 0.1); }
                100% { box-shadow: 0 0 30px rgba(${this.hexToRgb(color)}, 0.9), inset 0 0 25px rgba(255, 255, 255, 0.2); }
            }
            @keyframes bounce {
                0%, 100% { transform: scale(1); }
                50%      { transform: scale(1.1); }
            }
            @keyframes sparkle {
                0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
                50%      { opacity: 1; transform: scale(1) rotate(180deg); }
            }
        </style>
    `;

        return L.divIcon({
            html: markerHtml,
            className: 'custom-div-icon',
            iconSize: [40, 40],
            iconAnchor: [20, 45],
            popupAnchor: [0, -40]
        });
    }

    // === 精度円 ===
    updateAccuracyCircle(pid, lat, lng, acc, color) {
        if (this.accuracyCircles[pid]) {
            this.map.removeLayer(this.accuracyCircles[pid]);
            delete this.accuracyCircles[pid];
        }
        if (!acc || acc <= 0 || acc > 1000) return;

        const clusterInfo = this.getCurrentClusterInfo(pid);
        let aLat = lat,
            aLng = lng;
        if (clusterInfo) {
            const sorted = [...clusterInfo.participants].sort((a, b) => a.participant_id.localeCompare(b.participant_id));
            const idx = sorted.findIndex(p => p.participant_id === pid);
            if (idx !== -1) {
                const ang = 2 * Math.PI * idx / sorted.length,
                    r = CONFIG.CLUSTER_OFFSET_RADIUS;
                aLat = clusterInfo.clusterCenter.lat + (r * 0.00001) * Math.cos(ang);
                aLng = clusterInfo.clusterCenter.lng + (r * 0.00001) * Math.sin(ang);
            }
        }
        this.accuracyCircles[pid] = L.circle([aLat, aLng], {
            radius: acc,
            color,
            fillColor: color,
            fillOpacity: .18,
            opacity: .5,
            weight: 2,
            interactive: false,
            bubblingMouseEvents: false,
            pane: this.PANES.accuracy
        }).addTo(this.map);
    }

    // === リップル（1回） ===
    createRippleAnimation(pid, lat, lng, color, acc) {
        this.stopRegularAnimation(pid);
        if (this.animationCircles[pid]) {
            this.map.removeLayer(this.animationCircles[pid]);
            delete this.animationCircles[pid];
        }

        const clusterInfo = this.getCurrentClusterInfo(pid);
        let aLat = lat,
            aLng = lng;
        if (clusterInfo) {
            const sorted = [...clusterInfo.participants].sort((a, b) => a.participant_id.localeCompare(b.participant_id));
            const idx = sorted.findIndex(p => p.participant_id === pid);
            if (idx !== -1) {
                const ang = 2 * Math.PI * idx / sorted.length,
                    r = CONFIG.CLUSTER_OFFSET_RADIUS;
                aLat = clusterInfo.clusterCenter.lat + (r * 0.00001) * Math.cos(ang);
                aLng = clusterInfo.clusterCenter.lng + (r * 0.00001) * Math.sin(ang);
            }
        }
        const maxR = (!acc || acc <= 0 || acc > 1000) ? 50 : acc;
        const c = L.circle([aLat, aLng], {
            radius: 8,
            color,
            fillColor: color,
            fillOpacity: .3,
            opacity: .8,
            weight: 3,
            interactive: false,
            bubblingMouseEvents: false,
            pane: this.PANES.accuracy
        }).addTo(this.map);
        this.animationCircles[pid] = c;

        const duration = 1500,
            start = Date.now(),
            r0 = 8;
        if (this.rippleAnimationFrames?.[pid]) {
            cancelAnimationFrame(this.rippleAnimationFrames[pid]);
            delete this.rippleAnimationFrames[pid];
        }
        if (!this.rippleAnimationFrames) this.rippleAnimationFrames = {};
        const step = () => {
            const t = Date.now() - start,
                p = t / duration;
            if (p >= 1) {
                c.setRadius(maxR);
                c.setStyle({
                    opacity: .2,
                    fillOpacity: .05,
                    weight: 2
                });
                delete this.rippleAnimationFrames[pid];
                return;
            }
            const e = 1 - Math.pow(1 - p, 3),
                r = r0 + (maxR - r0) * e,
                op = .8 * (1 - p * .75),
                fop = .3 * (1 - p * .83);
            c.setRadius(r);
            c.setStyle({
                opacity: op,
                fillOpacity: fop,
                weight: Math.max(2, 3 * (1 - p * .33))
            });
            this.rippleAnimationFrames[pid] = requestAnimationFrame(step);
        };
        this.rippleAnimationFrames[pid] = requestAnimationFrame(step);
    }
    stopRegularAnimation(pid) {
        if (this.animationCircles[pid]) {
            if (this.map.hasLayer(this.animationCircles[pid])) this.map.removeLayer(this.animationCircles[pid]);
            delete this.animationCircles[pid];
        }
        if (this.rippleAnimationFrames?.[pid]) {
            cancelAnimationFrame(this.rippleAnimationFrames[pid]);
            delete this.rippleAnimationFrames[pid];
        }
    }

    // === 全体オートフィット ===
    resetAutoFit() {
        state.userInteracted = false;
        state.autoFitEnabled = true;
        state.followingParticipantId = null;
        if (state.followingGroup) {
            state.followingGroup = null;
            this.stopGroupFollowingTimer();
        }
        const layers = [...Object.values(this.markers), ...Object.values(this.accuracyCircles)].filter(Boolean);
        if (layers.length > 0) {
            if (Object.keys(this.markers).length === 1) {
                const m = Object.values(this.markers)[0];
                const ll = m.getLatLng();
                this.map.setView([ll.lat, ll.lng], 15);
            } else {
                const g = new L.featureGroup(layers);
                const b = g.getBounds();
                if (b.isValid()) this.map.fitBounds(b.pad(0.1));
            }
        }
    }

    // === 単一更新の薄いラッパ ===
    updateSingleMarkerOnly(location) {
        if (!this.mapInitialized) {
            console.warn('マップ未初期化');
            return;
        }
        const ok = location.latitude !== null && location.longitude !== null && location.latitude !== 999.0 && location.longitude !== 999.0 && !isNaN(location.latitude) && !isNaN(location.longitude);
        if (!ok) {
            this.removeMarker(location.participant_id);
            return;
        }
        const clusterInfo = this.getCurrentClusterInfo(location.participant_id);
        const isOffline = location.is_online === false || location.status === 'stopped';
        const markerLocation = {
            ...location,
            isOffline,
            isInCluster: !!clusterInfo,
            clusterSize: clusterInfo ? clusterInfo.participants.length : 1,
            isSingleUpdate: true
        };
        this.updateSingleMarker(markerLocation);
    }

    // === 色/ラベル ===
    lightenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16),
            amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt,
            G = (num >> 8 & 0x00FF) + amt,
            B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }
    hexToRgb(hex) {
        const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return r ? `${parseInt(r[1],16)}, ${parseInt(r[2],16)}, ${parseInt(r[3],16)}` : '255, 107, 107';
    }
    getInitials(name) {
        if (!name) return 'UN';
        const n = name.substring(0, 30);
        return n.substring(0, 2).toUpperCase();
    }
    getParticipantColor(id) {
        if (!state.participantColors[id]) state.participantColors[id] = this.getDeterministicColor(id);
        return state.participantColors[id];
    }
    getDeterministicColor(id) {
        let hash = 0;
        for (let i = 0; i < id.length; i++) {
            const c = id.charCodeAt(i);
            hash = ((hash << 5) - hash) + c;
            hash = hash & hash;
        }
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#FFB6C1', '#20B2AA', '#FF69B4', '#32CD32', '#FF4500', '#8A2BE2', '#DC143C', '#00CED1', '#FFD700', '#FF1493', '#00FA9A', '#1E90FF', '#FF8C00', '#9370DB', '#3CB371', '#BA55D3', '#FF6347', '#4682B4', '#D2691E', '#6A5ACD', '#FF7F50', '#40E0D0', '#EE82EE', '#F0E68C', '#B22222', '#5F9EA0', '#FF00FF', '#00FF7F', '#FFA500', '#4169E1', '#FA8072', '#00BFFF', '#F4A460', '#9932CC', '#FF00BF', '#2E8B57', '#FF5FA2', '#00D9FF', '#B8FF00', '#FF3E96', '#00E5FF', '#FFE600', '#6B00FF', '#FF9E00'];
        return colors[Math.abs(hash) % colors.length];
    }
}

// === 参加者管理クラス ===
class ParticipantManager {
    // === 参加者一覧を更新 ===
    updateList(locations) {
        if (!ui?.elements?.participantsList) return;

        // ★ 修正：自分が退出中の場合は参加者リスト更新をスキップ
        if (state.isLeaving) {
            return;
        }

        if (!Array.isArray(locations) || locations.length === 0) {
            const emptyHtml = '<div class="text-center text-muted">参加者がいません</div>';
            if (ui.currentParticipantsHtml !== emptyHtml) {
                ui.elements.participantsList.innerHTML = emptyHtml;
                ui.currentParticipantsHtml = emptyHtml;
            }
            return;
        }

        // ★ 修正：自分を除外した参加者リストを作成（退出中の場合）
        const filteredLocations = state.isLeaving ?
            locations.filter(l => l.participant_id !== state.participantId) :
            locations;

        // 重複参加者を処理
        const processedLocations = this.removeDuplicateParticipants(filteredLocations);

        // 新規参加者を順序リストに追加
        processedLocations.forEach(location => {
            if (!state.participantOrder.includes(location.participant_id)) {
                state.participantOrder.push(location.participant_id);
            }
        });

        // 退出した参加者を順序リストから削除
        state.participantOrder = state.participantOrder.filter(id =>
            processedLocations.some(location => location.participant_id === id)
        );

        state.participantsData = processedLocations;
        this.updateDisplay();
    }

    // === ：重複参加者を除去するメソッド ===
    removeDuplicateParticipants(locations) {
        const nameGroups = new Map();

        // 参加者名でグループ化
        locations.forEach(location => {
            const name = (location.participant_name || '').trim().toLowerCase();
            if (!name) return; // 名前が空の場合はスキップ
            if (!nameGroups.has(name)) {
                nameGroups.set(name, []);
            }
            nameGroups.get(name).push(location);
        });

        const processedLocations = [];
        const removedParticipantIds = [];

        // 各名前グループを処理
        nameGroups.forEach(group => {
            if (group.length === 1) {
                // 重複なし
                processedLocations.push(group[0]);
                return;
            }

            // 重複あり - オンラインの参加者を優先
            // 自分が含まれている場合は自分を最優先
            const selfParticipant = group.find(p => p.participant_id === state.participantId);
            if (selfParticipant) {
                processedLocations.push(selfParticipant);
                group
                    .filter(p => p.participant_id !== state.participantId)
                    .forEach(p => removedParticipantIds.push(p.participant_id));
                return;
            }

            // 自分以外の場合は、オンライン > 共有中 > 最新更新 の順で優先
            const sortedGroup = group.sort((a, b) => {
                // オンライン状態で比較
                if (a.is_online !== b.is_online) {
                    return b.is_online ? 1 : -1;
                }
                // 共有状態で比較
                if (a.status !== b.status) {
                    return b.status === 'sharing' ? 1 : -1;
                }
                // 最新更新時刻で比較
                return new Date(b.last_updated) - new Date(a.last_updated);
            });

            // 最優先の参加者を採用
            processedLocations.push(sortedGroup[0]);
            sortedGroup.slice(1).forEach(p => removedParticipantIds.push(p.participant_id));
        });

        // 名前が空の参加者も追加（重複チェック対象外）
        locations
            .filter(location => !(location.participant_name || '').trim())
            .forEach(location => processedLocations.push(location));

        // 除去された参加者のマーカーとデータをクリーンアップ
        if (removedParticipantIds.length > 0) {
            this.cleanupRemovedParticipants(removedParticipantIds);

            // サーバーに削除通知を送信
            this.notifyServerOfRemovedDuplicates(removedParticipantIds);

            // ★ ：削除された参加者の通知を抑制
            this.suppressNotificationsForRemovedParticipants(removedParticipantIds);
        }

        return processedLocations;
    }

    // ★ ：削除された参加者の通知を抑制するメソッド
    suppressNotificationsForRemovedParticipants(removedParticipantIds) {
        // 削除された参加者を前回状態からも除去（通知が表示されないようにする）
        removedParticipantIds.forEach(participantId => {
            if (state.previousParticipantsState.has(participantId)) {
                state.previousParticipantsState.delete(participantId);
            }
        });

        // 削除された参加者への参加通知も取り消し（必要なら通知する実装をコメントアウトで保持）
        // if (removedParticipantIds.length > 0) {
        //     ui.showNotification(
        //         `${removedParticipantIds.length}人の重複参加者を整理しました`,
        //         'info',
        //         'fas fa-users-cog',
        //         false // サイレント通知（控えめに表示）
        //     );
        // }
    }

    // === ★ ：サーバーに重複削除を通知 ===
    notifyServerOfRemovedDuplicates(removedParticipantIds) {
        if (!wsManager?.websocket || wsManager.websocket.readyState !== WebSocket.OPEN) {
            console.warn('WebSocket未接続のため重複削除通知をスキップ');
            return;
        }

        const duplicateRemovalData = {
            type: 'duplicate_participants_removed',
            removed_participant_ids: removedParticipantIds,
            reporter_participant_id: state.participantId,
            timestamp: new Date().toISOString(),
            session_id: state.sessionId,
            cleanup_request: true // サーバー側でも削除処理を要求
        };

        const sent = wsManager.send(duplicateRemovalData);
        if (sent) {
            // 送信成功時の追加処理があればここに
        } else {
            console.warn('重複削除通知の送信に失敗');
        }
    }

    // === ：除去された参加者のクリーンアップ（強化版） ===
    cleanupRemovedParticipants(removedParticipantIds) {
        removedParticipantIds.forEach(participantId => {
            // 1. マーカーとマップ要素を削除
            if (mapManager?.markers?.[participantId]) {
                mapManager.removeMarker(participantId);
            }

            // 2. 参加者順序から削除
            const orderIndex = state.participantOrder.indexOf(participantId);
            if (orderIndex !== -1) {
                state.participantOrder.splice(orderIndex, 1);
            }

            // 3. 参加者色設定から削除
            if (state.participantColors?.[participantId]) {
                delete state.participantColors[participantId];
            }

            // 4. 以前の状態履歴から削除
            if (state.previousParticipantsState.has(participantId)) {
                state.previousParticipantsState.delete(participantId);
            }

            // 5. 追従設定から削除
            if (state.followingParticipantId === participantId) {
                state.followingParticipantId = null;
                mapManager?.resetAutoFit?.();
            }

            // 6. グループ追従から除外
            if (state.followingGroup && state.followingGroup.includes(participantId)) {
                state.followingGroup = state.followingGroup.filter(id => id !== participantId);
                if (state.followingGroup.length === 0) {
                    state.followingGroup = null;
                    mapManager?.stopGroupFollowingTimer?.();
                }
            }

            // 7. ★ participantsData から完全除去
            state.participantsData = state.participantsData.filter(p => p.participant_id !== participantId);

            // 8. ★ アニメーション関連のクリーンアップ
            if (mapManager?.regularAnimationIntervals?.[participantId]) {
                clearInterval(mapManager.regularAnimationIntervals[participantId]);
                delete mapManager.regularAnimationIntervals[participantId];
            }

            // 9. ★ クラスター関連のクリーンアップ
            if (mapManager?.clusterConnections) {
                Object.keys(mapManager.clusterConnections).forEach(clusterId => {
                    if (clusterId.includes(participantId)) {
                        if (mapManager.clusterConnections[clusterId]) {
                            mapManager.map?.removeLayer?.(mapManager.clusterConnections[clusterId]);
                        }
                        delete mapManager.clusterConnections[clusterId];
                    }
                });
            }

            // 10. ★ パルスアニメーションのクリーンアップ
            if (mapManager?.pulseAnimations) {
                Object.keys(mapManager.pulseAnimations).forEach(pulseId => {
                    if (pulseId.includes(participantId)) {
                        const pa = mapManager.pulseAnimations[pulseId];
                        if (pa?.interval) clearInterval(pa.interval);
                        if (pa?.circle) mapManager.map?.removeLayer?.(pa.circle);
                        delete mapManager.pulseAnimations[pulseId];
                    }
                });
            }
        });

        // ★ 状態を保存して永続化
        state.save?.();
    }

    // === 表示更新（順序に沿って描画 + スクロールUI） ===
    updateDisplay() {
        if (!ui?.elements?.participantsList || !Array.isArray(state.participantsData) || state.participantsData.length === 0) return;

        const listEl = ui.elements.participantsList;
        listEl.innerHTML = '';

        const sortedLocations = state.participantOrder
            .map(id => state.participantsData.find(loc => loc.participant_id === id))
            .filter(Boolean);

        sortedLocations.forEach(location => {
            const participantDiv = this.createParticipantElement(location);
            // data-participant-id属性を設定
            participantDiv.dataset.participantId = location.participant_id;
            listEl.appendChild(participantDiv);
        });

        // スクロールインジケーターを追加（5人以上の場合）
        if (sortedLocations.length > 5) {
            const indicator = document.createElement('div');
            indicator.className = 'scroll-indicator';
            indicator.innerHTML = `
            <i class="fas fa-chevron-down" style="animation: bounce 1s infinite;"></i>
            <br>
            <small>${sortedLocations.length}人の参加者</small>
        `;
            listEl.appendChild(indicator);

            // ★ 変更点：一番上にいる時だけ表示、それ以外は非表示
            const checkTop = () => {
                const isAtTop = listEl.scrollTop <= 0; // 先頭かどうか
                if (isAtTop) {
                    indicator.classList.add('show'); // ← ずっと表示でOK（トップにいる間は消さない）
                } else {
                    indicator.classList.remove('show');
                }
            };
            listEl.addEventListener('scroll', checkTop, {
                passive: true
            });
            // 初期チェック（描画直後のスクロール位置に応じて表示）
            setTimeout(checkTop, 0);
        }
    }



    // === 参加者管理クラス - createParticipantElement メソッド（統合版） ===
    createParticipantElement(location) {
        const isMe = location.participant_id === state.participantId;
        const isFollowing = state.followingParticipantId === location.participant_id;
        const lastUpdated = new Date(location.last_updated);
        const timeDiff = Math.floor((new Date() - lastUpdated) / 1000);

        const canShowFollowing =
            isFollowing &&
            location.is_online &&
            location.status === 'sharing' &&
            location.latitude !== null &&
            location.longitude !== null;

        const {
            statusClass,
            statusText
        } = this.getParticipantStatus(location, isMe, timeDiff);
        const color = mapManager.getParticipantColor(location.participant_id);
        const originalName = location.participant_name || `参加者${location.participant_id.substring(0, 4)}`;
        const name = originalName.substring(0, 30);

        const participantDiv = document.createElement('div');
        participantDiv.className = `participant-item ${canShowFollowing ? 'following-participant' : ''}`;

        // ★ 重要：data-participant-id属性を設定
        participantDiv.dataset.participantId = location.participant_id;

        const statusDot = document.createElement('div');
        statusDot.className = `status-dot ${statusClass}`;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'flex-grow-1';

        const nameStrong = document.createElement('strong');
        nameStrong.style.color = color;
        nameStrong.textContent = name;
        contentDiv.appendChild(nameStrong);

        if (isMe) {
            const selfBadge = document.createElement('span');
            selfBadge.className = 'badge bg-primary ms-1';
            selfBadge.textContent = '自分';
            contentDiv.appendChild(selfBadge);
        }

        if (canShowFollowing) {
            const followingBadge = document.createElement('span');
            followingBadge.className = 'badge bg-info ms-1';
            followingBadge.innerHTML = '<i class="fas fa-crosshairs"></i> 追従中';
            contentDiv.appendChild(followingBadge);
        }

        contentDiv.appendChild(document.createElement('br'));

        const statusSmall = document.createElement('small');
        statusSmall.className = 'text-muted';
        statusSmall.textContent = statusText;
        contentDiv.appendChild(statusSmall);

        // === 精度表示の追加 ===
        if (
            location.status === 'sharing' &&
            location.is_online &&
            location.latitude !== null &&
            location.longitude !== null
        ) {
            contentDiv.appendChild(document.createElement('br'));

            const accuracySpan = document.createElement('small');
            accuracySpan.className = 'text-muted';

            let accuracyText = '';
            let accuracyClass = '';

            if (!location.accuracy || location.accuracy <= 0) {
                accuracyText = '精度: 不明';
                accuracyClass = 'text-secondary';
            } else if (location.accuracy <= 20) {
                accuracyText = `精度: ${Math.round(location.accuracy)}m (高精度)`;
                accuracyClass = 'text-success';
            } else if (location.accuracy <= 50) {
                accuracyText = `精度: ${Math.round(location.accuracy)}m (中精度)`;
                accuracyClass = 'text-warning';
            } else if (location.accuracy <= 200) {
                accuracyText = `精度: ${Math.round(location.accuracy)}m (低精度)`;
                accuracyClass = 'text-danger';
            } else {
                accuracyText = `精度: ${Math.round(location.accuracy)}m (非常に低い)`;
                accuracyClass = 'text-danger';
            }

            accuracySpan.innerHTML = `<i class="fas fa-bullseye me-1"></i>${accuracyText}`;
            accuracySpan.className = `${accuracyClass} fw-bold`;
            contentDiv.appendChild(accuracySpan);

            // 精度アイコンの色も変更
            const icon = accuracySpan.querySelector('i');
            if (icon) {
                icon.className = `fas fa-bullseye me-1 ${accuracyClass}`;
            }
        }

        participantDiv.appendChild(statusDot);
        participantDiv.appendChild(contentDiv);

        return participantDiv;
    }

    // === 状態表示テキストとクラスの決定 ===
    getParticipantStatus(location, isMe, timeDiff) {
        const hasValidLocation =
            location.latitude !== null &&
            location.longitude !== null &&
            location.latitude !== 999.0 &&
            location.longitude !== 999.0 &&
            !isNaN(location.latitude) &&
            !isNaN(location.longitude);

        // バックグラウンド状態の判定を最初に行う
        if (location.is_background && location.status === 'sharing' && hasValidLocation) {
            return {
                statusClass: 'status-background',
                statusText: 'バックグラウンド'
            };
        }

        // 未共有（waiting）状態の判定
        if (location.status === 'waiting') {
            // 最終更新からの経過時間をチェック
            const lastSeenTime = location.last_seen_at || location.last_updated;
            if (lastSeenTime) {
                const lastSeenDate = new Date(lastSeenTime);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastSeenDate) / (1000 * 60));

                // 5分以上更新がない場合は接続確認中と表示
                if (diffMinutes >= 5) {
                    return {
                        statusClass: 'status-waiting',
                        statusText: isMe ? '接続確認中...' : `参加中（最終接続${diffMinutes}分前）`
                    };
                }
            }

            return {
                statusClass: 'status-waiting',
                statusText: isMe ? '共有待機中' : '参加中（未共有）'
            };
        }

        // 共有中（オンライン）状態
        if (location.status === 'sharing' && hasValidLocation && !location.is_background) {
            return {
                statusClass: 'status-online',
                statusText: 'オンライン'
            };
        }

        // デフォルト（状態不明）
        return {
            statusClass: 'status-waiting',
            statusText: isMe ? '状態確認中' : '状態不明'
        };
    }

    // ★ ：外部から呼び出し可能な重複処理メソッド
    processLocationsForDuplicates(locations) {
        // 退出中の場合は自分を除外
        const filteredLocations = state.isLeaving ?
            locations.filter(location => location.participant_id !== state.participantId) :
            locations;

        // 重複参加者を処理
        return this.removeDuplicateParticipants(filteredLocations);
    }

    // ★ ：処理済みデータでリストを更新するメソッド
    updateListAfterProcessing(processedLocations) {
        if (!ui?.elements?.participantsList) return;

        if (!processedLocations || processedLocations.length === 0) {
            const emptyHtml = '<div class="text-center text-muted">参加者がいません</div>';
            if (ui.currentParticipantsHtml !== emptyHtml) {
                ui.elements.participantsList.innerHTML = emptyHtml;
                ui.currentParticipantsHtml = emptyHtml;
            }
            return;
        }

        // 新規参加者を順序リストに追加
        processedLocations.forEach(location => {
            if (!state.participantOrder.includes(location.participant_id)) {
                state.participantOrder.push(location.participant_id);
            }
        });

        // 退出した参加者を順序リストから削除
        state.participantOrder = state.participantOrder.filter(id =>
            processedLocations.some(location => location.participant_id === id)
        );

        state.participantsData = processedLocations;
        this.updateDisplay();
    }

    // === 単一参加者表示の差し替え/追加 ===
    updateSingleParticipant(participantData) {
        console.log('=== 単一参加者リスト更新 ===');

        if (!ui?.elements?.participantsList) return;

        // 既存の参加者要素を検索（セレクタを使用）
        const existingElement = ui.elements.participantsList.querySelector(
            `[data-participant-id="${participantData.participant_id}"]`
        );

        if (existingElement) {
            // 既存要素を置き換え
            const newElement = this.createParticipantElement(participantData);
            newElement.dataset.participantId = participantData.participant_id;
            existingElement.replaceWith(newElement);
        } else {
            // 新規参加者の場合は追加
            const newElement = this.createParticipantElement(participantData);
            newElement.dataset.participantId = participantData.participant_id;
            ui.elements.participantsList.appendChild(newElement);
        }
    }
}

// === チャット管理クラス（リファクタ版）===
class ChatManager {
    // ---- 定数/汎用 ----
    static C = {
        MOBILE_MAX_W: 768,
        TEXTAREA_MIN_H: 40,
        TEXTAREA_MAX_H: 120,
        NEWMSG_INDENT: 50,
        PENDING_CLEAN_MS: 60000,
        HISTORY_TIMEOUT_MS: 10000,
        AUTO_READ_MS: 300,
        RAPID_STATUS_MS: 1000,
        STATUS_MS: 2000,
        TYPING_PING_MS: 10000,
        TYPING_CHECK_MS: 500,
        IMAGE_MAX_BYTES: 50 * 1024 * 1024,
        IMAGE_MAX_W: 1920,
        IMAGE_MAX_H: 1920,
        IMAGE_THUMB_W: 300,
        IMAGE_THUMB_H: 300,
        IMAGE_QUALITY: 0.9,
        IMAGE_THUMB_QUALITY: 0.7,
        IMAGE_PENDING_TIMEOUT_MS: 90000
    };

    constructor() {
        // 状態
        this.currentChatTarget = null;
        this.messages = {
            group: [],
            individual: {}
        };
        this.unreadCounts = {
            group: 0,
            individual: {}
        };
        this.messageReadStatus = {
            group: {},
            individual: {}
        };
        this.readByInfo = {
            group: {},
            individual: {}
        };
        this.typingStates = {};
        this.typingCheckIntervals = {};
        this.typingTimeouts = {};
        this.pendingMessages = new Map();
        this.pendingTimeouts = {};
        this.messageIdCounter = 0;
        this.isTransitioning = false;
        this.lastTapTime = 0;
        this.scrollPosition = 0;
        this.messagesLoading = false;
        this.loadingTimeout = null;
        this.isScrolling = false;
        this._onViewportResizeBound = null;
        this.autoReadInterval = null;
        this.participantStatusInterval = null;
        this.rapidStatusInterval = null;

        // 端末
        this.isMobile = (() => {
            try {
                const touch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const narrow = window.matchMedia && window.matchMedia(`(max-width:${ChatManager.C.MOBILE_MAX_W}px)`).matches;
                return touch && narrow;
            } catch {
                return false;
            }
        })();

        // 画像ビューア
        this.currentZoom = 1;
        this.minZoom = 0.5;
        this.maxZoom = 5;
        this.zoomStep = 0.25;
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.imageX = 0;
        this.imageY = 0;
        this.touches = new Map();
        this.lastDistance = 0;
        this.baseZoom = 1;
        this.viewingImage = null;
        this.pendingImage = null;

        // 許可MIME
        this.ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

        // イベント管理
        this._wmHandlers = new WeakMap();

        // 初期化
        this.initElements();
        this.startStatusUpdateTimer();
        this.loadMessages();

        // モーダル外クリック閉じ
        this.chatModal?.addEventListener('click', (e) => {
            if (e.target === this.chatModal) this.closeChat();
        });

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) this.cleanupPendingMessages();
        });
        window.addEventListener('online', () => {
            setTimeout(() => this.cleanupPendingMessages(), 2000);
        });
    }

    // ---- イベント集約 ----
    _on(el, type, handler, opts) {
        if (!el) return;
        el.addEventListener(type, handler, opts);
        const arr = this._wmHandlers.get(el) || [];
        arr.push({
            type,
            handler,
            opts
        });
        this._wmHandlers.set(el, arr);
    }
    _off(el) {
        const arr = this._wmHandlers.get(el);
        if (arr) {
            arr.forEach(({
                type,
                handler,
                opts
            }) => el.removeEventListener(type, handler, opts));
            this._wmHandlers.delete(el);
        }
    }
    _qs(sel, root = document) {
        return root.querySelector(sel);
    }
    _qsa(sel, root = document) {
        return Array.from(root.querySelectorAll(sel));
    }

    // ---- 初期化 ----
    initElements() {
        this.chatButton = this._qs('#chat-button');
        this.chatBadge = this._qs('#chat-badge');
        this.chatModal = this._qs('#chat-modal');

        // ボタン
        this._on(this.chatButton, 'click', () => this.openChat());
        this._qsa('.close-btn').forEach(btn => {
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.closeChat();
            };
            this._on(btn, 'touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.closeChat();
            }, {
                passive: false
            });
            this._on(btn, 'click', handler);
        });

        // hover style（既存維持）
        if (!document.getElementById('chat-hover-fix-styles')) {
            const styleSheet = document.createElement('style');
            styleSheet.id = 'chat-hover-fix-styles';
            styleSheet.textContent = `
            .chat-participant-item{transition:none!important;background:#fff;border-left:3px solid transparent}
            .chat-participant-item.group:hover{background:rgba(0,179,0,.05)!important;transition:none!important}
            .chat-participant-item:not(.group):hover{border-left:3px solid #9c27b0!important;background:rgba(156,39,176,.05)!important;transition:none!important}
            .chat-participant-item:not(:hover){background:#fff!important;border-left:3px solid transparent!important;transition:none!important}
            .chat-participant-item:active{opacity:.8}
            .chat-participant-item{pointer-events:auto;cursor:pointer}
            @media(hover:none){.chat-participant-item:hover{background:#fff!important;border-left:3px solid transparent!important}.chat-participant-item:active{background:#f0f0f0!important}}`;
            document.head.appendChild(styleSheet);
        }
        // mouseover/out（既存維持）
        this._on(document, 'mouseover', (e) => {
            const item = e.target.closest('.chat-participant-item');
            if (item) item.classList.add('hover-state');
        });
        this._on(document, 'mouseout', (e) => {
            const item = e.target.closest('.chat-participant-item');
            if (item) item.classList.remove('hover-state');
        });

        // 画像選択
        const groupImageInput = this._qs('#group-image-input');
        const individualImageInput = this._qs('#individual-image-input');
        if (groupImageInput) this._on(groupImageInput, 'change', (e) => this.handleImageSelection(e, 'group'));
        if (individualImageInput) this._on(individualImageInput, 'change', (e) => this.handleImageSelection(e, 'individual'));
        this.createImagePreviewModal();

        // 入力中表示
        const groupInput = this._qs('#group-input');
        const individualInput = this._qs('#individual-input');
        if (groupInput) {
            this._on(groupInput, 'input', () => this.handleTypingStart('group', groupInput));
            this._on(groupInput, 'blur', () => this.handleTypingEnd('group'));
        }
        if (individualInput) {
            this._on(individualInput, 'input', () => {
                if (this.currentChatTarget) this.handleTypingStart(this.currentChatTarget, individualInput);
            });
            this._on(individualInput, 'blur', () => {
                if (this.currentChatTarget) this.handleTypingEnd(this.currentChatTarget);
            });
        }

        // テキストエリア統合
        this.setupTextarea('#group-input', 'group');
        this.setupTextarea('#individual-input', 'individual');

        // iOSズーム抑止
        this._qsa('.chat-input, #participant-name').forEach(input => {
            this._on(input, 'focus', (e) => {
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    e.preventDefault();
                    e.target.style.fontSize = '16px';
                    setTimeout(() => {
                        try {
                            e.target.setSelectionRange(e.target.value.length, e.target.value.length);
                        } catch {}
                    }, 0);
                }
            });
            let lastTouchEnd = 0;
            this._on(input, 'touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            });
        });
    }

    // ---- テキストエリア集約 ----
    setupTextarea(sel, chatType) {
        const input = this._qs(sel);
        if (!input) return;
        const S = ChatManager.C;
        Object.assign(input.style, {
            minHeight: `${S.TEXTAREA_MIN_H}px`,
            maxHeight: `${S.TEXTAREA_MAX_H}px`,
            overflowY: 'auto',
            overflowX: 'hidden',
            resize: 'none',
            lineHeight: '1.5',
            webkitOverflowScrolling: 'touch',
            whiteSpace: 'pre-wrap',
            wordWrap: 'break-word',
            wordBreak: 'break-word'
        });
        if (!document.getElementById('textarea-scrollbar-hide-style')) {
            const st = document.createElement('style');
            st.id = 'textarea-scrollbar-hide-style';
            st.textContent = `${sel}::-webkit-scrollbar{display:none} #group-input::-webkit-scrollbar{display:none} #individual-input::-webkit-scrollbar{display:none}`;
            document.head.appendChild(st);
        }
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        let isComposing = false;
        const adjustHeight = () => {
            const containerId = chatType === 'group' ? 'group-messages' : 'individual-messages';
            const mc = this._qs(`#${containerId}`);
            let wasAtBottom = false;
            if (mc) wasAtBottom = mc.scrollHeight - mc.scrollTop - mc.clientHeight < 50;

            if (!input.value) {
                input.style.height = `${S.TEXTAREA_MIN_H}px`;
                input.style.overflowY = 'hidden';
            } else {
                const keep = input.scrollTop;
                input.style.height = `${S.TEXTAREA_MIN_H}px`;
                const h = input.scrollHeight;
                if (h > S.TEXTAREA_MAX_H) {
                    input.style.height = `${S.TEXTAREA_MAX_H}px`;
                    input.style.overflowY = 'auto';
                    setTimeout(() => {
                        input.scrollTop = keep;
                    }, 0);
                } else if (h > S.TEXTAREA_MIN_H) {
                    input.style.height = `${h}px`;
                    input.style.overflowY = 'hidden';
                } else {
                    input.style.height = `${S.TEXTAREA_MIN_H}px`;
                    input.style.overflowY = 'hidden';
                }
            }
            if (wasAtBottom && mc) requestAnimationFrame(() => {
                mc.scrollTop = mc.scrollHeight;
            });
        };
        if (isAndroid) {
            let touchStartY = 0,
                lastTouchY = 0,
                isTextareaTouching = false;
            this._on(input, 'touchstart', (e) => {
                const can = input.scrollHeight > input.clientHeight;
                if (can) {
                    touchStartY = e.touches[0].pageY;
                    lastTouchY = touchStartY;
                    isTextareaTouching = true;
                }
            }, {
                passive: true
            });
            this._on(input, 'touchmove', (e) => {
                if (!isTextareaTouching) return;
                const can = input.scrollHeight > input.clientHeight;
                if (!can) return;
                const t = e.touches[0],
                    cur = t.pageY,
                    dy = lastTouchY - cur;
                const newTop = input.scrollTop + dy,
                    max = input.scrollHeight - input.clientHeight;
                if (newTop >= 0 && newTop <= max) {
                    input.scrollTop = newTop;
                    lastTouchY = cur;
                    e.preventDefault();
                    e.stopPropagation();
                } else if (newTop < 0) {
                    input.scrollTop = 0;
                    if (dy < 0) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                } else {
                    input.scrollTop = max;
                    if (dy > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }, {
                passive: false
            });
            this._on(input, 'touchend', () => {
                isTextareaTouching = false;
            }, {
                passive: true
            });
            ['#group-messages', '#individual-messages'].forEach(id => {
                const c = this._qs(id);
                if (c) this._on(c, 'touchstart', () => {
                    isTextareaTouching = false;
                }, {
                    passive: true
                });
            });
        }
        this._on(input, 'compositionstart', () => {
            isComposing = true;
        });
        this._on(input, 'compositionend', () => {
            isComposing = false;
            adjustHeight();
        });
        this._on(input, 'compositionupdate', () => adjustHeight());
        ['input', 'change', 'keyup', 'paste', 'cut'].forEach(ev => this._on(input, ev, adjustHeight));
        this._on(input, 'focus', () => {
            if (!input.value) input.style.height = `${S.TEXTAREA_MIN_H}px`;
        });
        this._on(input, 'keydown', (e) => {
            if (isComposing) return;
            if (e.key === 'Enter') {
                if (!this.isMobile) {
                    if (e.shiftKey) {
                        setTimeout(adjustHeight, 0);
                        return;
                    }
                    e.preventDefault();
                    const t = input.value.trim();
                    if (!t) return;
                    (chatType === 'group') ? this.sendGroupMessage(): this.sendIndividualMessage();
                } else setTimeout(adjustHeight, 0);
            }
        });
        if (this.isMobile) {
            const btnId = chatType === 'group' ? '#group-send-btn' : '#individual-send-btn';
            const btn = this._qs(btnId);
            if (btn) this._on(btn, 'click', (e) => {
                e.preventDefault();
                const t = input.value.trim();
                if (!t) return;
                (chatType === 'group') ? this.sendGroupMessage(): this.sendIndividualMessage();
            });
        }
        input.style.height = `${ChatManager.C.TEXTAREA_MIN_H}px`;
    }

    // ---- Pending cleanup ----
    cleanupPendingMessages() {
        if (!this.pendingMessages || this.pendingMessages.size === 0) return;
        const now = Date.now();
        this.pendingMessages.forEach((msg, tempId) => {
            const msgTime = new Date(msg.timestamp).getTime();
            if (now - msgTime > ChatManager.C.PENDING_CLEAN_MS) {
                this.pendingMessages.delete(tempId);
                if (this.pendingTimeouts[tempId]) {
                    clearTimeout(this.pendingTimeouts[tempId]);
                    delete this.pendingTimeouts[tempId];
                }
            }
        });
    }

    // ---- 画像:選択/プレビュー/送信 ----
    selectImage(chatType) {
        this.pendingImage = null;
        const inputId = chatType === 'group' ? '#group-image-input' : '#individual-image-input';
        const input = this._qs(inputId);
        if (input) {
            input.value = '';
            input.click();
        }
    }
    async handleImageSelection(event, chatType) {
        const file = event.target.files?.[0];
        if (!file) return;
        if (!this.ALLOWED_IMAGE_TYPES.includes(file.type)) {
            this.showImageErrorModal('サポートされていない画像形式です', 'JPEG/PNG/GIF/WebP のみ対応');
            event.target.value = '';
            return;
        }
        if (file.size > ChatManager.C.IMAGE_MAX_BYTES) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(1),
                maxMB = (ChatManager.C.IMAGE_MAX_BYTES / 1024 / 1024).toFixed(0);
            this.showImageErrorModal('画像サイズが大きすぎます', `選択: ${sizeMB}MB<br>最大: ${maxMB}MB`);
            event.target.value = '';
            return;
        }
        try {
            this.pendingImage = null;
            const resized = await this.resizeImage(file, ChatManager.C.IMAGE_MAX_W, ChatManager.C.IMAGE_MAX_H, ChatManager.C.IMAGE_QUALITY);
            const thumb = await this.resizeImage(file, ChatManager.C.IMAGE_THUMB_W, ChatManager.C.IMAGE_THUMB_H, ChatManager.C.IMAGE_THUMB_QUALITY);
            this.showImagePreview(resized, thumb, file.type, chatType);
        } catch (err) {
            console.error(err);
            this.showImageErrorModal('画像の処理に失敗しました', err.message || '読み込みエラー');
            this.pendingImage = null;
        }
        event.target.value = '';
    }
    resizeImage(file, maxW, maxH, quality = 0.85) {
        return new Promise((resolve, reject) => {
            const fr = new FileReader();
            fr.onload = async (e) => {
                try {
                    const src = e.target.result;
                    const imgBitmap = await (window.createImageBitmap ?
                        createImageBitmap(await (await fetch(src)).blob()) :
                        new Promise((res, rej) => {
                            const img = new Image();
                            img.onload = () => res(img);
                            img.onerror = () => rej(new Error('画像の読み込みに失敗'));
                            img.src = src;
                        })
                    );
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    let {
                        width,
                        height
                    } = imgBitmap;
                    const ratio = Math.min(maxW / width, maxH / height, 1);
                    width = Math.floor(width * ratio);
                    height = Math.floor(height * ratio);
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(imgBitmap, 0, 0, width, height);
                    const outType = (file.type === 'image/jpeg' || file.type === 'image/webp') ? file.type : 'image/jpeg';
                    canvas.toBlob((blob) => {
                        if (!blob) return reject(new Error('画像の処理に失敗'));
                        const r = new FileReader();
                        r.onloadend = () => {
                            const base64 = r.result;
                            const approx = (base64.length * 3) / 4;
                            if (approx > ChatManager.C.IMAGE_MAX_BYTES) return reject(new Error('画像が大きすぎます'));
                            resolve(base64);
                        };
                        r.readAsDataURL(blob);
                    }, outType, quality);
                } catch (err) {
                    reject(err);
                }
            };
            fr.onerror = () => reject(new Error('ファイル読み込みに失敗'));
            fr.readAsDataURL(file);
        });
    }
    createImagePreviewModal() {
        if (document.getElementById('image-preview-modal')) return;
        const modal = document.createElement('div');
        modal.id = 'image-preview-modal';
        modal.className = 'image-preview-modal';
        modal.style.display = 'none';
        modal.innerHTML = `
        <div class="image-preview-container">
            <div class="image-preview-header"><h5>画像を送信</h5><button class="close-preview-btn" onclick="chatManager.closeImagePreview()">×</button></div>
            <div class="image-preview-body"><img id="preview-image" src="" alt="プレビュー"></div>
            <div class="image-preview-footer"><button class="btn btn-secondary" onclick="chatManager.closeImagePreview()">キャンセル</button><button class="btn btn-primary" onclick="chatManager.sendImageMessage()">送信</button></div>
        </div>`;
        document.body.appendChild(modal);
    }
    showImagePreview(imageData, thumbnailData, mimeType, chatType) {
        this.pendingImage = {
            data: imageData,
            thumbnail: thumbnailData,
            mimeType,
            chatType
        };
        const modal = this._qs('#image-preview-modal');
        const img = this._qs('#preview-image');
        img.src = imageData;
        modal.style.display = 'flex';
        document.addEventListener('touchmove', this.preventDefaultHandler, {
            passive: false
        });
    }
    closeImagePreview() {
        const modal = this._qs('#image-preview-modal');
        if (modal) modal.style.display = 'none';
        this.pendingImage = null;
        const img = this._qs('#preview-image');
        if (img) img.src = '';
        document.removeEventListener('touchmove', this.preventDefaultHandler);
    }
    sendImageMessage() {
        if (!this.pendingImage) return;
        const sendPack = {
            ...this.pendingImage
        };
        this.pendingImage = null;
        const {
            data,
            thumbnail,
            mimeType,
            chatType
        } = sendPack;
        const tempId = `temp_${++this.messageIdCounter}`;
        const message = {
            type: 'chat_message',
            chat_type: chatType,
            message_type: 'image',
            sender_id: state.participantId,
            sender_name: this.getParticipantNameSafe(),
            target_id: chatType === 'individual' ? this.currentChatTarget : null,
            image_data: data,
            image_thumbnail: thumbnail,
            image_mime_type: mimeType,
            timestamp: new Date().toISOString(),
            tempId,
            isPending: true
        };
        if (chatType === 'group') {
            this.messages.group.push(message);
            if (this._qs('#group-chat-screen')?.classList.contains('active')) this.appendNewMessage('group-messages', message);
        } else {
            const key = this.currentChatTarget;
            if (!this.messages.individual[key]) this.messages.individual[key] = [];
            this.messages.individual[key].push(message);
            const open = this._qs('#individual-chat-screen')?.classList.contains('active');
            if (this.currentChatTarget === key && open) this.appendNewMessage('individual-messages', message);
        }
        this.pendingMessages.set(tempId, message);
        const ok = wsManager.send(message);
        if (ok) {
            this.pendingTimeouts[tempId] = setTimeout(() => {
                if (this.pendingMessages.has(tempId)) {
                    const container = chatType === 'group' ? this._qs('#group-messages') : this._qs('#individual-messages');
                    if (container) {
                        const el = container.querySelector(`[data-temp-id="${tempId}"]`);
                        if (el && el.querySelector('.loading-overlay')) {
                            this.handleMessageSendError(tempId, chatType, chatType === 'individual' ? this.currentChatTarget : null,
                                '送信がタイムアウトしました。<br>接続をご確認ください。<br><br>※実際には送信されている可能性があります。ページを更新して確認してください。'
                            );
                        } else {
                            this.pendingMessages.delete(tempId);
                            if (this.pendingTimeouts[tempId]) {
                                clearTimeout(this.pendingTimeouts[tempId]);
                                delete this.pendingTimeouts[tempId];
                            }
                        }
                    }
                }
            }, ChatManager.C.IMAGE_PENDING_TIMEOUT_MS);
        } else {
            this.handleMessageSendError(tempId, chatType, chatType === 'individual' ? this.currentChatTarget : null, 'ネットワークエラー：接続を確認してください');
        }
        this.closeImagePreview();
    }

    // ---- 画像エラー簡易モーダル（既存準拠・簡略）----
    showImageErrorModal(title, message) {
        const id = 'image-error-modal',
            sid = 'image-error-modal-styles';
        this._qs(`#${id}`)?.remove();
        const modal = document.createElement('div');
        modal.id = id;
        modal.className = 'image-error-modal';
        modal.innerHTML = `<div class="image-error-overlay"></div><div class="image-error-container">
            <div class="image-error-icon"><i class="fas fa-exclamation-triangle"></i></div>
            <div class="image-error-content"><h4 class="image-error-title">${title}</h4><div class="image-error-message">${message}</div></div>
            <div class="image-error-actions"><button class="btn btn-primary" onclick="chatManager.closeImageErrorModal()"><i class="fas fa-check"></i> OK</button></div>
        </div>`;
        if (!document.getElementById(sid)) {
            const styles = document.createElement('style');
            styles.id = sid;
            styles.textContent = `
            .image-error-modal{position:fixed;inset:0;z-index:10000;display:flex;align-items:center;justify-content:center;animation:fadeIn .2s}
            .image-error-overlay{position:absolute;inset:0;background:rgba(0,0,0,.7);backdrop-filter:blur(5px)}
            .image-error-container{position:relative;background:#fff;border-radius:16px;padding:24px;max-width:400px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,.3);animation:slideUp .3s}
            .image-error-icon{text-align:center;margin-bottom:16px}.image-error-icon i{font-size:48px;color:#ff6b6b;animation:pulse 1.5s infinite}
            .image-error-title{text-align:center;color:#333;margin-bottom:12px;font-weight:600;font-size:18px}
            .image-error-message{text-align:center;color:#666;margin-bottom:20px;line-height:1.5;font-size:14px}
            .image-error-actions{text-align:center}.image-error-actions .btn{min-width:100px;padding:10px 20px;font-weight:500}
            @keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes slideUp{from{transform:translateY(20px);opacity:0}to{transform:translateY(0);opacity:1}}@keyframes pulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.05);opacity:.8}}
            @media(max-width:480px){.image-error-container{width:95%;padding:20px}.image-error-icon i{font-size:40px}.image-error-title{font-size:16px}.image-error-message{font-size:13px}}`;
            document.head.appendChild(styles);
        }
        document.body.appendChild(modal);
        const esc = (e) => {
            if (e.key === 'Escape') {
                this.closeImageErrorModal();
                document.removeEventListener('keydown', esc);
            }
        };
        document.addEventListener('keydown', esc);
        setTimeout(() => {
            modal.querySelector('.btn')?.focus();
        }, 100);
    }
    closeImageErrorModal() {
        const m = this._qs('#image-error-modal');
        if (m) {
            m.style.animation = 'fadeOut .2s';
            setTimeout(() => m.remove(), 200);
        }
    }

    // ---- ビューア ----
    createImageViewer() {
        if (this._qs('#image-viewer-modal')) return;
        const v = document.createElement('div');
        v.id = 'image-viewer-modal';
        v.className = 'image-viewer-modal';
        v.style.display = 'none';
        v.innerHTML = `
        <div class="image-viewer-overlay"></div>
        <div class="image-viewer-container">
            <div class="image-viewer-header">
                <button class="viewer-close-btn" onclick="chatManager.closeImageViewer()"><i class="fas fa-times"></i></button>
                <div class="viewer-title">画像ビューア</div>
                <div class="viewer-actions"><button class="viewer-action-btn" onclick="chatManager.downloadImage()" title="ダウンロード"><i class="fas fa-download"></i></button></div>
            </div>
            <div class="image-viewer-body">
                <div class="image-loading-spinner"><div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading...</span></div></div>
                <div class="image-wrapper" id="image-wrapper"><img id="viewer-image" src="" alt="表示画像"></div>
            </div>
            <div class="image-viewer-controls">
                <button class="zoom-btn" onclick="chatManager.zoomOut()" title="縮小"><i class="fas fa-search-minus"></i></button>
                <button class="zoom-btn" onclick="chatManager.resetZoom()" title="リセット"><i class="fas fa-compress-arrows-alt"></i></button>
                <button class="zoom-btn" onclick="chatManager.zoomIn()" title="拡大"><i class="fas fa-search-plus"></i></button>
                <div class="zoom-level-display">100%</div>
            </div>
        </div>`;
        document.body.appendChild(v);
        this.initImageViewerZoom();
    }
    initImageViewerZoom() {
        this.currentZoom = 1;
        this.minZoom = 0.5;
        this.maxZoom = 5;
        this.zoomStep = 0.25;
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.imageX = 0;
        this.imageY = 0;
        this.touches = new Map();
        this.lastDistance = 0;
        this.baseZoom = 1;
        const wrapper = this._qs('#image-wrapper');
        const image = this._qs('#viewer-image');
        if (!wrapper || !image) return;
        const rec = (t) => this.touches.set(t.identifier, {
            x: t.clientX,
            y: t.clientY
        });
        const dist = () => {
            if (this.touches.size !== 2) return 0;
            const a = [...this.touches.values()];
            const dx = a[1].x - a[0].x,
                dy = a[1].y - a[0].y;
            return Math.hypot(dx, dy);
        };
        this._on(wrapper, 'touchstart', (e) => {
            e.preventDefault();
            for (const t of e.touches) rec(t);
            if (e.touches.length === 2) {
                this.lastDistance = dist();
                this.baseZoom = this.currentZoom;
                this.isDragging = false;
            } else if (e.touches.length === 1) {
                if (this.currentZoom > 1) {
                    this.isDragging = true;
                    this.dragStartX = e.touches[0].clientX - this.imageX;
                    this.dragStartY = e.touches[0].clientY - this.imageY;
                }
            }
        }, {
            passive: false
        });
        this._on(wrapper, 'touchmove', (e) => {
            e.preventDefault();
            this.touches.clear();
            for (const t of e.touches) rec(t);
            if (e.touches.length === 2) {
                const cur = dist();
                if (this.lastDistance > 0) {
                    const scale = cur / this.lastDistance;
                    const nz = this.baseZoom * scale;
                    this.currentZoom = Math.max(this.minZoom, Math.min(this.maxZoom, nz));
                    this.updateImageTransform();
                    this.updateZoomDisplay();
                }
            } else if (e.touches.length === 1 && this.isDragging) {
                const t = e.touches[0];
                this.imageX = t.clientX - this.dragStartX;
                this.imageY = t.clientY - this.dragStartY;
                this.updateImageTransform();
            }
        }, {
            passive: false
        });
        this._on(wrapper, 'touchend', (e) => {
            e.preventDefault();
            for (const t of e.changedTouches) this.touches.delete(t.identifier);
            if (e.touches.length === 0) {
                this.isDragging = false;
                this.lastDistance = 0;
            } else if (e.touches.length === 1) {
                if (this.currentZoom > 1) {
                    this.isDragging = true;
                    const t = e.touches[0];
                    this.dragStartX = t.clientX - this.imageX;
                    this.dragStartY = t.clientY - this.imageY;
                }
                this.lastDistance = 0;
            } else if (e.touches.length === 2) {
                this.lastDistance = dist();
                this.baseZoom = this.currentZoom;
            }
        }, {
            passive: false
        });
        this._on(wrapper, 'touchcancel', (e) => {
            e.preventDefault();
            this.touches.clear();
            this.isDragging = false;
            this.lastDistance = 0;
        }, {
            passive: false
        });
        // ダブルタップ
        let lastTap = 0,
            tapCount = 0;
        this._on(wrapper, 'touchstart', (e) => {
            if (e.touches.length === 1) {
                const now = Date.now();
                if (now - lastTap < 300) {
                    tapCount++;
                    if (tapCount === 2) {
                        e.preventDefault();
                        this.currentZoom > 1 ? this.resetZoom() : this.setZoom(2);
                        tapCount = 0;
                    }
                } else tapCount = 1;
                lastTap = now;
            }
        });
        // ホイール/ドラッグ(PC)
        this._on(wrapper, 'wheel', (e) => {
            e.preventDefault();
            const d = e.deltaY > 0 ? -this.zoomStep : this.zoomStep;
            this.setZoom(this.currentZoom + d);
        }, {
            passive: false
        });
        let mdown = false;
        this._on(wrapper, 'mousedown', (e) => {
            if (this.currentZoom > 1) {
                mdown = true;
                this.isDragging = true;
                this.dragStartX = e.clientX - this.imageX;
                this.dragStartY = e.clientY - this.imageY;
                wrapper.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        this._on(document, 'mousemove', (e) => {
            if (mdown && this.isDragging) {
                e.preventDefault();
                this.imageX = e.clientX - this.dragStartX;
                this.imageY = e.clientY - this.dragStartY;
                this.updateImageTransform();
            }
        });
        this._on(document, 'mouseup', () => {
            if (mdown) {
                mdown = false;
                this.isDragging = false;
                const w = this._qs('#image-wrapper');
                if (w) w.style.cursor = this.currentZoom > 1 ? 'grab' : 'default';
            }
        });
        // transform
        this.updateImageTransform = () => {
            const img = this._qs('#viewer-image');
            if (img) {
                const t = `translate3d(${this.imageX}px,${this.imageY}px,0) scale3d(${this.currentZoom},${this.currentZoom},1)`;
                img.style.webkitTransform = t;
                img.style.transform = t;
            }
        };
    }
    setZoom(z) {
        this.currentZoom = Math.max(this.minZoom, Math.min(this.maxZoom, z));
        if (this.currentZoom === 1) {
            this.imageX = 0;
            this.imageY = 0;
        }
        this.updateImageTransform();
        this.updateZoomDisplay();
        const w = this._qs('#image-wrapper');
        if (w) w.style.cursor = this.currentZoom > 1 ? 'grab' : 'default';
    }
    updateImageTransform() {
        const img = this._qs('#viewer-image');
        if (img) img.style.transform = `translate(${this.imageX}px,${this.imageY}px) scale(${this.currentZoom})`;
    }
    updateZoomDisplay() {
        const d = this._qs('.zoom-level-display');
        if (d) d.textContent = `${Math.round(this.currentZoom*100)}%`;
    }
    zoomIn() {
        this.setZoom(this.currentZoom + this.zoomStep);
    }
    zoomOut() {
        this.setZoom(this.currentZoom - this.zoomStep);
    }
    resetZoom() {
        this.setZoom(1);
    }
    showImageViewer(imageData, mimeType) {
        if (!this._qs('#image-viewer-modal')) this.createImageViewer();
        this.viewingImage = {
            data: imageData,
            mimeType
        };
        const viewer = this._qs('#image-viewer-modal'),
            img = this._qs('#viewer-image'),
            spin = viewer.querySelector('.image-loading-spinner');
        this.currentZoom = 1;
        this.imageX = 0;
        this.imageY = 0;
        if (spin) spin.style.display = 'flex';
        img.onload = () => {
            if (spin) spin.style.display = 'none';
            this.updateImageTransform();
            this.updateZoomDisplay();
        };
        img.src = imageData;
        viewer.style.display = 'flex';
        document.addEventListener('touchmove', this.preventDefaultHandler, {
            passive: false
        });
    }
    closeImageViewer() {
        const v = this._qs('#image-viewer-modal');
        if (v) {
            v.style.display = 'none';
            const img = this._qs('#viewer-image');
            if (img) {
                img.src = '';
                img.style.transform = '';
            }
            this.currentZoom = 1;
            this.imageX = 0;
            this.imageY = 0;
            this.isDragging = false;
        }
        this.viewingImage = null;
        document.removeEventListener('touchmove', this.preventDefaultHandler);
    }
    preventDefaultHandler(e) {
        if (e.touches && e.touches.length > 1) e.preventDefault();
    }
    downloadImage() {
        if (!this.viewingImage) return;
        const a = document.createElement('a');
        a.href = this.viewingImage.data;
        a.download = `image_${Date.now()}.${this.viewingImage.mimeType.split('/')[1]}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // ---- 入力中 ----
    handleTypingStart(target, inputEl) {
        const has = inputEl.value.trim().length > 0;
        if (has && !this.typingStates[target]) {
            this.typingStates[target] = true;
            this.sendTypingIndicator(target, true);
            this.startTypingCheck(target, inputEl);
        }
        if (!has && this.typingStates[target]) this.handleTypingEnd(target);
    }
    handleTypingEnd(target) {
        if (this.typingStates[target]) {
            this.typingStates[target] = false;
            this.sendTypingIndicator(target, false);
            this.stopTypingCheck(target);
        }
    }
    startTypingCheck(target, inputEl) {
        this.stopTypingCheck(target);
        this.typingCheckIntervals[target] = setInterval(() => {
            const has = inputEl.value.trim().length > 0;
            if (!has && this.typingStates[target]) this.handleTypingEnd(target);
            else if (has && this.typingStates[target]) {
                const now = Date.now();
                const last = this.lastTypingSent?.[target] || 0;
                if (now - last > ChatManager.C.TYPING_PING_MS) {
                    this.sendTypingIndicator(target, true);
                    if (!this.lastTypingSent) this.lastTypingSent = {};
                    this.lastTypingSent[target] = now;
                }
            }
        }, ChatManager.C.TYPING_CHECK_MS);
    }
    stopTypingCheck(target) {
        if (this.typingCheckIntervals[target]) {
            clearInterval(this.typingCheckIntervals[target]);
            delete this.typingCheckIntervals[target];
        }
    }
    sendTypingIndicator(target, isTyping) {
        wsManager.send({
            type: 'typing_indicator',
            chat_type: (target === 'group' ? 'group' : 'individual'),
            target_id: target === 'group' ? null : target,
            sender_id: state.participantId,
            sender_name: this.getParticipantNameSafe(),
            is_typing: isTyping
        });
    // 送った瞬間を刻んでおく
    if (!this.lastTypingSent) this.lastTypingSent = {};
    this.lastTypingSent[target] = Date.now();
    }
    handleTypingIndicator(data) {
        if (data.sender_id === state.participantId) return;
        if (data.chat_type === 'group') {
            const ind = this._qs('#group-typing-indicator');
            if (!ind) return;
            if (data.is_typing) {
                ind.querySelector('span').textContent = data.sender_name;
                ind.style.display = 'block';
                if (this.typingTimeouts?.group) clearTimeout(this.typingTimeouts.group);
                if (!this.typingTimeouts) this.typingTimeouts = {};
                this.typingTimeouts.group = setTimeout(() => {
                    ind.style.display = 'none';
                }, 15000);
            } else {
                ind.style.display = 'none';
                if (this.typingTimeouts?.group) {
                    clearTimeout(this.typingTimeouts.group);
                    delete this.typingTimeouts.group;
                }
            }
        } else if (data.chat_type === 'individual' && data.target_id === state.participantId) {
            const ind = this._qs('#typing-indicator');
            if (!ind || this.currentChatTarget !== data.sender_id) return;
            if (data.is_typing) {
                ind.querySelector('span').textContent = data.sender_name;
                ind.style.display = 'block';
                if (this.typingTimeouts?.[data.sender_id]) clearTimeout(this.typingTimeouts[data.sender_id]);
                if (!this.typingTimeouts) this.typingTimeouts = {};
                this.typingTimeouts[data.sender_id] = setTimeout(() => {
                    ind.style.display = 'none';
                }, 15000);
            } else {
                ind.style.display = 'none';
                if (this.typingTimeouts?.[data.sender_id]) {
                    clearTimeout(this.typingTimeouts[data.sender_id]);
                    delete this.typingTimeouts[data.sender_id];
                }
            }
        }
    }

    // ---- 履歴/未読 ----
    loadMessages() {
        this.messages = {
            group: [],
            individual: {}
        };
        this.unreadCounts = {
            group: 0,
            individual: {}
        };
        this.messagesLoading = true;
        const tryReq = () => {
            if (wsManager?.websocket?.readyState === WebSocket.OPEN) {
                const pid = state.participantId || window.djangoData?.participantId;
                if (pid) {
                    this.loadingTimeout = setTimeout(() => {
                        this.messagesLoading = false;
                        console.warn('メッセージ履歴読み込みタイムアウト');
                    }, ChatManager.C.HISTORY_TIMEOUT_MS);
                    wsManager.send({
                        type: 'request_chat_history',
                        session_id: state.sessionId,
                        participant_id: pid
                    });
                } else {
                    console.error('Participant ID not available');
                    setTimeout(tryReq, 500);
                }
            } else setTimeout(tryReq, 500);
        };
        setTimeout(tryReq, 1000);
    }
    computeLocalDMUnread(pid, myId) {
        const arr = this.messages.individual[pid] || [];
        const tsObj = this.getLastReadTimestamps();
        const last = tsObj?.individual?.[pid] || 0;
        let c = 0;
        for (const m of arr) {
            if (m.message_type === 'system') continue;
            // 相手(pid) → 自分(myId)宛のみ対象
            if (m.sender_id === pid && m.target_id === myId) {
                const t = new Date(m.timestamp).getTime() || 0;
                // ★ 最終閲覧時刻以前のものは未読扱いしない
                if (t <= last) continue;
                const rb = m.read_by || [];
                if (!rb.includes(myId)) c++;
            }
        }
        return c;
    }

handleChatHistory(data) {
    if (!data.messages) return;
    this.messagesLoading = false;
    if (this.loadingTimeout) {
        clearTimeout(this.loadingTimeout);
        this.loadingTimeout = null;
    }

    // ★ 既存キャッシュを退避（上書きで消さない）
    const prevReadStatus = {
        group: Array.isArray(this.messages?.group)
            ? (this.messageReadStatus?.group || {})
            : {},
        individual: this.messageReadStatus?.individual
            ? JSON.parse(JSON.stringify(this.messageReadStatus.individual))
            : {}
    };

    // 初期化
    this.messages = { group: [], individual: {} };
    this.messageReadStatus = { group: {}, individual: {} };
    this.unreadCounts = { group: 0, individual: {} };
    if (!this.suppressedDMUnread) this.suppressedDMUnread = {}; // ★ 退出者用の未読退避

    const myId = state.participantId || window.djangoData?.participantId;
    const activeIds = new Set((state.participantsData || []).map(p => p.participant_id));

    // ---- メッセージ本体 ----
    // group
    if (Array.isArray(data.messages.group)) {
        this.messages.group = data.messages.group;
        this.messages.group.forEach((msg, i) => {
            // 優先度: サーバmsg.read_by > 旧キャッシュ > フォールバック([sender_id])
            if (Array.isArray(msg.read_by) && msg.read_by.length) {
                this.messageReadStatus.group[i] = msg.read_by;
            } else if (Array.isArray(prevReadStatus.group[i]) && prevReadStatus.group[i].length) {
                this.messageReadStatus.group[i] = prevReadStatus.group[i];
            } else {
                this.messageReadStatus.group[i] = [msg.sender_id];
            }
        });
    }

    // individual
    if (data.messages.individual) {
        Object.keys(data.messages.individual).forEach(pid => {
            this.messages.individual[pid] = data.messages.individual[pid];
            this.messageReadStatus.individual[pid] = {};
            this.messages.individual[pid].forEach((msg, i) => {
                if (Array.isArray(msg.read_by) && msg.read_by.length) {
                    this.messageReadStatus.individual[pid][i] = msg.read_by;
                } else if (Array.isArray(prevReadStatus.individual?.[pid]?.[i]) && prevReadStatus.individual[pid][i].length) {
                    this.messageReadStatus.individual[pid][i] = prevReadStatus.individual[pid][i];
                } else {
                    this.messageReadStatus.individual[pid][i] = [msg.sender_id];
                }
            });
        });
    }

    // ---- 未読（サーバ値を優先しつつ、退席者は退避） ----
    if (data.unread_counts) {
        this.unreadCounts.group = data.unread_counts.group || 0;
        this.unreadCounts.individual = { ...(data.unread_counts.individual || {}) };
    }

    // すべてのDMスレッドを走査し、アクティブ/非アクティブに応じて整理
    Object.keys(this.messages.individual || {}).forEach(pid => {
        // ローカルから未読数を再計算（read_byベース + 最終閲覧時刻）
        const c = this.computeLocalDMUnread(pid, myId);

        if (activeIds.has(pid)) {
            // アクティブ: 表示対象。サーバ値が無ければローカル値を反映、あればサーバ値を優先。
            if (this.unreadCounts.individual[pid] == null) this.unreadCounts.individual[pid] = c;
            if (this.suppressedDMUnread[pid] != null) delete this.suppressedDMUnread[pid];
        } else {
            // 非アクティブ: 表示から除外、未読は退避
            delete this.unreadCounts.individual[pid];
            if (c > 0) this.suppressedDMUnread[pid] = c;
            else delete this.suppressedDMUnread[pid];
        }
    });

    this.updateBadge();
    this.updateParticipantsList();

    const gOpen = this._qs('#group-chat-screen')?.classList.contains('active');
    const iOpen = this._qs('#individual-chat-screen')?.classList.contains('active');
    if (gOpen) this.renderGroupMessages();
    else if (iOpen && this.currentChatTarget) this.renderIndividualMessages(this.currentChatTarget);
}



    getLastReadTimestamps() {
        const key = `lastRead_${state.sessionId}_${state.participantId}`,
            s = sessionStorage.getItem(key);
        if (s) {
            try {
                return JSON.parse(s);
            } catch {}
        }
        return {
            group: 0,
            individual: {}
        };
    }
    setLastReadTimestamp(chatType, targetId = null) {
        const key = `lastRead_${state.sessionId}_${state.participantId}`;
        const ts = this.getLastReadTimestamps();
        const now = Date.now();
        if (chatType === 'group') ts.group = now;
        else if (targetId) {
            ts.individual = ts.individual || {};
            ts.individual[targetId] = now;
        }
        sessionStorage.setItem(key, JSON.stringify(ts));
    }

    // ---- モーダル開閉 ----
    openChat() {
        this.isTransitioning = false;
        this.isScrolling = false;
        this.chatModal.style.display = 'flex';
        if (this.isMobile) {
            document.body.classList.add('chat-modal-open');
            document.documentElement.classList.add('chat-modal-open');
        } else {
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'fixed';
            document.body.style.width = '100%';
            this.scrollPosition = window.scrollY;
            document.body.style.top = `-${this.scrollPosition}px`;
        }
        requestAnimationFrame(() => this.chatModal.classList.add('open'));

        if (window.visualViewport && this._onViewportResizeBound) {
            window.visualViewport.removeEventListener('resize', this._onViewportResizeBound);
            window.visualViewport.removeEventListener('scroll', this._onViewportResizeBound);
            this._onViewportResizeBound = null;
        }
        const container = this._qs('.chat-container');
        if (container) {
            container.style.height = '';
            container.style.maxHeight = '';
            container.style.width = '';
            container.style.maxWidth = '';
            container.style.borderRadius = '';
        }

        this.showParticipantsList();
        this.updateParticipantsList();
        this.startRapidStatusUpdate();
    }
    closeChat() {
        this.isTransitioning = false;
        this.isScrolling = false;
        this.lastTapTime = 0;
        this.chatModal.classList.remove('open');
        setTimeout(() => {
            this.chatModal.style.display = 'none';
            const c = this._qs('.chat-container');
            if (c) {
                c.style.height = '';
                c.style.maxHeight = '';
                c.style.width = '';
                c.style.maxWidth = '';
                c.style.borderRadius = '';
            }
        }, 300);
        this.stopRapidStatusUpdate();
        if (this.isMobile) {
            document.body.classList.remove('chat-modal-open');
            document.documentElement.classList.remove('chat-modal-open');
            if (window.visualViewport && this._onViewportResizeBound) {
                window.visualViewport.removeEventListener('resize', this._onViewportResizeBound);
                window.visualViewport.removeEventListener('scroll', this._onViewportResizeBound);
                this._onViewportResizeBound = null;
            }
        } else {
            document.body.style.overflow = '';
            document.body.style.position = '';
            document.body.style.width = '';
            document.body.style.top = '';
            if (this.scrollPosition !== undefined) window.scrollTo(0, this.scrollPosition);
        }
    }

    // ---- 参加者リスト ----
    showParticipantsList() {
        this._qsa('.chat-screen').forEach(s => s.classList.remove('active'));
        this._qs('#participants-screen')?.classList.add('active');
        this.updateParticipantsList();
    }
    updateParticipantsList() {
        const listEl = this._qs('#chat-participant-list');
        if (!listEl) return;
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        listEl.innerHTML = '';
        const groupUnread = this.unreadCounts.group || 0;
        const last = this.messages.group[this.messages.group.length - 1];
        const groupLbl = document.createElement('div');
        groupLbl.className = 'chat-section-label group-section';
        groupLbl.innerHTML = `<i class="fas fa-users"></i><span>グループ</span>`;
        listEl.appendChild(groupLbl);
        const groupItem = document.createElement('div');
        groupItem.className = 'chat-participant-item group';
        groupItem.dataset.participantId = 'group';
        let lastTxt = '全員でチャットしよう！';
        if (last) lastTxt = (last.message_type === 'image') ? '[画像]' : this.truncateMessage(last.text);
        groupItem.innerHTML = `
        <div class="participant-avatar"><i class="fas fa-users"></i></div>
        <div class="participant-info">
            <div class="participant-name" style="color:#00b300;"><i class="fas fa-globe"></i> 全員</div>
            <div class="last-message">${lastTxt}</div>
        </div>
        ${last?`<div class="message-time">${this.formatTime(last.timestamp)}</div>`:''}
        ${groupUnread>0?`<div class="unread-badge">${groupUnread}</div>`:''}`;
        if (isTouch) {
            let sy = 0,
                scrolling = false;
            this._on(groupItem, 'touchstart', (e) => {
                sy = e.touches[0].clientY;
                scrolling = false;
            }, {
                passive: true
            });
            this._on(groupItem, 'touchmove', (e) => {
                const dy = Math.abs(e.touches[0].clientY - sy);
                if (dy > 5) scrolling = true;
            }, {
                passive: true
            });
            this._on(groupItem, 'touchend', (e) => {
                if (scrolling) return;
                e.preventDefault();
                e.stopPropagation();
                this.openGroupChat();
            }, {
                passive: false
            });
        } else this._on(groupItem, 'click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.openGroupChat();
        });
        listEl.appendChild(groupItem);

        const sorted = (state.participantsData || []).filter(p => p.participant_id !== state.participantId).sort((a, b) => {
            const na = (a.participant_name || `参加者${a.participant_id.substring(0,4)}`).toLowerCase();
            const nb = (b.participant_name || `参加者${b.participant_id.substring(0,4)}`).toLowerCase();
            if (na === nb) return a.participant_id.localeCompare(b.participant_id);
            return na.localeCompare(nb);
        });
        if (sorted.length) {
            const lbl = document.createElement('div');
            lbl.className = 'chat-section-label individual-section';
            lbl.innerHTML = `<i class="fas fa-user"></i><span>個別チャット</span>`;
            listEl.appendChild(lbl);
            sorted.forEach(p => {
                const name = p.participant_name || `参加者${p.participant_id.substring(0,4)}`;
                const initials = name.substring(0, 2).toUpperCase();
                const pid = p.participant_id;
                let statusClass = '',
                    statusText = '';
                if (!p.is_online) {
                    statusClass = 'offline';
                    statusText = 'オフライン';
                } else if (p.is_background) {
                    statusClass = 'background';
                    statusText = 'バックグラウンド';
                } else if (p.status === 'sharing') {
                    statusClass = 'sharing';
                    statusText = '位置共有中';
                } else {
                    statusClass = 'waiting';
                    statusText = '共有待機中';
                }

                const msgs = this.messages.individual[pid] || [];
                const lastMsg = msgs[msgs.length - 1];
                const unread = this.unreadCounts.individual[pid] || 0;
                let lastTxt = 'タップしてチャット開始';
                if (lastMsg) lastTxt = (lastMsg.message_type === 'image') ? '[画像]' : this.truncateMessage(lastMsg.text);
                const item = document.createElement('div');
                item.className = 'chat-participant-item';
                item.dataset.participantId = pid;
                item.innerHTML = `
                <div class="participant-avatar" style="background:${mapManager.getParticipantColor(pid)};">${initials}<div class="status-indicator ${statusClass}"></div></div>
                <div class="participant-info"><div class="participant-name">${this.escapeHtml(name)}</div><div class="last-message">${lastTxt}</div><div class="participant-status ${statusClass}">${statusText}</div></div>
                ${lastMsg?`<div class="message-time">${this.formatTime(lastMsg.timestamp)}</div>`:''}
                ${unread>0?`<div class="unread-badge">${unread}</div>`:''}`;
                if (isTouch) {
                    let sy = 0,
                        scrolling = false;
                    this._on(item, 'touchstart', (e) => {
                        sy = e.touches[0].clientY;
                        scrolling = false;
                    }, {
                        passive: true
                    });
                    this._on(item, 'touchmove', (e) => {
                        const dy = Math.abs(e.touches[0].clientY - sy);
                        if (dy > 5) scrolling = true;
                    }, {
                        passive: true
                    });
                    this._on(item, 'touchend', (e) => {
                        if (scrolling) return;
                        e.preventDefault();
                        e.stopPropagation();
                        this.openIndividualChat(pid, name);
                    }, {
                        passive: false
                    });
                } else this._on(item, 'click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.openIndividualChat(pid, name);
                });
                listEl.appendChild(item);
            });
        } else {
            const empty = document.createElement('div');
            empty.style.cssText = 'text-align:center;padding:20px;color:#999;';
            empty.innerHTML = `<i class="fas fa-user-friends" style="font-size:48px;opacity:.3;"></i><p style="margin-top:10px;">他の参加者を待っています...</p>`;
            listEl.appendChild(empty);
        }
    }

    // ---- チャット画面 ----
    openGroupChat() {
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            if (this.isTransitioning) return;
            const now = Date.now();
            if (now - this.lastTapTime < 300) return;
            this.lastTapTime = now;
            this.isTransitioning = true;
        }

        this._qsa('.chat-screen').forEach(s => s.classList.remove('active'));
        this._qs('#group-chat-screen')?.classList.add('active');

        const active = (state.participantsData || []).filter(p => p.is_online).length;
        const h = this._qs('#group-chat-screen .chat-header h5');
        if (h) h.innerHTML = `<i class="fas fa-users"></i> グループチャット (${active}人)`;

        this.setLastReadTimestamp('group');

        // ★ ここを変更：バッジが0でも必ず既読化（冪等）
        wsManager.send({
            type: 'mark_as_read',
            participant_id: state.participantId,
            chat_type: 'group'
        });
        setTimeout(() => wsManager.send({
            type: 'mark_as_read',
            participant_id: state.participantId,
            chat_type: 'group'
        }), 200);

        // ローカルの未読表示もクリア
        this.unreadCounts.group = 0;
        this.updateBadge();

        this.renderGroupMessages();
        this.scrollToBottom('group-messages');
        this.startAutoReadMonitoring('group');

        if (isTouch) setTimeout(() => {
            this.isTransitioning = false;
        }, 300);
    }

    openIndividualChat(participantId, name) {
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            if (this.isTransitioning) return;
            const now = Date.now();
            if (now - this.lastTapTime < 300) return;
            this.lastTapTime = now;
            this.isTransitioning = true;
        }

        this.currentChatTarget = participantId;
        this._qsa('.chat-screen').forEach(s => s.classList.remove('active'));
        this._qs('#individual-chat-screen')?.classList.add('active');
        this._qs('#individual-chat-title').textContent = name;

        this.setLastReadTimestamp('individual', participantId);

        // ★ ここを変更：バッジが0でも必ず既読化（冪等）
        const send = () => wsManager.send({
            type: 'mark_as_read',
            participant_id: state.participantId,
            chat_type: 'individual',
            sender_id: participantId
        });
        send();
        setTimeout(send, 300);

        // ローカルの未読表示もクリア
        this.unreadCounts.individual[participantId] = 0;
        this.updateBadge();

        this.renderIndividualMessages(participantId);
        this.scrollToBottom('individual-messages');
        this.startAutoReadMonitoring('individual', participantId);

        if (isTouch) setTimeout(() => {
            this.isTransitioning = false;
        }, 300);
    }

    startAutoReadMonitoring(chatType, targetId = null) {
        if (this.autoReadInterval) clearInterval(this.autoReadInterval);
        this.autoReadInterval = setInterval(() => {
            const open = this.chatModal.style.display !== 'none';
            if (!open) {
                clearInterval(this.autoReadInterval);
                return;
            }
            if (chatType === 'group') {
                if (this._qs('#group-chat-screen')?.classList.contains('active') && this.unreadCounts.group > 0) this.markAsReadImmediately('group');
            } else {
                const ok = this._qs('#individual-chat-screen')?.classList.contains('active');
                const cur = this.currentChatTarget === targetId;
                if (ok && cur && (this.unreadCounts.individual[targetId] > 0)) this.markAsReadImmediately('individual', targetId);
            }
        }, ChatManager.C.AUTO_READ_MS);
    }

    // ---- 送信 ----
    sendGroupMessage() {
        const input = this._qs('#group-input');
        const text = input.value.trim();
        if (!text) return;
        this.handleTypingEnd('group');
        const myId = state.participantId || window.djangoData?.participantId;
        const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;
        const msg = {
            type: 'chat_message',
            chat_type: 'group',
            message_id: messageId,
            sender_id: myId,
            sender_name: this.getParticipantNameSafe(),
            text,
            timestamp: new Date().toISOString(),
            read_by: [myId]
        };
        this.messages.group.push(msg);
        const idx = this.messages.group.length - 1;
        this.messageReadStatus.group[idx] = [myId];
        this.appendNewMessage('group-messages', msg);
        wsManager.send(msg);
        input.value = '';
        input.style.height = `${ChatManager.C.TEXTAREA_MIN_H}px`;
        input.style.overflowY = 'hidden';
    }
    sendIndividualMessage() {
        const input = this._qs('#individual-input');
        const text = input.value.trim();
        if (!text || !this.currentChatTarget) return;
        this.handleTypingEnd(this.currentChatTarget);
        const msg = {
            type: 'chat_message',
            chat_type: 'individual',
            sender_id: state.participantId,
            sender_name: this.getParticipantNameSafe(),
            target_id: this.currentChatTarget,
            text,
            timestamp: new Date().toISOString()
        };
        if (!this.messages.individual[this.currentChatTarget]) this.messages.individual[this.currentChatTarget] = [];
        this.messages.individual[this.currentChatTarget].push(msg);
        this.appendNewMessage('individual-messages', msg);
        wsManager.send(msg);
        input.value = '';
        input.style.height = `${ChatManager.C.TEXTAREA_MIN_H}px`;
        input.style.overflowY = 'hidden';
    }

    // ---- 送信結果 ----
    handleMessageSendError(tempId, chatType, targetId = null, msgText = null) {
        const pend = tempId ? this.pendingMessages.get(tempId) : null;
        if (pend) {
            pend.isPending = false;
            pend.hasError = true;
            if (chatType === 'group') {
                const i = this.messages.group.findIndex(m => m.tempId === tempId);
                if (i !== -1) this.messages.group[i] = pend;
                this.renderGroupMessages();
            } else if (targetId) {
                const arr = this.messages.individual[targetId];
                if (arr) {
                    const i = arr.findIndex(m => m.tempId === tempId);
                    if (i !== -1) arr[i] = pend;
                }
                if (this.currentChatTarget === targetId) this.renderIndividualMessages(targetId);
            }
            this.pendingMessages.delete(tempId);
            if (this.pendingTimeouts[tempId]) {
                clearTimeout(this.pendingTimeouts[tempId]);
                delete this.pendingTimeouts[tempId];
            }
        }
        const title = pend?.message_type === 'image' ? '画像の送信に失敗しました' : 'メッセージの送信に失敗しました';
        const defMsg = pend?.message_type === 'image' ?
            `画像を送信できませんでした。<br><br>• 接続不安定 • サーバ一時停止 • セッション切れ • 処理失敗` :
            `メッセージを送信できませんでした。<br><br>• 接続不安定 • サーバ一時停止 • セッション切れ`;
        this.showImageErrorModal(title, msgText || defMsg);
    }
    handleMessageSendSuccess(tempId, chatType, targetId = null) {
        const pend = this.pendingMessages.get(tempId);
        if (!pend) return;
        pend.isPending = false;
        pend.hasError = false;
        if (this.pendingTimeouts[tempId]) {
            clearTimeout(this.pendingTimeouts[tempId]);
            delete this.pendingTimeouts[tempId];
        }
        if (chatType === 'group') {
            const i = this.messages.group.findIndex(m => m.tempId === tempId);
            if (i !== -1) this.messages.group[i] = pend;
        } else if (targetId) {
            const arr = this.messages.individual[targetId];
            if (arr) {
                const i = arr.findIndex(m => m.tempId === tempId);
                if (i !== -1) arr[i] = pend;
            }
        }
        this.pendingMessages.delete(tempId);
    }

    // ---- 受信 ----
    handleIncomingMessage(data) {
        if (data.sender_id === state.participantId) {
            if (data.error) {
                this.handleMessageSendError(null, data.chat_type, data.target_id, data.error_message);
                return;
            }
            if (data.message_type === 'image') {
                let foundId = null,
                    found = null;
                const rev = [...this.pendingMessages.entries()].reverse();
                for (const [tid, m] of rev) {
                    if (m.message_type === 'image' && m.chat_type === data.chat_type && m.target_id === data.target_id) {
                        foundId = tid;
                        found = m;
                        break;
                    }
                }
                if (foundId) {
                    if (this.pendingTimeouts[foundId]) {
                        clearTimeout(this.pendingTimeouts[foundId]);
                        delete this.pendingTimeouts[foundId];
                    }
                    this.handleMessageSendSuccess(foundId, data.chat_type, data.target_id);
                    const container = data.chat_type === 'group' ? this._qs('#group-messages') : this._qs('#individual-messages');
                    if (container) {
                        container.querySelectorAll('[data-temp-id]').forEach(el => {
                            const tid = el.getAttribute('data-temp-id');
                            if (tid === foundId) {
                                el.querySelector('.loading-overlay')?.remove();
                                el.querySelector('.error-overlay')?.remove();
                                const img = el.querySelector('.chat-image');
                                if (img) {
                                    img.classList.remove('loading');
                                    img.onclick = () => this.showImageViewer(data.image_data || found.image_data, data.image_mime_type || found.image_mime_type);
                                }
                                el.classList.remove('pending', 'error');
                                el.removeAttribute('data-temp-id');
                                if (!el.querySelector('.read-status')) {
                                    const rs = document.createElement('div');
                                    rs.className = 'read-status unread';
                                    rs.textContent = '未読';
                                    rs.style.visibility = 'visible';
                                    el.insertBefore(rs, el.firstChild);
                                }
                                setTimeout(() => {
                                    container.style.display = 'none';
                                    container.offsetHeight;
                                    container.style.display = '';
                                    container.scrollTop = container.scrollHeight;
                                }, 10);
                                setTimeout(() => {
                                    container.scrollTop = container.scrollHeight;
                                }, 100);
                            }
                        });
                        requestAnimationFrame(() => {
                            container.style.scrollBehavior = 'smooth';
                            container.scrollTop = container.scrollHeight;
                            setTimeout(() => {
                                container.scrollTop = container.scrollHeight;
                                container.style.scrollBehavior = '';
                            }, 100);
                        });
                    }
                }
            } else {
                let foundId = null;
                this.pendingMessages.forEach((m, tid) => {
                    if (m.text === data.text && m.chat_type === data.chat_type && m.target_id === data.target_id) foundId = tid;
                });
                if (foundId) this.handleMessageSendSuccess(foundId, data.chat_type, data.target_id);
            }
            return;
        }
        // 他者メッセージ
        if (data.chat_type === 'group') {
            this.messages.group.push(data);
            const gOpen = this._qs('#group-chat-screen')?.classList.contains('active');
            const open = this.chatModal.style.display !== 'none';
            if (gOpen && open) this.markAsReadImmediately('group');
            else {
                this.unreadCounts.group++;
                this.updateBadge();
            }
            if (gOpen) this.appendNewMessage('group-messages', data);
            if (this._qs('#participants-screen')?.classList.contains('active')) this.updateParticipantsList();
            if (!open) {
                const txt = data.message_type === 'image' ? `${data.sender_name}: [画像]` : `${data.sender_name}: ${this.truncateMessage(data.text)}`;
                ui.showNotification(txt, 'info', 'fas fa-comment');
            }
        } else if (data.chat_type === 'individual') {
            if (data.target_id === state.participantId) {
                const sid = data.sender_id;
                if (!this.messages.individual[sid]) this.messages.individual[sid] = [];
                this.messages.individual[sid].push(data);
                const iOpen = this._qs('#individual-chat-screen')?.classList.contains('active');
                const cur = this.currentChatTarget === sid;
                const open = this.chatModal.style.display !== 'none';
                if (iOpen && cur && open) this.markAsReadImmediately('individual', sid);
                else {
                    this.unreadCounts.individual[sid] = (this.unreadCounts.individual[sid] || 0) + 1;
                    this.updateBadge();
                }
                if (cur && iOpen) this.appendNewMessage('individual-messages', data);
                if (this._qs('#participants-screen')?.classList.contains('active')) this.updateParticipantsList();
                if (!open) {
                    const txt = data.message_type === 'image' ? `${data.sender_name}: [画像]` : `${data.sender_name}: ${this.truncateMessage(data.text)}`;
                    ui.showNotification(txt, 'info', 'fas fa-comment');
                }
            }
        }
        if (data.read_by && data.chat_type === 'group') {
            if (!this.readByInfo.group[data.message_id]) this.readByInfo.group[data.message_id] = [];
            this.readByInfo.group[data.message_id] = data.read_by;
        }
    }

    // ---- 既読通知受信 ----
handleReadStatusUpdate(data) {
    const {
        reader_id,
        chat_type,
        message_sender_id,
        target_id,
        message_id,
        read_by
    } = data;
    const myId = state.participantId || window.djangoData?.participantId;

    console.log('[ChatManager][handleReadStatusUpdate] << IN', {
        myId,
        reader_id,
        chat_type,
        message_sender_id,
        target_id,
        message_id,
        read_by
    });

    // === 自分が「読んだ側」 ===
    if (reader_id === myId) {
        console.log('[ChatManager][handleReadStatusUpdate] I am the READER', { myId, chat_type });

        if (chat_type === 'individual') {
            const otherId = message_sender_id; // 相手（送信者）
            if (!otherId) {
                console.log('[ChatManager][handleReadStatusUpdate] WARN: no otherId (message_sender_id) for individual');
                return;
            }

            const arr = this.messages.individual[otherId] || [];
            console.log('[ChatManager][handleReadStatusUpdate] INDIV READER: messages length', arr.length);

            for (let i = 0; i < arr.length; i++) {
                const m = arr[i];

                // 自分宛のメッセージだけ対象
                if (m.sender_id === otherId && m.target_id === myId) {
                    if (message_id && m.message_id && m.message_id !== message_id) {
                        console.log('[ChatManager][handleReadStatusUpdate] skip by message_id filter', {
                            idx: i,
                            m_message_id: m.message_id,
                            filter_message_id: message_id
                        });
                        continue;
                    }
                    const next = Array.isArray(read_by)
                        ? Array.from(new Set(read_by))
                        : (Array.isArray(m.read_by) ? [...new Set([...m.read_by, myId])] : [myId]);

                    console.log('[ChatManager][handleReadStatusUpdate] mark READ (I am reader)', {
                        idx: i,
                        before_read_by: m.read_by,
                        next
                    });

                    m.read_by = next;
                    m.is_read = true;
                    if (!this.messageReadStatus.individual[otherId]) this.messageReadStatus.individual[otherId] = {};
                    this.messageReadStatus.individual[otherId][i] = next;
                }
            }
            // バッジをクリア
            console.log('[ChatManager][handleReadStatusUpdate] clear INDIV badge for otherId', { otherId });
            this.unreadCounts.individual[otherId] = 0;
            this.updateBadge();
            console.log('[ChatManager][handleReadStatusUpdate] after updateBadge (INDIV as reader)', {
                unreadCounts: JSON.parse(JSON.stringify(this.unreadCounts))
            });

            if (this.currentChatTarget === otherId &&
                this._qs('#individual-chat-screen')?.classList.contains('active')) {
                console.log('[ChatManager][handleReadStatusUpdate] re-render INDIV messages (I am reader)', { otherId });
                this.renderIndividualMessages(otherId);
            }
        } else if (chat_type === 'group') {
            console.log('[ChatManager][handleReadStatusUpdate] I am reader: clear GROUP badge');
            this.unreadCounts.group = 0;
            this.updateBadge();
            console.log('[ChatManager][handleReadStatusUpdate] after updateBadge (GROUP as reader)', {
                unreadCounts: JSON.parse(JSON.stringify(this.unreadCounts))
            });
        }
        console.log('[ChatManager][handleReadStatusUpdate] >> OUT (I was reader)');
        return;
    }

    // === 自分が「送った側」 ===
    if (chat_type === 'group') {
        console.log('[ChatManager][handleReadStatusUpdate] I am SENDER (GROUP). Targeted update.');
        if (!message_id) {
            console.warn('[ChatManager][handleReadStatusUpdate] GROUP: missing message_id; skip bulk mutation');
        } else {
            const arr = this.messages.group || [];
            let updatedIndex = -1;
            for (let i = 0; i < arr.length; i++) {
                const m = arr[i];
                if (m.sender_id !== myId) continue;
                if (m.message_id !== message_id) continue; // ★ 一点更新
                const next = Array.isArray(read_by)
                    ? Array.from(new Set(read_by)) // サーバ真値をそのまま
                    : (Array.isArray(m.read_by) ? Array.from(new Set(m.read_by.concat(reader_id))) : [myId, reader_id]);

                console.log('[ChatManager][handleReadStatusUpdate] GROUP read update (targeted)', {
                    idx: i,
                    msg_id: m.message_id,
                    before_read_by: m.read_by,
                    next
                });

                m.read_by = next;
                m.is_read = true;
                this.messageReadStatus.group[i] = next;
                updatedIndex = i;
                break; // 対象1件で終了
            }

            const open = this._qs('#group-chat-screen')?.classList.contains('active');
            console.log('[ChatManager][handleReadStatusUpdate] GROUP screen open?', { open });

            // ★ DOM も該当メッセージだけ更新
            if (open && updatedIndex !== -1) {
                const node = this._qs(`.message.own[data-message-id="${message_id}"] .read-status`);
                const msg = this.messages.group[updatedIndex];
                if (node && msg) {
                    const othersCount = (msg.read_by || []).filter(id => id !== myId).length;
                    node.textContent = othersCount > 0 ? `既読 ${othersCount}人` : '未読';
                    node.className = `read-status ${othersCount > 0 ? 'read' : 'unread'}`;
                    console.log('[ChatManager][handleReadStatusUpdate] refresh DOM read-status for own GROUP msg (targeted)', {
                        others_count: othersCount,
                        message_id
                    });
                    console.log('[ChatManager][handleReadStatusUpdate] SANITY DOM text after set:', {
                        text: node.textContent,
                        className: node.className
                    });
                } else {
                    console.log('[ChatManager][handleReadStatusUpdate] No DOM node found for message_id or msg missing', {
                        message_id, hasNode: !!node, hasMsg: !!msg
                    });
                }
            }
        }
    } else if (chat_type === 'individual') {
        // ★ 相手が読んだ「送信者本人」だけが処理する（Aの既読→Aだけ更新。Bは無視）
        if (message_sender_id !== myId) {
            console.log('[ChatManager][handleReadStatusUpdate] INDIV: I am NOT sender → ignore', {
                myId,
                message_sender_id
            });
            console.log('[ChatManager][handleReadStatusUpdate] >> OUT (INDIV, not my sent message)');
            return;
        }

        const key = target_id || reader_id; // 既読した相手（Cなど）
        const arr = this.messages.individual[key] || [];
        console.log('[ChatManager][handleReadStatusUpdate] INDIV I am SENDER. target key:', key, 'msgs:', arr.length);

        for (let i = 0; i < arr.length; i++) {
            const m = arr[i];
            if (m.sender_id === myId && m.target_id === key) {
                if (message_id && m.message_id && m.message_id !== message_id) {
                    console.log('[ChatManager][handleReadStatusUpdate] skip by message_id filter (INDIV sender)', {
                        idx: i,
                        m_message_id: m.message_id,
                        filter_message_id: message_id
                    });
                    continue;
                }
                const next = Array.isArray(read_by)
                    ? Array.from(new Set(read_by))
                    : (Array.isArray(m.read_by) ? [...new Set([...m.read_by, reader_id])] : [myId, reader_id]);

                console.log('[ChatManager][handleReadStatusUpdate] mark READ (I am sender, INDIV)', {
                    idx: i,
                    before_read_by: m.read_by,
                    next
                });

                m.read_by = next;
                m.is_read = true;
                if (!this.messageReadStatus.individual[key]) this.messageReadStatus.individual[key] = {};
                this.messageReadStatus.individual[key][i] = next;
            }
        }

        const open = this._qs('#individual-chat-screen')?.classList.contains('active');
        console.log('[ChatManager][handleReadStatusUpdate] INDIV screen open & current target match?', {
            open,
            currentChatTarget: this.currentChatTarget,
            key
        });
        if (open && this.currentChatTarget === key) {
            const cont = this._qs('#individual-messages');
            if (cont) {
                console.log('[ChatManager][handleReadStatusUpdate] refresh DOM read-status for own INDIV msgs');
                cont.querySelectorAll('.message.own .read-status').forEach(st => {
                    st.textContent = '既読';
                    st.className = 'read-status read';
                });
            }
        }
    }

    console.log('[ChatManager][handleReadStatusUpdate] >> OUT (sender branch finished)', {
        unreadCounts: JSON.parse(JSON.stringify(this.unreadCounts))
    });
}



    // ---- メッセージ描画 ----
renderGroupMessages() {
    const cont = this._qs('#group-messages');
    if (!cont) return;
    const atBottom = this.isScrolledToBottom(cont);
    const keep = cont.scrollTop;

    const active = (state.participantsData || []).filter(p => p.is_online).length;
    const h = this._qs('#group-chat-screen .chat-header h5');
    if (h) h.innerHTML = `<i class="fas fa-users"></i> グループチャット (${active}人)`;

    if (this.messagesLoading) {
        cont.innerHTML = `<div class="chat-welcome"><div class="spinner-border text-primary" role="status" style="width:48px;height:48px"><span class="visually-hidden">Loading...</span></div><p style="color:#999;margin-top:15px;">メッセージ履歴を読み込み中...</p></div>`;
        return;
    }
    if (this.messages.group.length === 0) {
        cont.innerHTML = `<div class="chat-welcome"><i class="fas fa-comments" style="font-size:48px;color:#00b300;opacity:.3;"></i><p style="color:#999;margin-top:10px;">グループチャットへようこそ！</p></div>`;
        return;
    }

    let html = '', lastDate = null;
    const myId = state.participantId || window.djangoData?.participantId;

    this.messages.group.forEach((m, i) => {
        if (m.message_type === 'system' || m.type === 'system') {
            html += `<div class="system-message">${m.text}</div>`;
            return;
        }
        const d = new Date(m.timestamp).toLocaleDateString();
        if (d !== lastDate) {
            html += `<div class="system-message">${d}</div>`;
            lastDate = d;
        }
        const own = m.sender_id === myId,
              isPending = m.isPending || false,
              hasError = m.hasError || false,
              mid = m.message_id || `temp-${i}`;

        // ★ サーバの m.read_by を最優先。無ければキャッシュ this.messageReadStatus.group[i]
        const readBy = (Array.isArray(m.read_by) && m.read_by.length ? m.read_by
                         : this.messageReadStatus.group[i]) || [];
        const others = readBy.filter(id => id !== myId);
        const readStatus = own ? (others.length > 0 ? `既読 ${others.length}人` : '未読') : '';
        const readCls = others.length > 0 ? 'read' : 'unread';

        if (m.message_type === 'image') {
            html += `
            <div class="message ${own?'own':''} ${isPending?'pending':''} ${hasError?'error':''}" data-message-date="${d}" data-message-id="${mid}" data-message-index="${i}">
                ${own&&readStatus?`<div class="read-status ${readCls}">${readStatus}</div>`:''}
                <div class="message-bubble image-bubble">
                    ${!own?`<div class="message-sender">${m.sender_name}</div>`:''}
                    <div class="image-container">
                        ${isPending?'<div class="loading-overlay"><div class="spinner-border spinner-border-sm text-light"></div></div>':''}
                        ${hasError?'<div class="error-overlay"><i class="fas fa-exclamation-triangle"></i></div>':''}
                        <img class="chat-image ${isPending?'loading':''}" src="${m.image_thumbnail||m.image_data}" ${(!isPending&&!hasError)?`onclick="chatManager.showImageViewer('${m.image_data}','${m.image_mime_type}')"`:''} alt="送信された画像">
                    </div>
                    <div class="message-time-label">${this.formatTime(m.timestamp)}</div>
                </div>
            </div>`;
        } else {
            html += `
            <div class="message ${own?'own':''} ${hasError?'error':''}" data-message-date="${d}" data-message-id="${mid}" data-message-index="${i}">
                ${own&&readStatus?`<div class="read-status ${readCls}">${readStatus}</div>`:''}
                <div class="message-bubble">
                    ${!own?`<div class="message-sender">${m.sender_name}</div>`:''}
                    <div>${this.escapeHtml(m.text)}</div>
                    <div class="message-time-label">${this.formatTime(m.timestamp)}</div>
                </div>
                ${hasError&&own?'<div class="message-error"><i class="fas fa-exclamation-circle"></i></div>':''}
            </div>`;
        }
    });

    cont.innerHTML = html;
    if (atBottom) this.scrollToBottom('group-messages');
    else cont.scrollTop = keep;
}

    renderIndividualMessages(pid) {
        const cont = this._qs('#individual-messages');
        if (!cont) return;
        const atBottom = this.isScrolledToBottom(cont);
        const keep = cont.scrollTop;
        if (this.messagesLoading) {
            cont.innerHTML = `<div class="chat-welcome"><div class="spinner-border text-primary" role="status" style="width:48px;height:48px"><span class="visually-hidden">Loading...</span></div><p style="color:#999;margin-top:15px;">メッセージ履歴を読み込み中...</p></div>`;
            return;
        }
        const arr = this.messages.individual[pid] || [];
        if (arr.length === 0) {
            cont.innerHTML = `<div class="chat-welcome"><i class="fas fa-comment" style="font-size:48px;color:#00b300;opacity:.3;"></i><p style="color:#999;margin-top:10px;">チャットを開始しましょう！</p></div>`;
            return;
        }
        let html = '',
            lastDate = null;
        const myId = state.participantId || window.djangoData?.participantId;
        arr.forEach((m, i) => {
            const d = new Date(m.timestamp).toLocaleDateString();
            if (d !== lastDate) {
                html += `<div class="system-message">${d}</div>`;
                lastDate = d;
            }
            const own = m.sender_id === myId,
                isPending = m.isPending || false,
                hasError = m.hasError || false,
                mid = m.message_id || `temp-${i}`;
            const readBy = this.messageReadStatus.individual[pid]?.[i] || m.read_by || [];
            const others = readBy.filter(id => id !== myId);
            const readStatus = own ? (others.length > 0 ? '既読' : '未読') : '';
            const readCls = others.length > 0 ? 'read' : 'unread';
            if (m.message_type === 'image') {
                html += `
                <div class="message ${own?'own':''} ${isPending?'pending':''} ${hasError?'error':''}" data-message-date="${d}" data-message-id="${mid}" data-message-index="${i}">
                    ${own&&readStatus?`<div class="read-status ${readCls}">${readStatus}</div>`:''}
                    <div class="message-bubble image-bubble">
                        <div class="image-container">
                            ${isPending?'<div class="loading-overlay"><div class="spinner-border spinner-border-sm text-light"></div></div>':''}
                            ${hasError?'<div class="error-overlay"><i class="fas fa-exclamation-triangle"></i></div>':''}
                            <img class="chat-image ${isPending?'loading':''}" src="${m.image_thumbnail||m.image_data}" ${(!isPending&&!hasError)?`onclick="chatManager.showImageViewer('${m.image_data}','${m.image_mime_type}')"`:''} alt="送信画像">
                        </div>
                        <div class="message-time-label">${this.formatTime(m.timestamp)}</div>
                    </div>
                </div>`;
            } else {
                html += `
                <div class="message ${own?'own':''} ${hasError?'error':''}" data-message-date="${d}" data-message-id="${mid}" data-message-index="${i}">
                    ${own&&readStatus?`<div class="read-status ${readCls}">${readStatus}</div>`:''}
                    <div class="message-bubble">
                        <div>${this.escapeHtml(m.text)}</div>
                        <div class="message-time-label">${this.formatTime(m.timestamp)}</div>
                    </div>
                    ${hasError&&own?'<div class="message-error"><i class="fas fa-exclamation-circle"></i></div>':''}
                </div>`;
            }
        });
        cont.innerHTML = html;
        if (atBottom) this.scrollToBottom('individual-messages');
        else cont.scrollTop = keep;
    }

    // ---- 逐次追加 ----
    appendNewMessage(containerId, message) {
        const cont = this._qs(`#${containerId}`);
        if (!cont) return;
        const welcome = cont.querySelector('.chat-welcome');
        if (welcome) {
            welcome.style.transition = 'opacity .3s';
            welcome.style.opacity = '0';
            setTimeout(() => welcome.remove(), 300);
        }
        const atBottom = this.isScrolledToBottom(cont);
        const prevTop = cont.scrollTop;
        const isOwn = message.sender_id === state.participantId;

        const msgDate = new Date(message.timestamp).toLocaleDateString();
        const msgs = cont.querySelectorAll('.message');
        let needSep = false;
        if (msgs.length > 0) {
            const last = msgs[msgs.length - 1];
            if (last.dataset.messageDate !== msgDate) needSep = true;
        } else needSep = true;
        if (needSep) {
            const sep = document.createElement('div');
            sep.className = 'system-message';
            sep.textContent = msgDate;
            cont.appendChild(sep);
        }

        const div = document.createElement('div');
        const isPending = !!message.isPending,
            hasError = !!message.hasError,
            mid = message.message_id || message.tempId || `msg-${Date.now()}`,
            tempId = message.tempId;
        div.className = `message ${isOwn?'own':''} ${isPending?'pending':''} ${hasError?'error':''}`;
        div.dataset.messageDate = msgDate;
        div.dataset.messageId = mid;
        if (tempId) div.setAttribute('data-temp-id', tempId);

        let readStatusHtml = '';
        if (isOwn) {
            if (message.message_type === 'image') {
                readStatusHtml = isPending ? '' : '<div class="read-status unread" style="visibility:hidden;">未読</div>';
                if (!isPending) setTimeout(() => {
                    const s = div.querySelector('.read-status');
                    if (s) s.style.visibility = 'visible';
                }, 500);
            } else {
                readStatusHtml = '<div class="read-status unread" style="visibility:hidden;">未読</div>';
                setTimeout(() => {
                    const s = div.querySelector('.read-status');
                    if (s) s.style.visibility = 'visible';
                }, 300);
            }
        }
        if (message.message_type === 'image') {
            div.innerHTML = `
            ${readStatusHtml}
            <div class="message-bubble image-bubble">
                ${!isOwn?`<div class="message-sender">${message.sender_name}</div>`:''}
                <div class="image-container">
                    ${isPending?'<div class="loading-overlay"><div class="spinner-border spinner-border-sm text-light"></div></div>':''}
                    ${hasError?'<div class="error-overlay"><i class="fas fa-exclamation-triangle"></i></div>':''}
                    <img class="chat-image ${isPending?'loading':''}" src="${message.image_thumbnail||message.image_data}" ${(!isPending&&!hasError)?`onclick="chatManager.showImageViewer('${message.image_data}','${message.image_mime_type}')"`:''} alt="送信画像">
                </div>
                <div class="message-time-label">${this.formatTime(message.timestamp)}</div>
            </div>`;
        } else {
            div.innerHTML = `
            ${readStatusHtml}
            <div class="message-bubble">
                ${!isOwn?`<div class="message-sender">${message.sender_name}</div>`:''}
                <div>${this.escapeHtml(message.text)}</div>
                <div class="message-time-label">${this.formatTime(message.timestamp)}</div>
            </div>`;
        }
        cont.appendChild(div);

        if (isOwn) {
            if (atBottom) {
                if (message.message_type === 'image') {
                    const img = div.querySelector('.chat-image');
                    if (img) {
                        img.onload = () => {
                            cont.scrollTop = cont.scrollHeight;
                        };
                        img.onerror = () => {
                            cont.scrollTop = cont.scrollHeight;
                        };
                        cont.scrollTop = cont.scrollHeight;
                    } else cont.scrollTop = cont.scrollHeight;
                } else {
                    requestAnimationFrame(() => {
                        cont.style.scrollBehavior = 'smooth';
                        cont.scrollTop = cont.scrollHeight;
                        setTimeout(() => {
                            cont.style.scrollBehavior = '';
                        }, 300);
                    });
                }
            } else {
                cont.style.scrollBehavior = 'auto';
                cont.scrollTop = cont.scrollHeight;
                if (message.message_type === 'image') {
                    const img = div.querySelector('.chat-image');
                    if (img) {
                        img.onload = () => cont.scrollTop = cont.scrollHeight;
                        img.onerror = () => cont.scrollTop = cont.scrollHeight;
                    }
                }
            }
        } else if (atBottom) {
            if (message.message_type === 'image') {
                const img = div.querySelector('.chat-image');
                const go = () => {
                    cont.style.scrollBehavior = 'smooth';
                    cont.scrollTop = cont.scrollHeight;
                    setTimeout(() => {
                        cont.style.scrollBehavior = '';
                    }, 300);
                };
                if (img) {
                    if (img.complete) go();
                    else {
                        img.addEventListener('load', go, {
                            once: true
                        });
                        img.addEventListener('error', go, {
                            once: true
                        });
                    }
                }
            } else {
                requestAnimationFrame(() => {
                    cont.style.scrollBehavior = 'smooth';
                    cont.scrollTop = cont.scrollHeight;
                    setTimeout(() => {
                        cont.style.scrollBehavior = '';
                    }, 300);
                });
            }
        } else {
            cont.scrollTop = prevTop;
            const type = containerId === 'group-messages' ? 'group' : 'individual';
            this.showNewMessageIndicator(type);
        }
    }

    // ---- 既読即時 ----
    markAsReadImmediately(chatType, senderId = null) {
        const payload = {
            type: 'mark_as_read',
            participant_id: state.participantId,
            chat_type: chatType
        };
        const myId = state.participantId || window.djangoData?.participantId;
        if (chatType === 'individual' && senderId) payload.sender_id = senderId;
        if (wsManager?.websocket?.readyState === WebSocket.OPEN) wsManager.send(payload);

        // ★ ローカルの既読反映（read_by を即時更新）
        if (chatType === 'individual' && senderId) {
            const arr = this.messages.individual[senderId] || [];
            for (const m of arr) {
                if (m.sender_id === senderId && m.target_id === myId) {
                    m.read_by = Array.isArray(m.read_by) ?
                        [...new Set([...m.read_by, myId])] :
                        [myId];
                    m.is_read = true;
                }
            }
        } else if (chatType === 'group') {
            // グループは数値で管理。必要に応じてローカル既読フラグも立てる
            this.messages.group.forEach(m => {
                if (m.sender_id !== myId) {
                    m.is_read = true;
                    m.read_by = Array.isArray(m.read_by) ?
                        [...new Set([...m.read_by, myId])] :
                        [myId];
                }
            });
        }

        // バッジ/最終閲覧時刻
        if (chatType === 'group') this.unreadCounts.group = 0;
        else if (senderId) this.unreadCounts.individual[senderId] = 0;

        this.updateBadge();
        this.setLastReadTimestamp(chatType, senderId);
    }


    // ---- ステータス ----
    handleParticipantStatusUpdate() {
        // 退出/復帰のたびに未読を再配分（表示用と退避用）
        if (!this.suppressedDMUnread) this.suppressedDMUnread = {};

        const myId = state.participantId || window.djangoData?.participantId;
        const activeIds = new Set((state.participantsData || []).map(p => p.participant_id));

        // 既知のDM相手を全て見て、現在のアクティブ状態で振り分け直す
        Object.keys(this.messages.individual || {}).forEach(pid => {
            const c = this.computeLocalDMUnread(pid, myId); // 最新未読をローカルで計算

            if (activeIds.has(pid)) {
                // 復帰（もしくは元からアクティブ） → 表示用へ
                if (c > 0) {
                    this.unreadCounts.individual[pid] = c; // そのまま上書きで最新化
                } else {
                    delete this.unreadCounts.individual[pid];
                }
                // 退避に残っていたら消す
                if (this.suppressedDMUnread[pid] != null) delete this.suppressedDMUnread[pid];
            } else {
                // 退出 → 表示から除外し退避へ
                delete this.unreadCounts.individual[pid];
                if (c > 0) this.suppressedDMUnread[pid] = c;
                else delete this.suppressedDMUnread[pid];
            }
        });

        // 画面反映
        if (this.chatModal.style.display !== 'none' && this._qs('#participants-screen')?.classList.contains('active')) {
            this.updateParticipantsList();
        }
        this.updateBadge(); // バッジ合計も即時更新
    }

    startStatusUpdateTimer() {
        this.participantStatusInterval = setInterval(() => {
            if (this.chatModal.style.display !== 'none' && this._qs('#participants-screen')?.classList.contains('active')) this.updateParticipantsList();
        }, ChatManager.C.STATUS_MS);
    }
    stopStatusUpdateTimer() {
        if (this.participantStatusInterval) {
            clearInterval(this.participantStatusInterval);
            this.participantStatusInterval = null;
        }
    }
    startRapidStatusUpdate() {
        if (this.rapidStatusInterval) clearInterval(this.rapidStatusInterval);
        this.pauseHoverTracking = true;
        this.rapidStatusInterval = setInterval(() => {
            if (this.chatModal.style.display !== 'none' && this._qs('#participants-screen')?.classList.contains('active')) {
                this.pauseHoverTracking = false;
                this.updateParticipantsList();
                setTimeout(() => {
                    this.pauseHoverTracking = true;
                }, 50);
            }
        }, ChatManager.C.RAPID_STATUS_MS);
    }
    stopRapidStatusUpdate() {
        if (this.rapidStatusInterval) {
            clearInterval(this.rapidStatusInterval);
            this.rapidStatusInterval = null;
        }
    }

    // ---- 表示補助 ----
    isScrolledToBottom(el) {
        if (!el) return true;
        const th = ChatManager.C.NEWMSG_INDENT;
        return el.scrollHeight - el.scrollTop - el.clientHeight < th;
    }
    showNewMessageIndicator(chatType) {
        const id = chatType === 'group' ? 'group-new-message-indicator' : 'individual-new-message-indicator';
        this._qs(`#${id}`)?.remove();
        const ind = document.createElement('div');
        ind.id = id;
        ind.className = 'new-message-indicator';
        ind.style.cssText = 'position:absolute;bottom:60px;left:50%;transform:translateX(-50%);background:#007bff;color:#fff;padding:8px 16px;border-radius:20px;font-size:12px;cursor:pointer;z-index:2000;box-shadow:0 2px 8px rgba(0,123,255,.3);animation:slideUpCenter .3s ease-out;pointer-events:auto;';
        ind.innerHTML = '<i class="fas fa-chevron-down"></i> 新着メッセージ';
        const container = chatType === 'group' ? this._qs('#group-chat-screen') : this._qs('#individual-chat-screen');
        if (!container) return;
        container.style.position = 'relative';
        container.appendChild(ind);
        const scrollHandler = (e) => {
            e.stopPropagation();
            e.preventDefault();
            const mc = chatType === 'group' ? this._qs('#group-messages') : this._qs('#individual-messages');
            if (mc) {
                mc.style.scrollBehavior = 'smooth';
                mc.scrollTop = mc.scrollHeight;
                setTimeout(() => {
                    mc.style.scrollBehavior = '';
                }, 500);
            }
            ind.remove();
        };
        this._on(ind, 'click', scrollHandler, {
            capture: true
        });
        this._on(ind, 'touchstart', (e) => {
            e.stopPropagation();
        }, {
            passive: true
        });
        this._on(ind, 'touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            scrollHandler(e);
        }, {
            passive: false
        });
        const mc = chatType === 'group' ? this._qs('#group-messages') : this._qs('#individual-messages');
        if (mc) {
            const mon = () => {
                if (this.isScrolledToBottom(mc)) {
                    ind.remove();
                    mc.removeEventListener('scroll', mon);
                }
            };
            this._on(mc, 'scroll', mon);
        }
    }
    updateBadge() {
        // 表示対象は unreadCounts.individual（=アクティブのみ）。退避中は suppressedDMUnread に入っているので合計に含めない。
        let total = this.unreadCounts.group || 0;

        // 念のため、アクティブ参加者のみ集計（冪等性維持）
        const activeIds = new Set((state.participantsData || []).map(p => p.participant_id));
        for (const [pid, cnt] of Object.entries(this.unreadCounts.individual || {})) {
            if (activeIds.has(pid)) total += cnt || 0;
        }

        if (total > 0) {
            this.chatBadge.textContent = total > 99 ? '99+' : total;
            this.chatBadge.style.display = 'block';
        } else {
            this.chatBadge.style.display = 'none';
        }
    }


    // ---- クリーンアップ ----
    cleanup() {
        ['#group-input', '#individual-input'].forEach(sel => {
            const el = this._qs(sel);
            if (el) {
                // 先に元要素のイベントを外す
                this._off(el);
                // その後でクローン差し替え（バブリングで残った匿名リスナを断つ）
                const clone = el.cloneNode(true);
                el.parentNode.replaceChild(clone, el);
            }
        });
        this.stopStatusUpdateTimer();
        this.stopRapidStatusUpdate();
        this.pendingMessages.clear();
        Object.keys(this.pendingTimeouts).forEach(k => clearTimeout(this.pendingTimeouts[k]));
        this.pendingTimeouts = {};
        this.messages = {
            group: [],
            individual: {}
        };
        this.messageReadStatus = {
            group: {},
            individual: {}
        };
    }

    // ---- ユーティリティ ----
    getParticipantNameSafe() {
        const name = state.getParticipantName?.();
        if (!name || !name.trim()) return `参加者${(state.participantId||'').substring(0,4)}`;
        return name;
    }
    formatTime(ts) {
        const date = new Date(ts),
            now = new Date(),
            diff = now - date;
        if (diff < 60000) return '今';
        if (diff < 3600000) return `${Math.floor(diff/60000)}分前`;
        if (diff < 86400000) return date.toLocaleTimeString('ja-JP', {
            hour: '2-digit',
            minute: '2-digit'
        });
        return date.toLocaleDateString('ja-JP', {
            month: 'numeric',
            day: 'numeric'
        });
    }
    truncateMessage(t, max = 30) {
        if (!t) return '';
        return t.length > max ? t.substring(0, max) + '...' : t;
    }
    escapeHtml(t) {
        const d = document.createElement('div');
        d.textContent = t;
        return d.innerHTML.replace(/\n/g, '<br>');
    }
    scrollToBottom(id) {
        const el = this._qs(`#${id}`);
        if (el) setTimeout(() => {
            el.scrollTop = el.scrollHeight;
        }, 50);
    }
}


// === セッション管理クラス ===
class SessionManager {
    // 内部ヘルパー：退出ボタンの状態変更
    _disableLeaveButton() {
        const leaveButton = document.getElementById('leave-session');
        if (leaveButton) {
            leaveButton.disabled = true;
            leaveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 退出中';
        }
    }

    // 内部ヘルパー：退出フラグ設定と永続化
    _setLeavingFlagsAndPersist() {
        // 退出フラグを設定
        state.isLeaving = true;
        state.sessionExpired = true;

        // ★ 重要：LocalStorageに退出フラグを保存（ページ遷移後も維持）
        try {
            localStorage.setItem(`leaving_${state.sessionId}`, 'true');
            localStorage.setItem(`leaving_timestamp_${state.sessionId}`, Date.now().toString());
        } catch (e) {
            console.warn('LocalStorage set error:', e);
        }
    }

    // 内部ヘルパー：WebSocketの再接続タイマーをクリア
    _clearWsTimers() {
        if (wsManager?.connectionInterval) {
            clearInterval(wsManager.connectionInterval);
            wsManager.connectionInterval = null;
        }
    }

    // 内部ヘルパー：WebSocketハンドラの解除
    _resetWebSocketHandlers() {
        if (wsManager?.websocket) {
            wsManager.websocket.onclose = null;
            wsManager.websocket.onerror = null;
            wsManager.websocket.onopen = null;
            wsManager.websocket.onmessage = null;
        }
    }

    // 内部ヘルパー：WebSocketを安全にクローズ
    _closeWebSocketIfAny(reason = 'user_leave') {
        if (wsManager?.websocket) {
            try {
                wsManager.websocket.close(1000, reason);
            } catch (e) {
                console.warn('WebSocket close error:', e);
            }
            wsManager.websocket = null;
        }
    }

    // 内部ヘルパー：状態クリア（安全）
    _safeStateClear() {
        try {
            state.clear();
        } catch (error) {
            console.warn('状態クリアエラー:', error);
        }
    }

    // 内部ヘルパー：チャットクリーンアップ（安全）
    _safeChatCleanup() {
        if (window.chatManager) {
            try {
                chatManager.cleanup();
            } catch (error) {
                console.warn('チャットクリーンアップエラー:', error);
            }
        }
    }

    // 内部ヘルパー：UIクリーンアップ（安全）
    _safeUiCleanup() {
        try {
            ui.cleanup();
        } catch (error) {
            console.warn('UIクリーンアップエラー:', error);
        }
    }

handleExpired(reason = 'expired') {
  state.sessionExpired = true;
  locationManager.stopSharing?.();
  state.clear();

  // ステータスバッジ
  if (ui?.elements?.sessionStatus) {
    if (reason === 'invalidated') {
      ui.elements.sessionStatus.innerHTML = '<span class="badge bg-secondary">無効化</span>';
    } else {
      ui.elements.sessionStatus.innerHTML = '<span class="badge bg-danger">期限切れ</span>';
    }
  }

  // 画面上のステータス行
  if (reason === 'invalidated') {
    ui.updateStatus?.('location', 'error', 'セッションは無効化されました');
  } else {
    ui.updateStatus?.('location', 'error', 'セッションが期限切れです');
  }

  // モーダル文言の差し替え
  const modalEl = document.getElementById('session-expired-modal');
  if (modalEl) {
    // header色・アイコン・タイトル
    const header = document.getElementById('expired-modal-header');
    const content = document.getElementById('expired-modal-content');
    const icon = document.getElementById('expired-title-icon');
    const titleText = document.getElementById('expired-title-text');
    const lead = document.getElementById('expired-lead');
    const desc = document.getElementById('expired-desc');

    if (reason === 'invalidated') {
      // 見た目
      header?.classList.remove('bg-danger', 'text-white');
      header?.classList.add('bg-secondary', 'text-white');
      content?.classList.remove('border-danger');
      content?.classList.add('border-secondary');

      // タイトル
      if (icon) { icon.className = 'fas fa-ban me-2'; }
      if (titleText) { titleText.textContent = 'セッションは無効化されました'; }

      // リード
      if (lead) {
        lead.classList.remove('alert-warning');
        lead.classList.add('alert-secondary');
        lead.innerHTML = '<i class="fas fa-ban me-2" aria-hidden="true"></i> このセッションは参加者により無効化されました。';
      }

      // 本文
      if (desc) {
        desc.innerHTML = '全参加者の位置情報共有を停止し、関連データのクリーンアップを実行しました。<br>必要に応じて新しいセッションを作成してください。';
      }
    } else {
      // 期限切れ（デフォルト表記へ戻す）
      header?.classList.remove('bg-secondary');
      header?.classList.add('bg-danger', 'text-white');
      content?.classList.remove('border-secondary');
      content?.classList.add('border-danger');

      if (icon) { icon.className = 'fas fa-exclamation-triangle me-2'; }
      if (titleText) { titleText.textContent = 'セッション期限切れ'; }

      if (lead) {
        lead.classList.remove('alert-secondary');
        lead.classList.add('alert-warning');
        lead.innerHTML = '<i class="fas fa-clock me-2" aria-hidden="true"></i> このセッションは期限切れになりました。';
      }
      if (desc) {
        desc.innerHTML = '位置情報の共有が停止されました。<br>セッションに関連する位置情報データ、チャットのやり取りは自動的に消去されました。';
      }
    }

    // モーダル表示
    if (window.bootstrap?.Modal) {
      const modal = new bootstrap.Modal(modalEl);
      modal.show();
    }
  }
}

    leave() {
        if (confirm('セッションから退出しますか？\n\n＜ご注意ください＞\n・再参加にはセッションURLが必要です。\n・退出後、数秒間は再参加できません。')) {
            console.log('=== 退出処理開始 ===');

            // ボタンを無効化して多重クリックを防ぐ
            this._disableLeaveButton();

            // 退出フラグを設定 + 永続化
            this._setLeavingFlagsAndPersist();

            // WebSocket の再接続タイマーをすべてクリア
            this._clearWsTimers();

            // 位置情報共有を停止
            if (locationManager?.watchId) {
                try {
                    navigator.geolocation.clearWatch(locationManager.watchId);
                } catch (e) {
                    console.warn('clearWatch error:', e);
                }
                locationManager.watchId = null;
            }

            // 自分のマーカーを即座に削除
            if (mapManager?.markers?.[state.participantId]) {
                mapManager.removeMarker(state.participantId);
            }

            // 参加者リストから自分を即座に削除
            state.participantsData = (state.participantsData || []).filter(p => p.participant_id !== state.participantId);
            try {
                state.previousParticipantsState.delete(state.participantId);
            } catch {}
            participantManager?.updateDisplay?.();

            // WebSocket接続がある場合は退出通知を送信
            if (wsManager?.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                const leaveData = {
                    type: 'leave',
                    participant_id: state.participantId,
                    participant_name: state.getParticipantName?.(),
                    session_id: state.sessionId,
                    timestamp: new Date().toISOString(),
                    final_leave: true
                };

                try {
                    // 送信を試行
                    wsManager.send(leaveData);

                    // 即座に WebSocket を閉じる（応答を待たない）
                    this._resetWebSocketHandlers();
                    this._closeWebSocketIfAny('user_leave');

                    // 少し待ってから画面遷移
                    setTimeout(() => {
                        this.finalizeLeave();
                    }, 500);

                } catch (error) {
                    console.warn('退出通知送信エラー:', error);
                    this.finalizeLeave();
                }
            } else {
                // WebSocket未接続の場合は即座に終了
                this.finalizeLeave();
            }
        }
    }

    finalizeLeave() {
        console.log('=== 最終退出処理開始 ===');

        // 退出フラグが確実に設定されていることを確認
        this._setLeavingFlagsAndPersist();

        // WebSocketを完全に無効化
        this._resetWebSocketHandlers();
        this._closeWebSocketIfAny('user_leave');

        // タイマーをクリア
        this._clearWsTimers();

        // 状態をクリア（エラーを無視）
        this._safeStateClear();

        // チャットマネージャーのクリーンアップ
        this._safeChatCleanup();

        // UIクリーンアップ
        this._safeUiCleanup();

        // ホーム画面に移動
        window.location.href = '/';
    }
}

// === バックグラウンド管理クラス ===
class BackgroundManager {
    constructor() {
        this.backgroundStateTimeout = null;
        this.isPageUnloading = false;
        this.foregroundRestoreTimeout = null; // 追加
        this.setupVisibilityHandlers();
    }

    setupVisibilityHandlers() {
        // 可視性変更の即座検出
        document.addEventListener('visibilitychange', () => {
            const wasInBackground = state.isInBackground;
            const newBackgroundState = document.hidden;

            // 全てのタイムアウトをクリア
            if (this.backgroundStateTimeout) {
                clearTimeout(this.backgroundStateTimeout);
                this.backgroundStateTimeout = null;
            }
            if (this.foregroundRestoreTimeout) {
                clearTimeout(this.foregroundRestoreTimeout);
                this.foregroundRestoreTimeout = null;
            }

            // 即座に状態変更
            if (newBackgroundState && !wasInBackground) {
                this.handleTransition(true);
            } else if (!newBackgroundState && wasInBackground) {
                this.isPageUnloading = false; // 確実にリセット
                this.handleImmediateForegroundReturn(); // 即座復帰専用メソッド
            }
        });

        // ページフォーカス喪失（即座検出）
        window.addEventListener('blur', () => {
            if (!state.isInBackground && !this.isPageUnloading) {
                this.handleTransition(true);
            }
        });

        // ページフォーカス復帰 - 最優先処理
        window.addEventListener('focus', () => {
            if (state.isInBackground && !this.isPageUnloading) {
                this.isPageUnloading = false;
                this.handleImmediateForegroundReturn(); // 即座復帰
            }
        });

        // モバイル向け：pagehide の即座検出
        window.addEventListener('pagehide', (e) => {
            this.isPageUnloading = true;
            if (!state.isInBackground) {
                this.handleTransition(true);
            }
        });

        // モバイル向け：pageshow の復帰検出 - 最優先処理
        window.addEventListener('pageshow', (e) => {
            if (e.persisted && state.isInBackground) {
                this.isPageUnloading = false;
                this.handleImmediateForegroundReturn(); // 即座復帰
            }
        });

        // beforeunload での事前通知（即座実行）
        window.addEventListener('beforeunload', () => {
            this.isPageUnloading = true;
            if (!state.isInBackground) {
                this.handleTransition(true);
            }
        });
    }

    // BackgroundManager の handleImmediateForegroundReturn メソッドを修正
    handleImmediateForegroundReturn() {
        console.log('即座フォアグラウンド復帰処理開始');

        // 状態を即座にフォアグラウンドに変更
        const wasInBackground = state.isInBackground;
        state.isInBackground = false;

        // UI を即座に更新
        ui.updateStatus?.('visibility', 'active', 'アクティブ');
        locationManager.updateLocationStatus?.();

        // WebSocket関連の即座処理
        state.backgroundReconnectAttempts = 0;

        // WebSocket接続状態をチェックして適切に処理
        if (!wsManager?.websocket || wsManager.websocket.readyState !== WebSocket.OPEN) {
            // 接続がない、または開いていない場合

            // 接続中フラグをリセット（重要）
            if (wsManager?.isConnecting) {
                console.log('接続中フラグをリセット');
                wsManager.isConnecting = false;
            }

            // 再接続中フラグもリセット
            if (state.isReconnecting) {
                console.log('再接続中フラグをリセット');
                state.isReconnecting = false;
            }

            // エラーカウントをリセット
            if (wsManager?.errorCount > 0) {
                console.log('エラーカウントをリセット');
                wsManager.errorCount = 0;
            }

            // 古いWebSocketインスタンスがある場合はクリーンアップ
            if (wsManager?.websocket) {
                wsManager.websocket.onopen = null;
                wsManager.websocket.onmessage = null;
                wsManager.websocket.onclose = null;
                wsManager.websocket.onerror = null;
                try {
                    wsManager.websocket.close();
                } catch (e) {
                    console.warn('WebSocket close error during foreground return:', e);
                }
                wsManager.websocket = null;
            }

            // 新規接続を開始
            console.log('WebSocket新規接続を開始');
            wsManager?.init?.();
        } else {
            // 接続が既にある場合はステータス更新を送信
            this.sendImmediateForegroundUpdate();
        }

        // 位置共有の復元処理（必要に応じて）
        if (state.isSharing && state.lastKnownPosition) {
            // 最後の位置を即座に送信
            locationManager.sendLocationUpdate?.(state.lastKnownPosition);
        }
    }

    // ：即座フォアグラウンド状態通知
    sendImmediateForegroundUpdate() {
        const statusData = {
            type: 'immediate_foreground_return', // 新しいタイプ
            participant_id: state.participantId,
            participant_name: state.getParticipantName?.(),
            is_background: false,
            has_position: !!state.lastKnownPosition,
            is_sharing: state.isSharing,
            is_mobile: wsManager?.isMobileDevice?.(),
            page_returning: true,
            immediate_transition: true,
            priority_update: true, // 最優先フラグ
            timestamp: new Date().toISOString()
        };

        const sent = wsManager?.send?.(statusData);

        // 送信失敗時の再試行
        if (!sent) {
            setTimeout(() => {
                if (wsManager?.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                    wsManager.send(statusData);
                }
            }, 100);
        }
    }

    handleTransition(toBackground) {
        if (this.isPageUnloading && !toBackground) {
            return;
        }

        const wasInBackground = state.isInBackground;
        state.isInBackground = toBackground;

        if (toBackground) {
            ui.updateStatus?.('visibility', 'background', 'バックグラウンド');
            locationManager.updateLocationStatus?.();
            this.sendBackgroundStatusUpdate(true, this.isPageUnloading);
        } else {
            ui.updateStatus?.('visibility', 'active', 'アクティブ');
            locationManager.updateLocationStatus?.();
            state.backgroundReconnectAttempts = 0;

            if (!wsManager?.websocket || wsManager.websocket.readyState !== WebSocket.OPEN) {
                wsManager?.init?.();
            } else {
                this.sendBackgroundStatusUpdate(false, false);
            }

            // 共有状態の自動復元
            const savedState = state.load?.();
            if (savedState && savedState.isSharing && !state.isSharing && !state.sessionExpired) {
                setTimeout(() => {
                    locationManager.startSharing?.();
                }, 1000);
            }
        }
    }

    sendBackgroundStatusUpdate(isBackground, isPageUnloading = false) {
        const statusData = {
            type: 'background_status_update',
            participant_id: state.participantId,
            participant_name: state.getParticipantName?.(),
            is_background: isBackground,
            has_position: !!state.lastKnownPosition,
            is_sharing: state.isSharing,
            is_mobile: wsManager?.isMobileDevice?.(),
            page_unloading: isPageUnloading,
            maintain_active: isPageUnloading,
            timestamp: new Date().toISOString(),
            immediate_transition: true
        };

        const sent = wsManager?.send?.(statusData);

        // sendBeacon を使用した確実な送信（ページ閉じ時）
        if (isPageUnloading && navigator.sendBeacon) {
            try {
                const beaconData = new Blob([JSON.stringify({
                    session_id: state.sessionId,
                    participant_id: state.participantId,
                    action: 'background_transition',
                    timestamp: new Date().toISOString(),
                    immediate: true
                })], {
                    type: 'application/json'
                });

                navigator.sendBeacon('/api/background-status/', beaconData);
            } catch (error) {
                console.warn('sendBeacon failed:', error);
            }
        }
    }
}


// === イベントハンドラー管理クラス ===
class EventHandlerManager {
    constructor() {
        this.setupEventListeners();
    }

    // 内部ヘルパー：安全にイベントを付与
    _on(el, type, handler, options) {
        if (!el) return;
        ui.addEventListener ? ui.addEventListener(el, type, handler, options) : el.addEventListener(type, handler, options);
    }

    setupEventListeners() {
        // 共有ボタン
        if (ui.elements.toggleSharing) {
            this._on(ui.elements.toggleSharing, 'click', () => {
                if (state.isSharing) {
                    locationManager.stopSharing();
                } else {
                    const modal = new bootstrap.Modal(document.getElementById('permission-modal'));
                    modal.show();
                }
            });
        }

        // 参加者追加ボタン
        const shareFromParticipantsBtn = document.getElementById('share-from-participants');
        if (shareFromParticipantsBtn) {
            this._on(shareFromParticipantsBtn, 'click', () => {
                this.showShareOptions();
            });
        }

        // ビューリセットボタン
        const resetViewBtn = document.getElementById('reset-view');
        if (resetViewBtn) {
            this._on(resetViewBtn, 'click', () => mapManager.resetAutoFit());
        }

        // セッション退出ボタン
        const leaveSessionBtn = document.getElementById('leave-session');
        if (leaveSessionBtn) {
            this._on(leaveSessionBtn, 'click', () => sessionManager.leave());
        }

        // 位置情報許可ボタン
        const requestLocationBtn = document.getElementById('request-location');
        if (requestLocationBtn) {
            this._on(requestLocationBtn, 'click', () => {
                const modal = bootstrap.Modal.getInstance(document.getElementById('permission-modal'));
                if (modal) modal.hide();
                locationManager.startSharing();
            });
        }

        // 名前変更リスナー
        this.setupNameChangeListener();
    }

    // EventHandlerManager クラスに追加
    showShareOptions() {
        // 既存のモーダルがあれば削除
        const existingModal = document.getElementById('share-options-modal');
        if (existingModal) {
            const bsModal = bootstrap.Modal.getInstance(existingModal);
            if (bsModal) {
                bsModal.dispose();
            }
            existingModal.remove();
        }

        // 共有URLを生成（getExternalBrowserUrl関数を内部で再定義）
        const getShareUrl = () => {
            // 現在のURLをチェック
            const currentUrl = window.location.href;
            const currentParams = new URLSearchParams(window.location.search);

            // 必要なパラメータがすべて揃っているかチェック
            const hasAllParams =
                currentParams.get('openExternalBrowser') === '1' &&
                currentParams.get('utm_source') === 'share' &&
                currentParams.get('utm_medium') === 'share' &&
                currentParams.get('utm_campaign') === 'location_share';

            // すでに適用済みなら現在のURLをそのまま返す
            if (hasAllParams) {
                console.log('共有パラメータは既に適用済みです');
                return currentUrl;
            }

            // 適用されていない場合は、baseURLから構築
            let baseUrl = window.djangoData?.shareUrl || window.location.origin + window.location.pathname;

            if (!baseUrl) {
                console.error('共有URLが取得できません');
                return currentUrl;
            }

            // スラッシュありで統一
            if (!baseUrl.endsWith('/')) {
                baseUrl = baseUrl + '/';
            }

            // 既存のパラメータをクリア（新規構築）
            const url = new URL(baseUrl);
            url.search = ''; // 既存のクエリパラメータをクリア

            // 新しいパラメータを設定
            const params = new URLSearchParams();
            params.set('openExternalBrowser', '1');
            params.set('utm_source', 'share');
            params.set('utm_medium', 'share');
            params.set('utm_campaign', 'location_share');

            url.search = params.toString();

            return url.href;
        };

        const shareUrl = getShareUrl();

        // モーダルを作成
        const modalDiv = document.createElement('div');
        modalDiv.className = 'modal fade';
        modalDiv.id = 'share-options-modal';
        modalDiv.setAttribute('tabindex', '-1');
        modalDiv.style.zIndex = '10001';
        modalDiv.innerHTML = `
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-success text-white">
                    <h5 class="modal-title">
                        <i class="fas fa-user-plus"></i> 参加者を追加
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-3">以下の方法で新しい参加者を招待できます：</p>
                    
                    <!-- URL共有 -->
                    <div class="share-option mb-3">
                        <label class="form-label fw-bold">
                            <i class="fas fa-link"></i> 共有URL
                        </label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="share-url-copy" 
                                   value="${shareUrl}" readonly>
                            <button class="btn btn-outline-secondary" type="button" 
                                    id="copy-url-btn" title="URLをコピー">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <small class="text-muted">URLをコピーして共有してください</small>
                    </div>
                    
                    <!-- QRコード表示 -->
                    <div class="share-option mb-3 text-center">
                        <label class="form-label fw-bold d-block">
                            <i class="fas fa-qrcode"></i> QRコード
                        </label>
                        <div id="modal-qr-code" class="d-inline-block"></div>
                        <div class="mt-2">
                            <small class="text-muted">QRコードをスキャンして参加</small>
                        </div>
                    </div>
                    
                    <!-- 共有ボタン -->
                    <div class="d-grid gap-2">
                        <button class="btn btn-primary" id="share-via-apps">
                            <i class="fas fa-share-alt"></i> アプリで共有
                        </button>
                    </div>
                    
                    <!-- セッション情報 -->
                    <div class="alert alert-info mt-3 mb-0">
                        <small>
                            <i class="fas fa-info-circle"></i> 
                            残り時間: <span id="modal-countdown">${document.getElementById('countdown')?.textContent || ''}</span><br>
                            現在の参加者数: ${state.participantsData.length}人
                        </small>
                    </div>
                </div>
            </div>
        </div>
    `;

        document.body.appendChild(modalDiv);

        // QRコードを生成
        setTimeout(() => {
            this.generateModalQRCode(shareUrl);
        }, 100);

        // イベントリスナーを設定
        const copyBtn = document.getElementById('copy-url-btn');
        if (copyBtn) {
            copyBtn.addEventListener('click', async () => {
                const urlInput = document.getElementById('share-url-copy');
                if (urlInput) {
                    urlInput.select();

                    try {
                        // copyToClipboard関数を内部で実装
                        if (navigator.clipboard && window.isSecureContext) {
                            await navigator.clipboard.writeText(urlInput.value);
                        } else {
                            // フォールバック
                            const textArea = document.createElement('textarea');
                            textArea.value = urlInput.value;
                            textArea.setAttribute('readonly', '');
                            textArea.style.position = 'fixed';
                            textArea.style.left = '-999999px';
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                        }

                        copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                        copyBtn.classList.remove('btn-outline-secondary');
                        copyBtn.classList.add('btn-success');

                        setTimeout(() => {
                            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                            copyBtn.classList.remove('btn-success');
                            copyBtn.classList.add('btn-outline-secondary');
                        }, 2000);

                        ui.showNotification('URLをコピーしました', 'success', 'fas fa-check');
                    } catch (err) {
                        ui.showNotification('コピーに失敗しました', 'error', 'fas fa-times');
                    }
                }
            });
        }

        // アプリで共有ボタン
        const shareBtn = document.getElementById('share-via-apps');
        if (shareBtn) {
            shareBtn.addEventListener('click', () => {
                // Web Share APIを使用
                if (navigator.share && typeof navigator.share === 'function') {
                    navigator.share({
                        title: '位置情報共有',
                        text: '位置情報を共有します',
                        url: shareUrl
                    }).catch(error => {
                        if (error.name !== 'AbortError') {
                            console.error('Share error:', error);
                            // フォールバック：URLをコピー
                            this.copyUrlFallback(shareUrl);
                        }
                    });
                } else {
                    // Web Share APIが使えない場合
                    this.copyUrlFallback(shareUrl);
                }
            });
        }

        // カウントダウンを更新
        const updateModalCountdown = () => {
            const countdownEl = document.getElementById('modal-countdown');
            const mainCountdown = document.getElementById('countdown');
            if (countdownEl && mainCountdown) {
                countdownEl.textContent = mainCountdown.textContent;
            }
        };

        const countdownInterval = setInterval(() => {
            if (!document.getElementById('share-options-modal')) {
                clearInterval(countdownInterval);
                return;
            }
            updateModalCountdown();
        }, 1000);

        // モーダルを表示
        const modal = new bootstrap.Modal(modalDiv);
        modal.show();

        // モーダルが閉じられたらクリーンアップ
        modalDiv.addEventListener('hidden.bs.modal', () => {
            clearInterval(countdownInterval);
            setTimeout(() => {
                modalDiv.remove();
            }, 300);
        });
    }

    // URLコピーのフォールバック関数を追加
    copyUrlFallback(url) {
        navigator.clipboard.writeText(url)
            .then(() => {
                ui.showNotification('URLをクリップボードにコピーしました', 'success', 'fas fa-check');
            })
            .catch(() => {
                ui.showNotification('共有に失敗しました。URLを手動でコピーしてください。', 'warning', 'fas fa-exclamation-triangle');
            });
    }

    generateModalQRCode(shareUrl) {
        const qrContainer = document.getElementById('modal-qr-code');
        if (!qrContainer) return;

        const size = 180;
        const encoded = encodeURIComponent(shareUrl);
        const qrServerUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encoded}&format=png&margin=10`;

        qrContainer.innerHTML = '';
        const img = document.createElement('img');
        img.src = qrServerUrl;
        img.alt = 'QRコード';
        img.width = size;
        img.height = size;
        img.loading = 'lazy';
        img.style.border = '2px solid #dee2e6';
        img.style.borderRadius = '8px';
        img.style.padding = '8px';
        img.style.backgroundColor = 'white';

        img.onerror = function() {
            qrContainer.innerHTML = `
            <div class="text-center p-3 border rounded" style="width: ${size}px; height: ${size}px; display: inline-flex; flex-direction: column; justify-content: center; align-items: center;">
                <i class="fas fa-qrcode fa-2x text-muted mb-2"></i>
                <small class="text-muted">QRコード生成失敗</small>
            </div>
        `;
        };

        qrContainer.appendChild(img);
    }

    setupNameChangeListener() {
        if (ui.elements.participantName) {
            let nameUpdateTimeout;
            let nameValidationTimeout;

            this._on(ui.elements.participantName, 'input', function() {
                let newName = this.value.trim();
                if (newName.length > 30) {
                    newName = newName.substring(0, 30);
                    this.value = newName;
                }

                // リアルタイム重複チェック（入力中）
                clearTimeout(nameValidationTimeout);
                nameValidationTimeout = setTimeout(() => {
                    eventHandlerManager.validateNameDuplicate(newName, this);
                }, 300);

                // 自分のマーカー即座更新
                if (mapManager.markers[state.participantId]) {
                    const color = mapManager.getParticipantColor(state.participantId);
                    const customIcon = mapManager.createCustomMarker(
                        newName || `参加者${state.participantId.substring(0, 4)}`,
                        color,
                        state.isInBackground
                    );
                    mapManager.markers[state.participantId].setIcon(customIcon);
                }

                state.save();

                clearTimeout(nameUpdateTimeout);
                nameUpdateTimeout = setTimeout(() => {
                    // 最終的な名前更新送信前にもチェック
                    eventHandlerManager.sendNameUpdateIfValid(newName);
                }, 800);
            });

            // フォーカス離脱時の最終チェック
            this._on(ui.elements.participantName, 'blur', function() {
                const finalName = this.value.trim();
                if (finalName) {
                    eventHandlerManager.validateAndUpdateName(finalName, this);
                }
            });
        }
    }

    // === ：名前重複チェック ===
    validateNameDuplicate(newName, inputElement) {
        if (!newName) {
            this.clearNameValidation(inputElement);
            return;
        }

        const normalizedNewName = newName.toLowerCase();

        // 現在の参加者リストから自分以外で同じ名前をチェック
        const isDuplicate = state.participantsData.some(participant => {
            const participantName = (participant.participant_name || '').trim().toLowerCase();
            return participant.participant_id !== state.participantId &&
                participantName === normalizedNewName &&
                participant.is_online; // オンラインの参加者のみチェック
        });

        if (isDuplicate) {
            this.showNameDuplicateWarning(inputElement, newName);
        } else {
            this.clearNameValidation(inputElement);
        }
    }

    // === ：重複警告表示 ===
    showNameDuplicateWarning(inputElement, duplicateName) {
        // 既存の警告を削除
        this.clearNameValidation(inputElement);

        // 入力欄のスタイルを警告色に
        inputElement.classList.add('is-invalid');

        // 警告メッセージを作成
        const warningDiv = document.createElement('div');
        warningDiv.className = 'invalid-feedback name-duplicate-warning';
        warningDiv.innerHTML = `
            <i class="fas fa-exclamation-triangle"></i> 
            「${duplicateName.substring(0, 20)}」は既に使用されています
        `;

        // 入力欄の後に警告を挿入
        inputElement.parentNode.insertBefore(warningDiv, inputElement.nextSibling);

        // グローバル通知も表示
        ui.showNotification(
            `名前「${duplicateName.substring(0, 20)}」は既に使用されています`,
            'warning',
            'fas fa-user-times',
            false
        );
    }

    // === ：名前検証クリア ===
    clearNameValidation(inputElement) {
        inputElement.classList.remove('is-invalid', 'is-valid');

        // 既存の警告メッセージを削除
        const existingWarning = inputElement.parentNode.querySelector('.name-duplicate-warning');
        if (existingWarning) {
            existingWarning.remove();
        }
    }

    // === ：有効な名前の場合のみ送信 ===
    sendNameUpdateIfValid(newName) {
        if (!newName) return;

        const normalizedNewName = newName.toLowerCase();

        // 最終重複チェック
        const isDuplicate = state.participantsData.some(participant => {
            const participantName = (participant.participant_name || '').trim().toLowerCase();
            return participant.participant_id !== state.participantId &&
                participantName === normalizedNewName &&
                participant.is_online; // ★ 修正：オンライン参加者のみチェック
        });

        if (isDuplicate) {
            if (ui.elements.participantName) {
                this.showNameDuplicateWarning(ui.elements.participantName, newName);
            }
            return;
        }

        // 重複なしの場合は送信
        const nameUpdateData = {
            type: 'name_update',
            participant_id: state.participantId,
            participant_name: newName,
            check_duplicate: true,
            cleanup_old_offline: true, // ★ 古いオフライン参加者のクリーンアップを要求
            timestamp: new Date().toISOString()
        };

        const sent = wsManager.send(nameUpdateData);
        if (sent) {
            // ★ ローカルでも古いオフライン参加者を削除
            this.cleanupLocalOldOfflineParticipants(newName);

            if (ui.elements.participantName) {
                ui.elements.participantName.classList.remove('is-invalid');
                ui.elements.participantName.classList.add('is-valid');

                setTimeout(() => {
                    if (ui.elements.participantName) {
                        ui.elements.participantName.classList.remove('is-valid');
                    }
                }, 2000);
            }
        }
    }

    // ★ 新規メソッドを追加
    cleanupLocalOldOfflineParticipants(newName) {
        const normalizedNewName = newName.toLowerCase();

        // ローカルの参加者データから古いオフライン参加者を削除
        state.participantsData = state.participantsData.filter(participant => {
            const participantName = (participant.participant_name || '').trim().toLowerCase();

            // 同じ名前のオフライン参加者を削除（自分以外）
            if (participant.participant_id !== state.participantId &&
                participantName === normalizedNewName &&
                !participant.is_online) {

                // マーカーも削除
                if (mapManager.markers[participant.participant_id]) {
                    mapManager.removeMarker(participant.participant_id);
                }

                return false; // フィルターから除外
            }

            return true; // 維持
        });

        // 参加者リストを更新
        participantManager.updateDisplay();
    }

    // === ：名前検証と更新 ===
    validateAndUpdateName(finalName, inputElement) {
        const normalizedFinalName = finalName.toLowerCase();

        const isDuplicate = state.participantsData.some(participant => {
            const participantName = (participant.participant_name || '').trim().toLowerCase();
            return participant.participant_id !== state.participantId &&
                participantName === normalizedFinalName &&
                participant.is_online;
        });

        if (isDuplicate) {
            // 重複の場合、一意な名前を提案
            const suggestedName = this.generateUniqueName(finalName);

            const confirmChange = confirm(
                `「${finalName}」は既に使用されています。\n` +
                `「${suggestedName}」に変更しますか？\n\n` +
                `キャンセルすると元の名前に戻ります。`
            );

            if (confirmChange) {
                inputElement.value = suggestedName;
                this.sendNameUpdateIfValid(suggestedName);
                ui.showNotification(`名前を「${suggestedName}」に変更しました`, 'success');
            } else {
                // 元の名前に戻す
                const currentName = state.participantsData.find(p => p.participant_id === state.participantId)?.participant_name || '';
                inputElement.value = currentName;
                this.clearNameValidation(inputElement);
            }
        } else {
            // 重複なしの場合
            this.sendNameUpdateIfValid(finalName);
        }
    }

    // === ：一意な名前を生成 ===
    generateUniqueName(baseName) {
        let counter = 1;
        let suggestedName = `${baseName}${counter}`;

        while (counter < 100) { // 無限ループ防止
            const normalizedSuggested = suggestedName.toLowerCase();

            const exists = state.participantsData.some(participant => {
                const participantName = (participant.participant_name || '').trim().toLowerCase();
                return participant.participant_id !== state.participantId &&
                    participantName === normalizedSuggested &&
                    participant.is_online;
            });

            if (!exists) {
                return suggestedName.substring(0, 30); // 長さ制限
            }

            counter++;
            suggestedName = `${baseName}${counter}`;
        }

        // 最終手段：ランダム数字を追加
        const randomSuffix = Math.floor(Math.random() * 1000);
        return `${baseName}${randomSuffix}`.substring(0, 30);
    }
}

// === アプリケーション初期化と制御 ===
class LocationSharingApp {
    constructor() {
        this.initializeComponents();
        this.setupPeriodicTasks();
        this.setupPageUnloadHandler();
    }

    // 内部ヘルパー：WebSocketを完全リセット
    _resetWebSocketFully(contextLabel = 'reset') {
        if (!wsManager) return;

        // 古いWebSocketを確実にクリーンアップ
        if (wsManager.websocket) {
            wsManager.websocket.onopen = null;
            wsManager.websocket.onmessage = null;
            wsManager.websocket.onclose = null;
            wsManager.websocket.onerror = null;
            try {
                wsManager.websocket.close();
            } catch (e) {
                console.warn(`WebSocket close error during ${contextLabel}:`, e);
            }
            wsManager.websocket = null;
        }

        // 接続関連のフラグを全てリセット
        wsManager.errorCount = 0;
        wsManager.isConnecting = false;
        state.isReconnecting = false;

        // インターバルタイマーもクリア
        if (wsManager.connectionInterval) {
            clearInterval(wsManager.connectionInterval);
            wsManager.connectionInterval = null;
        }
    }

    initializeComponents() {
        // グローバルインスタンスを作成
        window.state = new LocationSharingState();
        window.ui = new UIManager();
        window.wsManager = new WebSocketManager();
        window.messageHandler = new MessageHandler();
        window.locationManager = new LocationManager();
        window.mapManager = new MapManager();
        window.participantManager = new ParticipantManager();
        window.sessionManager = new SessionManager();
        window.backgroundManager = new BackgroundManager();
        window.eventHandlerManager = new EventHandlerManager();
        window.chatManager = new ChatManager();

        // 短縮参照を作成（元コードのまま温存）
        window.state = state;
        window.ui = ui;
        window.wsManager = wsManager;
        window.messageHandler = messageHandler;
        window.locationManager = locationManager;
        window.mapManager = mapManager;
        window.participantManager = participantManager;
        window.sessionManager = sessionManager;
        window.backgroundManager = backgroundManager;
    }

    async init() {
        console.log('=== アプリケーション初期化開始 ===');

        // ★ 追加：退出フラグをチェック
        const leavingFlag = localStorage.getItem(`leaving_${state.sessionId}`);
        const leavingTimestamp = localStorage.getItem(`leaving_timestamp_${state.sessionId}`);

        if (leavingFlag === 'true' && leavingTimestamp) {
            const elapsed = Date.now() - parseInt(leavingTimestamp);
            // 10秒以内の退出フラグは有効とみなす
            if (elapsed < 10000) {
                console.log('退出処理中のため初期化を中止');
                // フラグをクリア
                localStorage.removeItem(`leaving_${state.sessionId}`);
                localStorage.removeItem(`leaving_timestamp_${state.sessionId}`);
                // ホーム画面にリダイレクト
                window.location.href = '/';
                return;
            } else {
                // 古いフラグはクリア
                localStorage.removeItem(`leaving_${state.sessionId}`);
                localStorage.removeItem(`leaving_timestamp_${state.sessionId}`);
            }
        }

        // マップを初期化
        mapManager.init();

        // 保存された状態を復元
        this.restoreSessionState();

        // 参加者リストを初期状態に設定
        if (ui.elements.participantsList) {
            ui.elements.participantsList.innerHTML = '<div class="text-center text-muted">参加者情報を読み込み中...</div>';
        }

        // WebSocket接続を開始（即座に）
        wsManager.init();

        // 初期ステータス更新
        ui.updateCountdown();
        ui.updateStatus('visibility', 'active', 'アクティブ');
    }

    restoreSessionState() {
        const savedState = state.load();
        if (!savedState) {
            return;
        }

        // 名前の復元
        if (savedState.participantName && ui.elements.participantName) {
            ui.elements.participantName.value = savedState.participantName;
        }

        // 位置情報の復元
        if (savedState.lastPosition) {
            state.lastKnownPosition = {
                coords: {
                    latitude: savedState.lastPosition.latitude,
                    longitude: savedState.lastPosition.longitude,
                    accuracy: savedState.lastPosition.accuracy
                },
                timestamp: savedState.lastPosition.timestamp
            };
        }

        // 共有状態の復元
        if (savedState.isSharing) {
            const timeSinceSharing = Date.now() - (savedState.savedAt || 0);
            if (timeSinceSharing < CONFIG.POSITION_CACHE_DURATION) {
                setTimeout(() => {
                    if (!state.isSharing && !state.sessionExpired) {
                        ui.showNotification('前回の共有状態を復元しました', 'info');
                        locationManager.startSharing();
                    }
                }, 1500);
            } else {
                state.clear();
            }
        }
    }

    setupPeriodicTasks() {
        // カウントダウン更新
        setInterval(() => ui.updateCountdown(), 1000);

        // 参加者表示更新
        setInterval(() => participantManager.updateDisplay(), CONFIG.PARTICIPANTS_UPDATE);

        // 定期的な状態保存
        setInterval(() => {
            if (state.isSharing) {
                state.save();
            }
        }, 30000);
    }

    // === アプリケーション初期化と制御 - setupPageUnloadHandler メソッドの修正 ===
    setupPageUnloadHandler() {
        // ページ表示時の処理
        window.addEventListener('pageshow', (e) => {
            // ページキャッシュから復帰した場合
            if (e.persisted) {
                console.log('ページキャッシュから復帰');

                // WebSocket関連のフラグと状態を完全リセット
                if (wsManager) {
                    this._resetWebSocketFully('pageshow');

                    // 少し待ってから新規接続を開始
                    setTimeout(() => {
                        if (!state.isLeaving && !state.sessionExpired) {
                            console.log('WebSocket再接続を開始');
                            wsManager.init();
                        }
                    }, 500);
                }
            }
        });

        // visibilitychange イベントでも同様の処理を追加
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && wsManager) {
                // ページが表示状態になった時
                if ((!wsManager.websocket || wsManager.websocket.readyState !== WebSocket.OPEN) &&
                    wsManager.isConnecting) {
                    // 接続中フラグが残っている場合はリセット
                    console.log('接続中フラグをリセット');
                    wsManager.isConnecting = false;
                    state.isReconnecting = false;

                    // エラーカウントもリセット
                    wsManager.errorCount = 0;

                    // 再接続を試行
                    setTimeout(() => {
                        if (!state.isLeaving && !state.sessionExpired) {
                            wsManager.init();
                        }
                    }, 1000);
                }
            }
        });

        // 既存のbeforeunload処理はそのまま
        window.addEventListener('beforeunload', (e) => {
            // WebSocket接続を適切に閉じる
            if (wsManager.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                try {
                    wsManager.websocket.close(1000, 'page_unload');
                } catch (error) {
                    console.warn('WebSocket close error:', error);
                }
            }

            // チャットマネージャーのクリーンアップ
            if (window.chatManager) {
                chatManager.cleanup();
            }

            // クリーンアップ
            ui.cleanup();
        });

        // unload でも念のため処理
        window.addEventListener('unload', () => {
            if (wsManager.websocket) {
                try {
                    wsManager.websocket.close(1000, 'page_unload');
                } catch (error) {
                    console.warn('Final WebSocket close error:', error);
                }
            }
        });

        // pagehide - モバイルやタブ切り替え対応
        window.addEventListener('pagehide', (e) => {
            if (wsManager.websocket && wsManager.websocket.readyState === WebSocket.OPEN) {
                try {
                    wsManager.websocket.close(1000, 'page_unload');
                } catch (error) {
                    console.warn('Pagehide WebSocket close error:', error);
                }
            }
        });
    }
}

// === ユーティリティ関数 ===
function requestLocation() {
    const modal = bootstrap.Modal.getInstance(document.getElementById('permission-modal'));
    if (modal) modal.hide();
    locationManager.startSharing();
}

// === データ整合性とセキュリティ ===
function validateData() {
    const data = window.djangoData;

    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

    if (!uuidRegex.test(data.sessionId)) {
        console.error('Invalid session ID format');
        window.location.href = '/';
        return false;
    }

    if (!uuidRegex.test(data.participantId)) {
        console.error('Invalid participant ID format');
        window.location.href = '/';
        return false;
    }

    const expiresDate = new Date(data.expiresAt);
    if (isNaN(expiresDate.getTime())) {
        console.error('Invalid expires date format');
        window.location.href = '/';
        return false;
    }

    if (expiresDate <= new Date()) {
        console.warn('Session already expired');
        const modal = document.getElementById('session-expired-modal');
        if (modal) {
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }
        return false;
    }

    return true;
}

// === アプリケーション開始 ===
document.addEventListener('DOMContentLoaded', function() {
    // データ整合性チェック
    if (!validateData()) {
        return;
    }

    // アプリケーションを初期化して開始
    const app = new LocationSharingApp();
    app.init().catch(error => {
        console.error('アプリケーション初期化エラー:', error);
        ui.showNotification('アプリケーションの初期化に失敗しました', 'error');
    });
    
    // セッション無効化ボタン押下後
    const btn = document.getElementById("invalidate-session");
    if (btn) {
    btn.addEventListener("click", async () => {
        if (!confirm("このセッションを無効化しますか？\n全員の共有が即時停止されます。")) return;

        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 無効化中...';

        try {
        const res = await fetch(`/api/session/${state.sessionId}/invalidate/`, {
            method: "POST",
            headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": window.djangoData?.csrfToken || "",
            },
            body: JSON.stringify({ participant_id: state.participantId })
        });
        const data = await res.json();

        if (data.success) {
            // ▼ ここで「無効化」用にモーダル文言へ差し替え
            //   SessionManager があればそれを使う
            if (window.sessionManager?.handleExpired) {
            sessionManager.handleExpired('invalidated');
            } else {
            // 念のためのフォールバック（直接DOM書き換え）
            const header = document.getElementById('expired-modal-header');
            const content = document.getElementById('expired-modal-content');
            const icon = document.getElementById('expired-title-icon');
            const titleText = document.getElementById('expired-title-text');
            const lead = document.getElementById('expired-lead');
            const desc = document.getElementById('expired-desc');
            header?.classList.remove('bg-danger'); header?.classList.add('bg-secondary', 'text-white');
            content?.classList.remove('border-danger'); content?.classList.add('border-secondary');
            if (icon) icon.className = 'fas fa-ban me-2';
            if (titleText) titleText.textContent = 'セッションは無効化されました';
            if (lead) { lead.classList.remove('alert-warning'); lead.classList.add('alert-secondary'); lead.innerHTML = '<i class="fas fa-ban me-2"></i> このセッションは参加者により無効化されました。'; }
            if (desc) { desc.innerHTML = '全参加者の位置情報共有を停止し、関連データのクリーンアップを実行しました。<br>必要に応じて新しいセッションを作成してください。'; }
            const modalEl = document.getElementById('session-expired-modal');
            if (modalEl && window.bootstrap?.Modal) new bootstrap.Modal(modalEl).show();
            }

            // 状態も停止方向へ
            state.sessionExpired = true;
            locationManager.stopSharing?.();
            // 任意：WSの自動再接続があれば止める
            if (window.wsManager?.websocket?.readyState === WebSocket.OPEN) {
            try { wsManager.websocket.close(1000, 'session_invalidated'); } catch {}
            }
        } else {
            alert("無効化失敗: " + (data.error || data.message));
        }
        } catch (e) {
        console.error("invalidate error:", e);
        alert("エラーが発生しました。");
        } finally {
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-ban"></i> セッション無効化';
        }
    });
    }
});


function goToHome() {
    window.location.href = '/';
}